"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-google-maps";
exports.ids = ["vendor-chunks/@react-google-maps"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-google-maps/api/dist/cjs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-google-maps/api/dist/cjs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/shared/react-jsx-runtime.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest$1(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter$1(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar NODE_ENV = \"development\";\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nvar invariant_1 = invariant;\n\nvar invariant$1 = /*@__PURE__*/getDefaultExportFromCjs(invariant_1);\n\nvar MapContext = react.createContext(null);\nfunction useGoogleMap() {\n    invariant$1(!!react.useContext, 'useGoogleMap is React hook and requires React version 16.8+');\n    var map = react.useContext(MapContext);\n    invariant$1(!!map, 'useGoogleMap needs a GoogleMap available up in the tree');\n    return map;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction reduce(obj, fn, acc) {\n    return Object.keys(obj).reduce(function reducer(newAcc, key) {\n        return fn(newAcc, obj[key], key);\n    }, acc);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction forEach(obj, fn) {\n    Object.keys(obj).forEach(function (key) {\n        return fn(obj[key], key);\n    });\n}\n\n/* global google */\nfunction applyUpdaterToNextProps(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nupdaterMap, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprevProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnextProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var map = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var iter = function (fn, key) {\n        var nextValue = nextProps[key];\n        if (nextValue !== prevProps[key]) {\n            map[key] = nextValue;\n            fn(instance, nextValue);\n        }\n    };\n    forEach(updaterMap, iter);\n    return map;\n}\nfunction registerEvents(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprops, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance, eventMap) {\n    var registeredList = reduce(eventMap, function reducer(acc, googleEventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onEventName) {\n        if (typeof props[onEventName] === 'function') {\n            acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));\n        }\n        return acc;\n    }, []);\n    return registeredList;\n}\nfunction unregisterEvent(registered) {\n    google.maps.event.removeListener(registered);\n}\nfunction unregisterEvents(events) {\n    if (events === void 0) { events = []; }\n    events.forEach(unregisterEvent);\n}\nfunction applyUpdatersToPropsAndRegisterEvents(_a) {\n    var updaterMap = _a.updaterMap, eventMap = _a.eventMap, prevProps = _a.prevProps, nextProps = _a.nextProps, instance = _a.instance;\n    var registeredEvents = registerEvents(nextProps, instance, eventMap);\n    applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);\n    return registeredEvents;\n}\n\nvar eventMap$i = {\n    onDblClick: 'dblclick',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMapTypeIdChanged: 'maptypeid_changed',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseDown: 'mousedown',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n    onTilesLoaded: 'tilesloaded',\n    onBoundsChanged: 'bounds_changed',\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onDrag: 'drag',\n    onHeadingChanged: 'heading_changed',\n    onIdle: 'idle',\n    onProjectionChanged: 'projection_changed',\n    onResize: 'resize',\n    onTiltChanged: 'tilt_changed',\n    onZoomChanged: 'zoom_changed',\n};\nvar updaterMap$i = {\n    extraMapTypes: function (map, extra) {\n        extra.forEach(function forEachExtra(it, i) {\n            map.mapTypes.set(String(i), it);\n        });\n    },\n    center: function (map, center) {\n        map.setCenter(center);\n    },\n    clickableIcons: function (map, clickable) {\n        map.setClickableIcons(clickable);\n    },\n    heading: function (map, heading) {\n        map.setHeading(heading);\n    },\n    mapTypeId: function (map, mapTypeId) {\n        map.setMapTypeId(mapTypeId);\n    },\n    options: function (map, options) {\n        map.setOptions(options);\n    },\n    streetView: function (map, streetView) {\n        map.setStreetView(streetView);\n    },\n    tilt: function (map, tilt) {\n        map.setTilt(tilt);\n    },\n    zoom: function (map, zoom) {\n        map.setZoom(zoom);\n    },\n};\n// TODO: unfinished!\nfunction GoogleMapFunctional(_a) {\n    var children = _a.children, options = _a.options, id = _a.id, mapContainerStyle = _a.mapContainerStyle, mapContainerClassName = _a.mapContainerClassName, center = _a.center, \n    // clickableIcons,\n    // extraMapTypes,\n    // heading,\n    // mapTypeId,\n    onClick = _a.onClick, onDblClick = _a.onDblClick, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, \n    // onMapTypeIdChanged,\n    // onTilesLoaded,\n    // onBoundsChanged,\n    onCenterChanged = _a.onCenterChanged, \n    // onHeadingChanged,\n    // onIdle,\n    // onProjectionChanged,\n    // onResize,\n    // onTiltChanged,\n    // onZoomChanged,\n    onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var _b = react.useState(null), map = _b[0], setMap = _b[1];\n    var ref = react.useRef(null);\n    // const [extraMapTypesListener, setExtraMapTypesListener] = useState<google.maps.MapsEventListener | null>(null)\n    var _c = react.useState(null), centerChangedListener = _c[0], setCenterChangedListener = _c[1];\n    var _d = react.useState(null), dblclickListener = _d[0], setDblclickListener = _d[1];\n    var _e = react.useState(null), dragendListener = _e[0], setDragendListener = _e[1];\n    var _f = react.useState(null), dragstartListener = _f[0], setDragstartListener = _f[1];\n    var _g = react.useState(null), mousedownListener = _g[0], setMousedownListener = _g[1];\n    var _h = react.useState(null), mousemoveListener = _h[0], setMousemoveListener = _h[1];\n    var _j = react.useState(null), mouseoutListener = _j[0], setMouseoutListener = _j[1];\n    var _k = react.useState(null), mouseoverListener = _k[0], setMouseoverListener = _k[1];\n    var _l = react.useState(null), mouseupListener = _l[0], setMouseupListener = _l[1];\n    var _m = react.useState(null), rightclickListener = _m[0], setRightclickListener = _m[1];\n    var _o = react.useState(null), clickListener = _o[0], setClickListener = _o[1];\n    var _p = react.useState(null), dragListener = _p[0], setDragListener = _p[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (options && map !== null) {\n            map.setOptions(options);\n        }\n    }, [map, options]);\n    react.useEffect(function () {\n        if (map !== null && typeof center !== 'undefined') {\n            map.setCenter(center);\n        }\n    }, [map, center]);\n    react.useEffect(function () {\n        if (map && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(map, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (map && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(map, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (map && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(map, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (map && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(map, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (map && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(map, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (map && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(map, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (map && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(map, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (map && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(map, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (map && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(map, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (map && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(map, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (map && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(map, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        if (map && onCenterChanged) {\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            setCenterChangedListener(google.maps.event.addListener(map, 'center_changed', onCenterChanged));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        var map = ref.current === null\n            ? null\n            : new google.maps.Map(ref.current, options);\n        setMap(map);\n        if (map !== null && onLoad) {\n            onLoad(map);\n        }\n        return function () {\n            if (map !== null) {\n                if (onUnmount) {\n                    onUnmount(map);\n                }\n            }\n        };\n    }, []);\n    return (jsxRuntime.jsx(\"div\", { id: id, ref: ref, style: mapContainerStyle, className: mapContainerClassName, children: jsxRuntime.jsx(MapContext.Provider, { value: map, children: map !== null ? children : jsxRuntime.jsx(jsxRuntime.Fragment, {}) }) }));\n}\nreact.memo(GoogleMapFunctional);\nvar GoogleMap = /** @class */ (function (_super) {\n    __extends(GoogleMap, _super);\n    function GoogleMap() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            map: null,\n        };\n        _this.registeredEvents = [];\n        _this.mapRef = null;\n        _this.getInstance = function () {\n            if (_this.mapRef === null) {\n                return null;\n            }\n            return new google.maps.Map(_this.mapRef, _this.props.options);\n        };\n        _this.panTo = function (latLng) {\n            var map = _this.getInstance();\n            if (map) {\n                map.panTo(latLng);\n            }\n        };\n        _this.setMapCallback = function () {\n            if (_this.state.map !== null) {\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.map);\n                }\n            }\n        };\n        _this.getRef = function (ref) {\n            _this.mapRef = ref;\n        };\n        return _this;\n    }\n    GoogleMap.prototype.componentDidMount = function () {\n        var map = this.getInstance();\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$i,\n            eventMap: eventMap$i,\n            prevProps: {},\n            nextProps: this.props,\n            instance: map,\n        });\n        this.setState(function setMap() {\n            return {\n                map: map,\n            };\n        }, this.setMapCallback);\n    };\n    GoogleMap.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.map !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$i,\n                eventMap: eventMap$i,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.map,\n            });\n        }\n    };\n    GoogleMap.prototype.componentWillUnmount = function () {\n        if (this.state.map !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.map);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    GoogleMap.prototype.render = function () {\n        return (jsxRuntime.jsx(\"div\", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: jsxRuntime.jsx(MapContext.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : jsxRuntime.jsx(jsxRuntime.Fragment, {}) }) }));\n    };\n    return GoogleMap;\n}(react.PureComponent));\n\nvar isBrowser = typeof document !== 'undefined';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction injectScript(_a) {\n    var url = _a.url, id = _a.id, nonce = _a.nonce;\n    if (!isBrowser) {\n        return Promise.reject(new Error('document is undefined'));\n    }\n    return new Promise(function injectScriptCallback(resolve, reject) {\n        var existingScript = document.getElementById(id);\n        var windowWithGoogleMap = window;\n        if (existingScript) {\n            // Same script id/url: keep same script\n            var dataStateAttribute = existingScript.getAttribute('data-state');\n            if (existingScript.src === url && dataStateAttribute !== 'error') {\n                if (dataStateAttribute === 'ready') {\n                    return resolve(id);\n                }\n                else {\n                    var originalInitMap_1 = windowWithGoogleMap.initMap;\n                    var originalErrorCallback_1 = existingScript.onerror;\n                    windowWithGoogleMap.initMap = function initMap() {\n                        if (originalInitMap_1) {\n                            originalInitMap_1();\n                        }\n                        resolve(id);\n                    };\n                    existingScript.onerror = function (err) {\n                        if (originalErrorCallback_1) {\n                            originalErrorCallback_1(err);\n                        }\n                        reject(err);\n                    };\n                    return;\n                }\n            }\n            // Same script id, but either\n            // 1. requested URL is different\n            // 2. script failed to load\n            else {\n                existingScript.remove();\n            }\n        }\n        var script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        script.id = id;\n        script.async = true;\n        script.nonce = nonce || '';\n        script.onerror = function onerror(err) {\n            script.setAttribute('data-state', 'error');\n            reject(err);\n        };\n        windowWithGoogleMap.initMap = function onload() {\n            script.setAttribute('data-state', 'ready');\n            resolve(id);\n        };\n        document.head.appendChild(script);\n    }).catch(function (err) {\n        console.error('injectScript error: ', err);\n        throw err;\n    });\n}\n\nfunction isGoogleFontStyle(element) {\n    // 'Roboto' or 'Google Sans Text' font download\n    var href = element.href;\n    if (href && (href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0 ||\n        href.indexOf('https://fonts.googleapis.com/css?family=Google+Sans+Text') === 0)) {\n        return true;\n    }\n    // font style elements\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText = '';\n        return true;\n    }\n    // font style elements for other browsers\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML = '';\n        return true;\n    }\n    // when google tries to add empty style\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        !element.styleSheet &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        !element.innerHTML) {\n        return true;\n    }\n    return false;\n}\n// Preventing the Google Maps library from downloading an extra font\nfunction preventGoogleFonts() {\n    // we override these methods only for one particular head element\n    // default methods for other elements are not affected\n    var head = document.getElementsByTagName('head')[0];\n    if (head) {\n        var trueInsertBefore_1 = head.insertBefore.bind(head);\n        // TODO: adding return before reflect solves the TS issue\n        head.insertBefore = function insertBefore(newElement, referenceElement) {\n            if (!isGoogleFontStyle(newElement)) {\n                Reflect.apply(trueInsertBefore_1, head, [newElement, referenceElement]);\n            }\n            return newElement;\n        };\n        var trueAppend_1 = head.appendChild.bind(head);\n        // TODO: adding return before reflect solves the TS issue\n        head.appendChild = function appendChild(textNode) {\n            if (!isGoogleFontStyle(textNode)) {\n                Reflect.apply(trueAppend_1, head, [textNode]);\n            }\n            return textNode;\n        };\n    }\n}\n\nfunction makeLoadScriptUrl(_a) {\n    var googleMapsApiKey = _a.googleMapsApiKey, googleMapsClientId = _a.googleMapsClientId, _b = _a.version, version = _b === void 0 ? 'weekly' : _b, language = _a.language, region = _a.region, libraries = _a.libraries, channel = _a.channel, mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var params = [];\n    invariant$1((googleMapsApiKey && googleMapsClientId) || !(googleMapsApiKey && googleMapsClientId), 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.');\n    if (googleMapsApiKey) {\n        params.push(\"key=\".concat(googleMapsApiKey));\n    }\n    else if (googleMapsClientId) {\n        params.push(\"client=\".concat(googleMapsClientId));\n    }\n    if (version) {\n        params.push(\"v=\".concat(version));\n    }\n    if (language) {\n        params.push(\"language=\".concat(language));\n    }\n    if (region) {\n        params.push(\"region=\".concat(region));\n    }\n    if (libraries && libraries.length) {\n        params.push(\"libraries=\".concat(libraries.sort().join(',')));\n    }\n    if (channel) {\n        params.push(\"channel=\".concat(channel));\n    }\n    if (mapIds && mapIds.length) {\n        params.push(\"map_ids=\".concat(mapIds.join(',')));\n    }\n    if (authReferrerPolicy) {\n        params.push(\"auth_referrer_policy=\".concat(authReferrerPolicy));\n    }\n    params.push('callback=initMap');\n    return \"https://maps.googleapis.com/maps/api/js?\".concat(params.join('&'));\n}\n\nvar cleaningUp = false;\nfunction DefaultLoadingElement() {\n    return jsxRuntime.jsx(\"div\", { children: \"Loading...\" });\n}\nvar defaultLoadScriptProps = {\n    id: 'script-loader',\n    version: 'weekly',\n};\nvar LoadScript = /** @class */ (function (_super) {\n    __extends(LoadScript, _super);\n    function LoadScript() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.check = react.createRef();\n        _this.state = {\n            loaded: false,\n        };\n        _this.cleanupCallback = function () {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            delete window.google.maps;\n            _this.injectScript();\n        };\n        _this.isCleaningUp = function () { return __awaiter$1(_this, void 0, void 0, function () {\n            function promiseCallback(resolve) {\n                if (!cleaningUp) {\n                    resolve();\n                }\n                else {\n                    if (isBrowser) {\n                        var timer_1 = window.setInterval(function interval() {\n                            if (!cleaningUp) {\n                                window.clearInterval(timer_1);\n                                resolve();\n                            }\n                        }, 1);\n                    }\n                }\n                return;\n            }\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(promiseCallback)];\n            });\n        }); };\n        _this.cleanup = function () {\n            cleaningUp = true;\n            var script = document.getElementById(_this.props.id);\n            if (script && script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n            Array.prototype.slice\n                .call(document.getElementsByTagName('script'))\n                .filter(function filter(script) {\n                return typeof script.src === 'string' && script.src.includes('maps.googleapis');\n            })\n                .forEach(function forEach(script) {\n                if (script.parentNode) {\n                    script.parentNode.removeChild(script);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('link'))\n                .filter(function filter(link) {\n                return (link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans');\n            })\n                .forEach(function forEach(link) {\n                if (link.parentNode) {\n                    link.parentNode.removeChild(link);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('style'))\n                .filter(function filter(style) {\n                return (style.innerText !== undefined &&\n                    style.innerText.length > 0 &&\n                    style.innerText.includes('.gm-'));\n            })\n                .forEach(function forEach(style) {\n                if (style.parentNode) {\n                    style.parentNode.removeChild(style);\n                }\n            });\n        };\n        _this.injectScript = function () {\n            if (_this.props.preventGoogleFontsLoading) {\n                preventGoogleFonts();\n            }\n            invariant$1(!!_this.props.id, 'LoadScript requires \"id\" prop to be a string: %s', _this.props.id);\n            var injectScriptOptions = {\n                id: _this.props.id,\n                nonce: _this.props.nonce,\n                url: makeLoadScriptUrl(_this.props),\n            };\n            injectScript(injectScriptOptions)\n                .then(function () {\n                if (_this.props.onLoad) {\n                    _this.props.onLoad();\n                }\n                _this.setState(function setLoaded() {\n                    return {\n                        loaded: true,\n                    };\n                });\n                return;\n            })\n                .catch(function (err) {\n                if (_this.props.onError) {\n                    _this.props.onError(err);\n                }\n                console.error(\"\\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(_this\n                    .props.googleMapsApiKey || '-', \") or Client ID (\").concat(_this.props.googleMapsClientId ||\n                    '-', \") to <LoadScript />\\n          Otherwise it is a Network issue.\\n        \"));\n            });\n        };\n        return _this;\n    }\n    LoadScript.prototype.componentDidMount = function () {\n        if (isBrowser) {\n            if (window.google && window.google.maps && !cleaningUp) {\n                console.error('google api is already presented');\n                return;\n            }\n            this.isCleaningUp()\n                .then(this.injectScript)\n                .catch(function error(err) {\n                console.error('Error at injecting script after cleaning up: ', err);\n            });\n        }\n    };\n    LoadScript.prototype.componentDidUpdate = function (prevProps) {\n        if (this.props.libraries !== prevProps.libraries) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        if (isBrowser && prevProps.language !== this.props.language) {\n            this.cleanup();\n            // TODO: refactor to use gDSFP maybe... wait for hooks refactoring.\n            this.setState(function setLoaded() {\n                return {\n                    loaded: false,\n                };\n            }, this.cleanupCallback);\n        }\n    };\n    LoadScript.prototype.componentWillUnmount = function () {\n        var _this = this;\n        if (isBrowser) {\n            this.cleanup();\n            var timeoutCallback = function () {\n                if (!_this.check.current) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    delete window.google;\n                    cleaningUp = false;\n                }\n            };\n            window.setTimeout(timeoutCallback, 1);\n            if (this.props.onUnmount) {\n                this.props.onUnmount();\n            }\n        }\n    };\n    LoadScript.prototype.render = function () {\n        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(\"div\", { ref: this.check }), this.state.loaded\n                    ? this.props.children\n                    : this.props.loadingElement || jsxRuntime.jsx(DefaultLoadingElement, {})] }));\n    };\n    LoadScript.defaultProps = defaultLoadScriptProps;\n    return LoadScript;\n}(react.PureComponent));\n\n/* eslint-disable filenames/match-regex */\nvar previouslyLoadedUrl;\nfunction useLoadScript(_a) {\n    var _b = _a.id, id = _b === void 0 ? defaultLoadScriptProps.id : _b, _c = _a.version, version = _c === void 0 ? defaultLoadScriptProps.version : _c, nonce = _a.nonce, googleMapsApiKey = _a.googleMapsApiKey, googleMapsClientId = _a.googleMapsClientId, language = _a.language, region = _a.region, libraries = _a.libraries, preventGoogleFontsLoading = _a.preventGoogleFontsLoading, channel = _a.channel, mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var isMounted = react.useRef(false);\n    var _d = react.useState(false), isLoaded = _d[0], setLoaded = _d[1];\n    var _e = react.useState(undefined), loadError = _e[0], setLoadError = _e[1];\n    react.useEffect(function trackMountedState() {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    react.useEffect(function applyPreventGoogleFonts() {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    react.useEffect(function validateLoadedState() {\n        if (isLoaded) {\n            invariant$1(!!window.google, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.');\n        }\n    }, [isLoaded]);\n    var url = makeLoadScriptUrl({\n        version: version,\n        googleMapsApiKey: googleMapsApiKey,\n        googleMapsClientId: googleMapsClientId,\n        language: language,\n        region: region,\n        libraries: libraries,\n        channel: channel,\n        mapIds: mapIds,\n        authReferrerPolicy: authReferrerPolicy\n    });\n    react.useEffect(function loadScriptAndModifyLoadedState() {\n        if (!isBrowser) {\n            return;\n        }\n        function setLoadedIfMounted() {\n            if (isMounted.current) {\n                setLoaded(true);\n                previouslyLoadedUrl = url;\n            }\n        }\n        if (window.google && window.google.maps && previouslyLoadedUrl === url) {\n            setLoadedIfMounted();\n            return;\n        }\n        injectScript({ id: id, url: url, nonce: nonce })\n            .then(setLoadedIfMounted)\n            .catch(function handleInjectError(err) {\n            if (isMounted.current) {\n                setLoadError(err);\n            }\n            console.warn(\"\\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(googleMapsApiKey ||\n                '-', \") or Client ID (\").concat(googleMapsClientId || '-', \")\\n        Otherwise it is a Network issue.\\n      \"));\n            console.error(err);\n        });\n    }, [id, url, nonce]);\n    var prevLibraries = react.useRef();\n    react.useEffect(function checkPerformance() {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded: isLoaded, loadError: loadError, url: url };\n}\n\nvar defaultLoadingElement = jsxRuntime.jsx(DefaultLoadingElement, {});\nfunction LoadScriptNext(_a) {\n    var loadingElement = _a.loadingElement, onLoad = _a.onLoad, onError = _a.onError, onUnmount = _a.onUnmount, children = _a.children, hookOptions = __rest$1(_a, [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"]);\n    var _b = useLoadScript(hookOptions), isLoaded = _b.isLoaded, loadError = _b.loadError;\n    react.useEffect(function handleOnLoad() {\n        if (isLoaded && typeof onLoad === 'function') {\n            onLoad();\n        }\n    }, [isLoaded, onLoad]);\n    react.useEffect(function handleOnError() {\n        if (loadError && typeof onError === 'function') {\n            onError(loadError);\n        }\n    }, [loadError, onError]);\n    react.useEffect(function handleOnUnmount() {\n        return function () {\n            if (onUnmount) {\n                onUnmount();\n            }\n        };\n    }, [onUnmount]);\n    return isLoaded ? children : loadingElement || defaultLoadingElement;\n}\nvar LoadScriptNext$1 = react.memo(LoadScriptNext);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual$1 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at.\n *\n *      Http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ID = \"__googleMapsScriptId\";\n/**\n * The status of the [[Loader]].\n */\nvar LoaderStatus;\n(function (LoaderStatus) {\n    LoaderStatus[LoaderStatus[\"INITIALIZED\"] = 0] = \"INITIALIZED\";\n    LoaderStatus[LoaderStatus[\"LOADING\"] = 1] = \"LOADING\";\n    LoaderStatus[LoaderStatus[\"SUCCESS\"] = 2] = \"SUCCESS\";\n    LoaderStatus[LoaderStatus[\"FAILURE\"] = 3] = \"FAILURE\";\n})(LoaderStatus || (LoaderStatus = {}));\n/**\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\n * dynamically using\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n * It works by dynamically creating and appending a script node to the the\n * document head and wrapping the callback function so as to return a promise.\n *\n * ```\n * const loader = new Loader({\n *   apiKey: \"\",\n *   version: \"weekly\",\n *   libraries: [\"places\"]\n * });\n *\n * loader.load().then((google) => {\n *   const map = new google.maps.Map(...)\n * })\n * ```\n */\nclass Loader {\n    /**\n     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\n     * using this library, instead the defaults are set by the Google Maps\n     * JavaScript API server.\n     *\n     * ```\n     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\n     * ```\n     */\n    constructor({ apiKey, authReferrerPolicy, channel, client, id = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = \"https://maps.googleapis.com/maps/api/js\", version, }) {\n        this.callbacks = [];\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.apiKey = apiKey;\n        this.authReferrerPolicy = authReferrerPolicy;\n        this.channel = channel;\n        this.client = client;\n        this.id = id || DEFAULT_ID; // Do not allow empty string\n        this.language = language;\n        this.libraries = libraries;\n        this.mapIds = mapIds;\n        this.nonce = nonce;\n        this.region = region;\n        this.retries = retries;\n        this.url = url;\n        this.version = version;\n        if (Loader.instance) {\n            if (!fastDeepEqual$1(this.options, Loader.instance.options)) {\n                throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);\n            }\n            return Loader.instance;\n        }\n        Loader.instance = this;\n    }\n    get options() {\n        return {\n            version: this.version,\n            apiKey: this.apiKey,\n            channel: this.channel,\n            client: this.client,\n            id: this.id,\n            libraries: this.libraries,\n            language: this.language,\n            region: this.region,\n            mapIds: this.mapIds,\n            nonce: this.nonce,\n            url: this.url,\n            authReferrerPolicy: this.authReferrerPolicy,\n        };\n    }\n    get status() {\n        if (this.errors.length) {\n            return LoaderStatus.FAILURE;\n        }\n        if (this.done) {\n            return LoaderStatus.SUCCESS;\n        }\n        if (this.loading) {\n            return LoaderStatus.LOADING;\n        }\n        return LoaderStatus.INITIALIZED;\n    }\n    get failed() {\n        return this.done && !this.loading && this.errors.length >= this.retries + 1;\n    }\n    /**\n     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\n     *\n     * @ignore\n     * @deprecated\n     */\n    createUrl() {\n        let url = this.url;\n        url += `?callback=__googleMapsCallback`;\n        if (this.apiKey) {\n            url += `&key=${this.apiKey}`;\n        }\n        if (this.channel) {\n            url += `&channel=${this.channel}`;\n        }\n        if (this.client) {\n            url += `&client=${this.client}`;\n        }\n        if (this.libraries.length > 0) {\n            url += `&libraries=${this.libraries.join(\",\")}`;\n        }\n        if (this.language) {\n            url += `&language=${this.language}`;\n        }\n        if (this.region) {\n            url += `&region=${this.region}`;\n        }\n        if (this.version) {\n            url += `&v=${this.version}`;\n        }\n        if (this.mapIds) {\n            url += `&map_ids=${this.mapIds.join(\",\")}`;\n        }\n        if (this.authReferrerPolicy) {\n            url += `&auth_referrer_policy=${this.authReferrerPolicy}`;\n        }\n        return url;\n    }\n    deleteScript() {\n        const script = document.getElementById(this.id);\n        if (script) {\n            script.remove();\n        }\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     * @deprecated, use importLibrary() instead.\n     */\n    load() {\n        return this.loadPromise();\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     *\n     * @ignore\n     * @deprecated, use importLibrary() instead.\n     */\n    loadPromise() {\n        return new Promise((resolve, reject) => {\n            this.loadCallback((err) => {\n                if (!err) {\n                    resolve(window.google);\n                }\n                else {\n                    reject(err.error);\n                }\n            });\n        });\n    }\n    importLibrary(name) {\n        this.execute();\n        return google.maps.importLibrary(name);\n    }\n    /**\n     * Load the Google Maps JavaScript API script with a callback.\n     * @deprecated, use importLibrary() instead.\n     */\n    loadCallback(fn) {\n        this.callbacks.push(fn);\n        this.execute();\n    }\n    /**\n     * Set the script on document.\n     */\n    setScript() {\n        var _a, _b;\n        if (document.getElementById(this.id)) {\n            // TODO wrap onerror callback for cases where the script was loaded elsewhere\n            this.callback();\n            return;\n        }\n        const params = {\n            key: this.apiKey,\n            channel: this.channel,\n            client: this.client,\n            libraries: this.libraries.length && this.libraries,\n            v: this.version,\n            mapIds: this.mapIds,\n            language: this.language,\n            region: this.region,\n            authReferrerPolicy: this.authReferrerPolicy,\n        };\n        // keep the URL minimal:\n        Object.keys(params).forEach(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (key) => !params[key] && delete params[key]);\n        if (!((_b = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary)) {\n            // tweaked copy of https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n            // which also sets the base url, the id, and the nonce\n            /* eslint-disable */\n            ((g) => {\n                // @ts-ignore\n                let h, a, k, p = \"The Google Maps JavaScript API\", c = \"google\", l = \"importLibrary\", q = \"__ib__\", m = document, b = window;\n                // @ts-ignore\n                b = b[c] || (b[c] = {});\n                // @ts-ignore\n                const d = b.maps || (b.maps = {}), r = new Set(), e = new URLSearchParams(), u = () => \n                // @ts-ignore\n                h || (h = new Promise((f, n) => __awaiter(this, void 0, void 0, function* () {\n                    var _a;\n                    yield (a = m.createElement(\"script\"));\n                    a.id = this.id;\n                    e.set(\"libraries\", [...r] + \"\");\n                    // @ts-ignore\n                    for (k in g)\n                        e.set(k.replace(/[A-Z]/g, (t) => \"_\" + t[0].toLowerCase()), g[k]);\n                    e.set(\"callback\", c + \".maps.\" + q);\n                    a.src = this.url + `?` + e;\n                    d[q] = f;\n                    a.onerror = () => (h = n(Error(p + \" could not load.\")));\n                    // @ts-ignore\n                    a.nonce = this.nonce || ((_a = m.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n                    m.head.append(a);\n                })));\n                // @ts-ignore\n                d[l] ? console.warn(p + \" only loads once. Ignoring:\", g) : (d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)));\n            })(params);\n            /* eslint-enable */\n        }\n        // While most libraries populate the global namespace when loaded via bootstrap params,\n        // this is not the case for \"marker\" when used with the inline bootstrap loader\n        // (and maybe others in the future). So ensure there is an importLibrary for each:\n        const libraryPromises = this.libraries.map((library) => this.importLibrary(library));\n        // ensure at least one library, to kick off loading...\n        if (!libraryPromises.length) {\n            libraryPromises.push(this.importLibrary(\"core\"));\n        }\n        Promise.all(libraryPromises).then(() => this.callback(), (error) => {\n            const event = new ErrorEvent(\"error\", { error }); // for backwards compat\n            this.loadErrorCallback(event);\n        });\n    }\n    /**\n     * Reset the loader state.\n     */\n    reset() {\n        this.deleteScript();\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.onerrorEvent = null;\n    }\n    resetIfRetryingFailed() {\n        if (this.failed) {\n            this.reset();\n        }\n    }\n    loadErrorCallback(e) {\n        this.errors.push(e);\n        if (this.errors.length <= this.retries) {\n            const delay = this.errors.length * Math.pow(2, this.errors.length);\n            console.error(`Failed to load Google Maps script, retrying in ${delay} ms.`);\n            setTimeout(() => {\n                this.deleteScript();\n                this.setScript();\n            }, delay);\n        }\n        else {\n            this.onerrorEvent = e;\n            this.callback();\n        }\n    }\n    callback() {\n        this.done = true;\n        this.loading = false;\n        this.callbacks.forEach((cb) => {\n            cb(this.onerrorEvent);\n        });\n        this.callbacks = [];\n    }\n    execute() {\n        this.resetIfRetryingFailed();\n        if (this.done) {\n            this.callback();\n        }\n        else {\n            // short circuit and warn if google.maps is already loaded\n            if (window.google && window.google.maps && window.google.maps.version) {\n                console.warn(\"Google Maps already loaded outside @googlemaps/js-api-loader.\" +\n                    \"This may result in undesirable behavior as options and script parameters may not match.\");\n                this.callback();\n                return;\n            }\n            if (this.loading) ;\n            else {\n                this.loading = true;\n                this.setScript();\n            }\n        }\n    }\n}\n\nvar defaultLibraries = ['maps'];\nfunction useJsApiLoader(_a) {\n    var _b = _a.id, id = _b === void 0 ? defaultLoadScriptProps.id : _b, _c = _a.version, version = _c === void 0 ? defaultLoadScriptProps.version : _c, nonce = _a.nonce, googleMapsApiKey = _a.googleMapsApiKey, \n    // googleMapsClientId,\n    language = _a.language, region = _a.region, _d = _a.libraries, libraries = _d === void 0 ? defaultLibraries : _d, preventGoogleFontsLoading = _a.preventGoogleFontsLoading, \n    // channel,\n    mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var isMounted = react.useRef(false);\n    var _e = react.useState(false), isLoaded = _e[0], setLoaded = _e[1];\n    var _f = react.useState(undefined), loadError = _f[0], setLoadError = _f[1];\n    react.useEffect(function trackMountedState() {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    var loader = react.useMemo(function () {\n        return new Loader({\n            id: id,\n            apiKey: googleMapsApiKey,\n            version: version,\n            libraries: libraries,\n            language: language || 'en',\n            region: region || 'US',\n            mapIds: mapIds || [],\n            nonce: nonce || '',\n            authReferrerPolicy: authReferrerPolicy || 'origin',\n        });\n    }, [id, googleMapsApiKey, version, libraries, language, region, mapIds, nonce, authReferrerPolicy]);\n    react.useEffect(function effect() {\n        if (isLoaded) {\n            return;\n        }\n        else {\n            loader.load().then(function () {\n                if (isMounted.current) {\n                    setLoaded(true);\n                }\n                return;\n            })\n                .catch(function (error) {\n                setLoadError(error);\n            });\n        }\n    }, []);\n    react.useEffect(function () {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    var prevLibraries = react.useRef();\n    react.useEffect(function () {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded: isLoaded, loadError: loadError };\n}\n\nvar eventMap$h = {};\nvar updaterMap$h = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction TrafficLayerFunctional(_a) {\n    var options = _a.options, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        var trafficLayer = new google.maps.TrafficLayer(__assign(__assign({}, (options || {})), { map: map }));\n        setInstance(trafficLayer);\n        if (onLoad) {\n            onLoad(trafficLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar TrafficLayerF = react.memo(TrafficLayerFunctional);\nvar TrafficLayer = /** @class */ (function (_super) {\n    __extends(TrafficLayer, _super);\n    function TrafficLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            trafficLayer: null,\n        };\n        _this.setTrafficLayerCallback = function () {\n            if (_this.state.trafficLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.trafficLayer);\n            }\n        };\n        _this.registeredEvents = [];\n        return _this;\n    }\n    TrafficLayer.prototype.componentDidMount = function () {\n        var trafficLayer = new google.maps.TrafficLayer(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$h,\n            eventMap: eventMap$h,\n            prevProps: {},\n            nextProps: this.props,\n            instance: trafficLayer,\n        });\n        this.setState(function setTrafficLayer() {\n            return {\n                trafficLayer: trafficLayer,\n            };\n        }, this.setTrafficLayerCallback);\n    };\n    TrafficLayer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.trafficLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$h,\n                eventMap: eventMap$h,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.trafficLayer,\n            });\n        }\n    };\n    TrafficLayer.prototype.componentWillUnmount = function () {\n        if (this.state.trafficLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.trafficLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.trafficLayer.setMap(null);\n        }\n    };\n    TrafficLayer.prototype.render = function () {\n        return null;\n    };\n    TrafficLayer.contextType = MapContext;\n    return TrafficLayer;\n}(react.PureComponent));\n\nfunction BicyclingLayerFunctional(_a) {\n    var onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        var bicyclingLayer = new google.maps.BicyclingLayer();\n        setInstance(bicyclingLayer);\n        bicyclingLayer.setMap(map);\n        if (onLoad) {\n            onLoad(bicyclingLayer);\n        }\n        return function () {\n            if (bicyclingLayer !== null) {\n                if (onUnmount) {\n                    onUnmount(bicyclingLayer);\n                }\n                bicyclingLayer.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar BicyclingLayerF = react.memo(BicyclingLayerFunctional);\nvar BicyclingLayer = /** @class */ (function (_super) {\n    __extends(BicyclingLayer, _super);\n    function BicyclingLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            bicyclingLayer: null,\n        };\n        _this.setBicyclingLayerCallback = function () {\n            if (_this.state.bicyclingLayer !== null) {\n                _this.state.bicyclingLayer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.bicyclingLayer);\n                }\n            }\n        };\n        return _this;\n    }\n    BicyclingLayer.prototype.componentDidMount = function () {\n        var bicyclingLayer = new google.maps.BicyclingLayer();\n        this.setState(function () {\n            return {\n                bicyclingLayer: bicyclingLayer,\n            };\n        }, this.setBicyclingLayerCallback);\n    };\n    BicyclingLayer.prototype.componentWillUnmount = function () {\n        if (this.state.bicyclingLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.bicyclingLayer);\n            }\n            this.state.bicyclingLayer.setMap(null);\n        }\n    };\n    BicyclingLayer.prototype.render = function () {\n        return null;\n    };\n    BicyclingLayer.contextType = MapContext;\n    return BicyclingLayer;\n}(react.PureComponent));\n\nfunction TransitLayerFunctional(_a) {\n    var onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        var transitLayer = new google.maps.TransitLayer();\n        setInstance(transitLayer);\n        transitLayer.setMap(map);\n        if (onLoad) {\n            onLoad(transitLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar TransitLayerF = react.memo(TransitLayerFunctional);\nvar TransitLayer = /** @class */ (function (_super) {\n    __extends(TransitLayer, _super);\n    function TransitLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            transitLayer: null,\n        };\n        _this.setTransitLayerCallback = function () {\n            if (_this.state.transitLayer !== null) {\n                _this.state.transitLayer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.transitLayer);\n                }\n            }\n        };\n        return _this;\n    }\n    TransitLayer.prototype.componentDidMount = function () {\n        var transitLayer = new google.maps.TransitLayer();\n        this.setState(function setTransitLayer() {\n            return {\n                transitLayer: transitLayer,\n            };\n        }, this.setTransitLayerCallback);\n    };\n    TransitLayer.prototype.componentWillUnmount = function () {\n        if (this.state.transitLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.transitLayer);\n            }\n            this.state.transitLayer.setMap(null);\n        }\n    };\n    TransitLayer.prototype.render = function () {\n        return null;\n    };\n    TransitLayer.contextType = MapContext;\n    return TransitLayer;\n}(react.PureComponent));\n\nvar eventMap$g = {\n    onCircleComplete: 'circlecomplete',\n    onMarkerComplete: 'markercomplete',\n    onOverlayComplete: 'overlaycomplete',\n    onPolygonComplete: 'polygoncomplete',\n    onPolylineComplete: 'polylinecomplete',\n    onRectangleComplete: 'rectanglecomplete',\n};\nvar updaterMap$g = {\n    drawingMode: function (instance, drawingMode) {\n        instance.setDrawingMode(drawingMode);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction DrawingManagerFunctional(_a) {\n    var options = _a.options, drawingMode = _a.drawingMode, onCircleComplete = _a.onCircleComplete, onMarkerComplete = _a.onMarkerComplete, onOverlayComplete = _a.onOverlayComplete, onPolygonComplete = _a.onPolygonComplete, onPolylineComplete = _a.onPolylineComplete, onRectangleComplete = _a.onRectangleComplete, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), circlecompleteListener = _c[0], setCircleCompleteListener = _c[1];\n    var _d = react.useState(null), markercompleteListener = _d[0], setMarkerCompleteListener = _d[1];\n    var _e = react.useState(null), overlaycompleteListener = _e[0], setOverlayCompleteListener = _e[1];\n    var _f = react.useState(null), polygoncompleteListener = _f[0], setPolygonCompleteListener = _f[1];\n    var _g = react.useState(null), polylinecompleteListener = _g[0], setPolylineCompleteListener = _g[1];\n    var _h = react.useState(null), rectanglecompleteListener = _h[0], setRectangleCompleteListener = _h[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (drawingMode && instance !== null) {\n            instance.setDrawingMode(drawingMode);\n        }\n    }, [instance, drawingMode]);\n    react.useEffect(function () {\n        if (instance && onCircleComplete) {\n            if (circlecompleteListener !== null) {\n                google.maps.event.removeListener(circlecompleteListener);\n            }\n            setCircleCompleteListener(google.maps.event.addListener(instance, 'circlecomplete', onCircleComplete));\n        }\n    }, [instance, onCircleComplete]);\n    react.useEffect(function () {\n        if (instance && onMarkerComplete) {\n            if (markercompleteListener !== null) {\n                google.maps.event.removeListener(markercompleteListener);\n            }\n            setMarkerCompleteListener(google.maps.event.addListener(instance, 'markercomplete', onMarkerComplete));\n        }\n    }, [instance, onMarkerComplete]);\n    react.useEffect(function () {\n        if (instance && onOverlayComplete) {\n            if (overlaycompleteListener !== null) {\n                google.maps.event.removeListener(overlaycompleteListener);\n            }\n            setOverlayCompleteListener(google.maps.event.addListener(instance, 'overlaycomplete', onOverlayComplete));\n        }\n    }, [instance, onOverlayComplete]);\n    react.useEffect(function () {\n        if (instance && onPolygonComplete) {\n            if (polygoncompleteListener !== null) {\n                google.maps.event.removeListener(polygoncompleteListener);\n            }\n            setPolygonCompleteListener(google.maps.event.addListener(instance, 'polygoncomplete', onPolygonComplete));\n        }\n    }, [instance, onPolygonComplete]);\n    react.useEffect(function () {\n        if (instance && onPolylineComplete) {\n            if (polylinecompleteListener !== null) {\n                google.maps.event.removeListener(polylinecompleteListener);\n            }\n            setPolylineCompleteListener(google.maps.event.addListener(instance, 'polylinecomplete', onPolylineComplete));\n        }\n    }, [instance, onPolylineComplete]);\n    react.useEffect(function () {\n        if (instance && onRectangleComplete) {\n            if (rectanglecompleteListener !== null) {\n                google.maps.event.removeListener(rectanglecompleteListener);\n            }\n            setRectangleCompleteListener(google.maps.event.addListener(instance, 'rectanglecomplete', onRectangleComplete));\n        }\n    }, [instance, onRectangleComplete]);\n    react.useEffect(function () {\n        invariant$1(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n        var drawingManager = new google.maps.drawing.DrawingManager(__assign(__assign({}, (options || {})), { map: map }));\n        if (drawingMode) {\n            drawingManager.setDrawingMode(drawingMode);\n        }\n        if (onCircleComplete) {\n            setCircleCompleteListener(google.maps.event.addListener(drawingManager, 'circlecomplete', onCircleComplete));\n        }\n        if (onMarkerComplete) {\n            setMarkerCompleteListener(google.maps.event.addListener(drawingManager, 'markercomplete', onMarkerComplete));\n        }\n        if (onOverlayComplete) {\n            setOverlayCompleteListener(google.maps.event.addListener(drawingManager, 'overlaycomplete', onOverlayComplete));\n        }\n        if (onPolygonComplete) {\n            setPolygonCompleteListener(google.maps.event.addListener(drawingManager, 'polygoncomplete', onPolygonComplete));\n        }\n        if (onPolylineComplete) {\n            setPolylineCompleteListener(google.maps.event.addListener(drawingManager, 'polylinecomplete', onPolylineComplete));\n        }\n        if (onRectangleComplete) {\n            setRectangleCompleteListener(google.maps.event.addListener(drawingManager, 'rectanglecomplete', onRectangleComplete));\n        }\n        setInstance(drawingManager);\n        if (onLoad) {\n            onLoad(drawingManager);\n        }\n        return function () {\n            if (instance !== null) {\n                if (circlecompleteListener) {\n                    google.maps.event.removeListener(circlecompleteListener);\n                }\n                if (markercompleteListener) {\n                    google.maps.event.removeListener(markercompleteListener);\n                }\n                if (overlaycompleteListener) {\n                    google.maps.event.removeListener(overlaycompleteListener);\n                }\n                if (polygoncompleteListener) {\n                    google.maps.event.removeListener(polygoncompleteListener);\n                }\n                if (polylinecompleteListener) {\n                    google.maps.event.removeListener(polylinecompleteListener);\n                }\n                if (rectanglecompleteListener) {\n                    google.maps.event.removeListener(rectanglecompleteListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar DrawingManagerF = react.memo(DrawingManagerFunctional);\nvar DrawingManager = /** @class */ (function (_super) {\n    __extends(DrawingManager, _super);\n    function DrawingManager(props) {\n        var _this = _super.call(this, props) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            drawingManager: null,\n        };\n        _this.setDrawingManagerCallback = function () {\n            if (_this.state.drawingManager !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.drawingManager);\n            }\n        };\n        invariant$1(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n        return _this;\n    }\n    DrawingManager.prototype.componentDidMount = function () {\n        var drawingManager = new google.maps.drawing.DrawingManager(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$g,\n            eventMap: eventMap$g,\n            prevProps: {},\n            nextProps: this.props,\n            instance: drawingManager,\n        });\n        this.setState(function setDrawingManager() {\n            return {\n                drawingManager: drawingManager,\n            };\n        }, this.setDrawingManagerCallback);\n    };\n    DrawingManager.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.drawingManager !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$g,\n                eventMap: eventMap$g,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.drawingManager,\n            });\n        }\n    };\n    DrawingManager.prototype.componentWillUnmount = function () {\n        if (this.state.drawingManager !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.drawingManager);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.drawingManager.setMap(null);\n        }\n    };\n    DrawingManager.prototype.render = function () {\n        return null;\n    };\n    DrawingManager.contextType = MapContext;\n    return DrawingManager;\n}(react.PureComponent));\n\nvar eventMap$f = {\n    onAnimationChanged: 'animation_changed',\n    onClick: 'click',\n    onClickableChanged: 'clickable_changed',\n    onCursorChanged: 'cursor_changed',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDraggableChanged: 'draggable_changed',\n    onDragStart: 'dragstart',\n    onFlatChanged: 'flat_changed',\n    onIconChanged: 'icon_changed',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onPositionChanged: 'position_changed',\n    onRightClick: 'rightclick',\n    onShapeChanged: 'shape_changed',\n    onTitleChanged: 'title_changed',\n    onVisibleChanged: 'visible_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$f = {\n    animation: function (instance, animation) {\n        instance.setAnimation(animation);\n    },\n    clickable: function (instance, clickable) {\n        instance.setClickable(clickable);\n    },\n    cursor: function (instance, cursor) {\n        instance.setCursor(cursor);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    icon: function (instance, icon) {\n        instance.setIcon(icon);\n    },\n    label: function (instance, label) {\n        instance.setLabel(label);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    opacity: function (instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    shape: function (instance, shape) {\n        instance.setShape(shape);\n    },\n    title: function (instance, title) {\n        instance.setTitle(title);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar defaultOptions$5 = {};\nfunction MarkerFunctional(_a) {\n    var position = _a.position, options = _a.options, clusterer = _a.clusterer, noClustererRedraw = _a.noClustererRedraw, children = _a.children, draggable = _a.draggable, visible = _a.visible, animation = _a.animation, clickable = _a.clickable, cursor = _a.cursor, icon = _a.icon, label = _a.label, opacity = _a.opacity, shape = _a.shape, title = _a.title, zIndex = _a.zIndex, onClick = _a.onClick, onDblClick = _a.onDblClick, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onMouseDown = _a.onMouseDown, onRightClick = _a.onRightClick, onClickableChanged = _a.onClickableChanged, onCursorChanged = _a.onCursorChanged, onAnimationChanged = _a.onAnimationChanged, onDraggableChanged = _a.onDraggableChanged, onFlatChanged = _a.onFlatChanged, onIconChanged = _a.onIconChanged, onPositionChanged = _a.onPositionChanged, onShapeChanged = _a.onShapeChanged, onTitleChanged = _a.onTitleChanged, onVisibleChanged = _a.onVisibleChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = react.useState(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = react.useState(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = react.useState(null), mouseoutListener = _g[0], setMouseoutListener = _g[1];\n    var _h = react.useState(null), mouseoverListener = _h[0], setMouseoverListener = _h[1];\n    var _j = react.useState(null), mouseupListener = _j[0], setMouseupListener = _j[1];\n    var _k = react.useState(null), rightclickListener = _k[0], setRightclickListener = _k[1];\n    var _l = react.useState(null), clickListener = _l[0], setClickListener = _l[1];\n    var _m = react.useState(null), dragListener = _m[0], setDragListener = _m[1];\n    var _o = react.useState(null), clickableChangedListener = _o[0], setClickableChangedListener = _o[1];\n    var _p = react.useState(null), cursorChangedListener = _p[0], setCursorChangedListener = _p[1];\n    var _q = react.useState(null), animationChangedListener = _q[0], setAnimationChangedListener = _q[1];\n    var _r = react.useState(null), draggableChangedListener = _r[0], setDraggableChangedListener = _r[1];\n    var _s = react.useState(null), flatChangedListener = _s[0], setFlatChangedListener = _s[1];\n    var _t = react.useState(null), iconChangedListener = _t[0], setIconChangedListener = _t[1];\n    var _u = react.useState(null), positionChangedListener = _u[0], setPositionChangedListener = _u[1];\n    var _v = react.useState(null), shapeChangedListener = _v[0], setShapeChangedListener = _v[1];\n    var _w = react.useState(null), titleChangedListener = _w[0], setTitleChangedListener = _w[1];\n    var _x = react.useState(null), visibleChangedListener = _x[0], setVisibleChangedListener = _x[1];\n    var _y = react.useState(null), zIndexChangedListener = _y[0], setZindexChangedListener = _y[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    react.useEffect(function () {\n        if (position && instance !== null) {\n            instance.setPosition(position);\n        }\n    }, [instance, position]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    react.useEffect(function () {\n        instance === null || instance === void 0 ? void 0 : instance.setAnimation(animation);\n    }, [instance, animation]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        if (instance && onClickableChanged) {\n            if (clickableChangedListener !== null) {\n                google.maps.event.removeListener(clickableChangedListener);\n            }\n            setClickableChangedListener(google.maps.event.addListener(instance, 'clickable_changed', onClickableChanged));\n        }\n    }, [onClickableChanged]);\n    react.useEffect(function () {\n        if (instance && onCursorChanged) {\n            if (cursorChangedListener !== null) {\n                google.maps.event.removeListener(cursorChangedListener);\n            }\n            setCursorChangedListener(google.maps.event.addListener(instance, 'cursor_changed', onCursorChanged));\n        }\n    }, [onCursorChanged]);\n    react.useEffect(function () {\n        if (instance && onAnimationChanged) {\n            if (animationChangedListener !== null) {\n                google.maps.event.removeListener(animationChangedListener);\n            }\n            setAnimationChangedListener(google.maps.event.addListener(instance, 'animation_changed', onAnimationChanged));\n        }\n    }, [onAnimationChanged]);\n    react.useEffect(function () {\n        if (instance && onDraggableChanged) {\n            if (draggableChangedListener !== null) {\n                google.maps.event.removeListener(draggableChangedListener);\n            }\n            setDraggableChangedListener(google.maps.event.addListener(instance, 'draggable_changed', onDraggableChanged));\n        }\n    }, [onDraggableChanged]);\n    react.useEffect(function () {\n        if (instance && onFlatChanged) {\n            if (flatChangedListener !== null) {\n                google.maps.event.removeListener(flatChangedListener);\n            }\n            setFlatChangedListener(google.maps.event.addListener(instance, 'flat_changed', onFlatChanged));\n        }\n    }, [onFlatChanged]);\n    react.useEffect(function () {\n        if (instance && onIconChanged) {\n            if (iconChangedListener !== null) {\n                google.maps.event.removeListener(iconChangedListener);\n            }\n            setIconChangedListener(google.maps.event.addListener(instance, 'icon_changed', onIconChanged));\n        }\n    }, [onIconChanged]);\n    react.useEffect(function () {\n        if (instance && onPositionChanged) {\n            if (positionChangedListener !== null) {\n                google.maps.event.removeListener(positionChangedListener);\n            }\n            setPositionChangedListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    react.useEffect(function () {\n        if (instance && onShapeChanged) {\n            if (shapeChangedListener !== null) {\n                google.maps.event.removeListener(shapeChangedListener);\n            }\n            setShapeChangedListener(google.maps.event.addListener(instance, 'shape_changed', onShapeChanged));\n        }\n    }, [onShapeChanged]);\n    react.useEffect(function () {\n        if (instance && onTitleChanged) {\n            if (titleChangedListener !== null) {\n                google.maps.event.removeListener(titleChangedListener);\n            }\n            setTitleChangedListener(google.maps.event.addListener(instance, 'title_changed', onTitleChanged));\n        }\n    }, [onTitleChanged]);\n    react.useEffect(function () {\n        if (instance && onVisibleChanged) {\n            if (visibleChangedListener !== null) {\n                google.maps.event.removeListener(visibleChangedListener);\n            }\n            setVisibleChangedListener(google.maps.event.addListener(instance, 'visible_changed', onVisibleChanged));\n        }\n    }, [onVisibleChanged]);\n    react.useEffect(function () {\n        if (instance && onZindexChanged) {\n            if (zIndexChangedListener !== null) {\n                google.maps.event.removeListener(zIndexChangedListener);\n            }\n            setZindexChangedListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    react.useEffect(function () {\n        var markerOptions = __assign(__assign(__assign({}, (options || defaultOptions$5)), (clusterer ? defaultOptions$5 : { map: map })), { position: position });\n        var marker = new google.maps.Marker(markerOptions);\n        if (clusterer) {\n            clusterer.addMarker(marker, !!noClustererRedraw);\n        }\n        else {\n            marker.setMap(map);\n        }\n        if (position) {\n            marker.setPosition(position);\n        }\n        if (typeof visible !== 'undefined') {\n            marker.setVisible(visible);\n        }\n        if (typeof draggable !== 'undefined') {\n            marker.setDraggable(draggable);\n        }\n        if (typeof clickable !== 'undefined') {\n            marker.setClickable(clickable);\n        }\n        if (typeof cursor === 'string') {\n            marker.setCursor(cursor);\n        }\n        if (icon) {\n            marker.setIcon(icon);\n        }\n        if (typeof label !== 'undefined') {\n            marker.setLabel(label);\n        }\n        if (typeof opacity !== 'undefined') {\n            marker.setOpacity(opacity);\n        }\n        if (shape) {\n            marker.setShape(shape);\n        }\n        if (typeof title === 'string') {\n            marker.setTitle(title);\n        }\n        if (typeof zIndex === 'number') {\n            marker.setZIndex(zIndex);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(marker, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(marker, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(marker, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(marker, 'mousedown', onMouseDown));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(marker, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(marker, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(marker, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(marker, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(marker, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(marker, 'drag', onDrag));\n        }\n        if (onClickableChanged) {\n            setClickableChangedListener(google.maps.event.addListener(marker, 'clickable_changed', onClickableChanged));\n        }\n        if (onCursorChanged) {\n            setCursorChangedListener(google.maps.event.addListener(marker, 'cursor_changed', onCursorChanged));\n        }\n        if (onAnimationChanged) {\n            setAnimationChangedListener(google.maps.event.addListener(marker, 'animation_changed', onAnimationChanged));\n        }\n        if (onDraggableChanged) {\n            setDraggableChangedListener(google.maps.event.addListener(marker, 'draggable_changed', onDraggableChanged));\n        }\n        if (onFlatChanged) {\n            setFlatChangedListener(google.maps.event.addListener(marker, 'flat_changed', onFlatChanged));\n        }\n        if (onIconChanged) {\n            setIconChangedListener(google.maps.event.addListener(marker, 'icon_changed', onIconChanged));\n        }\n        if (onPositionChanged) {\n            setPositionChangedListener(google.maps.event.addListener(marker, 'position_changed', onPositionChanged));\n        }\n        if (onShapeChanged) {\n            setShapeChangedListener(google.maps.event.addListener(marker, 'shape_changed', onShapeChanged));\n        }\n        if (onTitleChanged) {\n            setTitleChangedListener(google.maps.event.addListener(marker, 'title_changed', onTitleChanged));\n        }\n        if (onVisibleChanged) {\n            setVisibleChangedListener(google.maps.event.addListener(marker, 'visible_changed', onVisibleChanged));\n        }\n        if (onZindexChanged) {\n            setZindexChangedListener(google.maps.event.addListener(marker, 'zindex_changed', onZindexChanged));\n        }\n        setInstance(marker);\n        if (onLoad) {\n            onLoad(marker);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (clickableChangedListener !== null) {\n                google.maps.event.removeListener(clickableChangedListener);\n            }\n            if (cursorChangedListener !== null) {\n                google.maps.event.removeListener(cursorChangedListener);\n            }\n            if (animationChangedListener !== null) {\n                google.maps.event.removeListener(animationChangedListener);\n            }\n            if (draggableChangedListener !== null) {\n                google.maps.event.removeListener(draggableChangedListener);\n            }\n            if (flatChangedListener !== null) {\n                google.maps.event.removeListener(flatChangedListener);\n            }\n            if (iconChangedListener !== null) {\n                google.maps.event.removeListener(iconChangedListener);\n            }\n            if (positionChangedListener !== null) {\n                google.maps.event.removeListener(positionChangedListener);\n            }\n            if (titleChangedListener !== null) {\n                google.maps.event.removeListener(titleChangedListener);\n            }\n            if (visibleChangedListener !== null) {\n                google.maps.event.removeListener(visibleChangedListener);\n            }\n            if (zIndexChangedListener !== null) {\n                google.maps.event.removeListener(zIndexChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(marker);\n            }\n            if (clusterer) {\n                clusterer.removeMarker(marker, !!noClustererRedraw);\n            }\n            else if (marker) {\n                marker.setMap(null);\n            }\n        };\n    }, []);\n    var chx = react.useMemo(function () {\n        return children\n            ? react.Children.map(children, function (child) {\n                if (!react.isValidElement(child)) {\n                    return child;\n                }\n                var elementChild = child;\n                return react.cloneElement(elementChild, { anchor: instance });\n            })\n            : null;\n    }, [children, instance]);\n    return jsxRuntime.jsx(jsxRuntime.Fragment, { children: chx }) || null;\n}\nvar MarkerF = react.memo(MarkerFunctional);\nvar Marker = /** @class */ (function (_super) {\n    __extends(Marker, _super);\n    function Marker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        return _this;\n    }\n    Marker.prototype.componentDidMount = function () {\n        var markerOptions = __assign(__assign(__assign({}, (this.props.options || defaultOptions$5)), (this.props.clusterer ? defaultOptions$5 : { map: this.context })), { position: this.props.position });\n        // Unfortunately we can't just do this in the contstructor, because the\n        // `MapContext` might not be filled in yet.\n        this.marker = new google.maps.Marker(markerOptions);\n        if (this.props.clusterer) {\n            this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw);\n        }\n        else {\n            this.marker.setMap(this.context);\n        }\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$f,\n            eventMap: eventMap$f,\n            prevProps: {},\n            nextProps: this.props,\n            instance: this.marker,\n        });\n        if (this.props.onLoad) {\n            this.props.onLoad(this.marker);\n        }\n    };\n    Marker.prototype.componentDidUpdate = function (prevProps) {\n        if (this.marker) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$f,\n                eventMap: eventMap$f,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.marker,\n            });\n        }\n    };\n    Marker.prototype.componentWillUnmount = function () {\n        if (this.marker) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.marker);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.props.clusterer) {\n                this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw);\n            }\n            else {\n                this.marker && this.marker.setMap(null);\n            }\n        }\n    };\n    Marker.prototype.render = function () {\n        var _this = this;\n        var children = null;\n        if (this.props.children) {\n            children = react.Children.map(this.props.children, function (child) {\n                if (!react.isValidElement(child)) {\n                    return child;\n                }\n                var elementChild = child;\n                return react.cloneElement(elementChild, { anchor: _this.marker });\n            });\n        }\n        return children || null;\n    };\n    Marker.contextType = MapContext;\n    return Marker;\n}(react.PureComponent));\n\nvar ClusterIcon = /** @class */ (function () {\n    function ClusterIcon(cluster, styles) {\n        cluster.getClusterer().extend(ClusterIcon, google.maps.OverlayView);\n        this.cluster = cluster;\n        this.clusterClassName = this.cluster.getClusterer().getClusterClass();\n        this.className = this.clusterClassName;\n        this.styles = styles;\n        this.center = undefined;\n        this.div = null;\n        this.sums = null;\n        this.visible = false;\n        this.boundsChangedListener = null;\n        this.url = '';\n        this.height = 0;\n        this.width = 0;\n        this.anchorText = [0, 0];\n        this.anchorIcon = [0, 0];\n        this.textColor = 'black';\n        this.textSize = 11;\n        this.textDecoration = 'none';\n        this.fontWeight = 'bold';\n        this.fontStyle = 'normal';\n        this.fontFamily = 'Arial,sans-serif';\n        this.backgroundPosition = '0 0';\n        this.cMouseDownInCluster = null;\n        this.cDraggingMapByCluster = null;\n        this.timeOut = null;\n        this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n        this.onBoundsChanged = this.onBoundsChanged.bind(this);\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onMouseOver = this.onMouseOver.bind(this);\n        this.onMouseOut = this.onMouseOut.bind(this);\n        this.onAdd = this.onAdd.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.draw = this.draw.bind(this);\n        this.hide = this.hide.bind(this);\n        this.show = this.show.bind(this);\n        this.useStyle = this.useStyle.bind(this);\n        this.setCenter = this.setCenter.bind(this);\n        this.getPosFromLatLng = this.getPosFromLatLng.bind(this);\n    }\n    ClusterIcon.prototype.onBoundsChanged = function () {\n        this.cDraggingMapByCluster = this.cMouseDownInCluster;\n    };\n    ClusterIcon.prototype.onMouseDown = function () {\n        this.cMouseDownInCluster = true;\n        this.cDraggingMapByCluster = false;\n    };\n    ClusterIcon.prototype.onClick = function (event) {\n        this.cMouseDownInCluster = false;\n        if (!this.cDraggingMapByCluster) {\n            var markerClusterer_1 = this.cluster.getClusterer();\n            /**\n             * This event is fired when a cluster marker is clicked.\n             * @name MarkerClusterer#click\n             * @param {Cluster} c The cluster that was clicked.\n             * @event\n             */\n            google.maps.event.trigger(markerClusterer_1, 'click', this.cluster);\n            google.maps.event.trigger(markerClusterer_1, 'clusterclick', this.cluster); // deprecated name\n            // The default click handler follows. Disable it by setting\n            // the zoomOnClick property to false.\n            if (markerClusterer_1.getZoomOnClick()) {\n                // Zoom into the cluster.\n                var maxZoom_1 = markerClusterer_1.getMaxZoom();\n                var bounds_1 = this.cluster.getBounds();\n                var map = markerClusterer_1.getMap();\n                if (map !== null && 'fitBounds' in map) {\n                    map.fitBounds(bounds_1);\n                }\n                // There is a fix for Issue 170 here:\n                this.timeOut = window.setTimeout(function () {\n                    var map = markerClusterer_1.getMap();\n                    if (map !== null) {\n                        if ('fitBounds' in map) {\n                            map.fitBounds(bounds_1);\n                        }\n                        var zoom = map.getZoom() || 0;\n                        // Don't zoom beyond the max zoom level\n                        if (maxZoom_1 !== null &&\n                            zoom > maxZoom_1) {\n                            map.setZoom(maxZoom_1 + 1);\n                        }\n                    }\n                }, 100);\n            }\n            // Prevent event propagation to the map:\n            event.cancelBubble = true;\n            if (event.stopPropagation) {\n                event.stopPropagation();\n            }\n        }\n    };\n    ClusterIcon.prototype.onMouseOver = function () {\n        /**\n         * This event is fired when the mouse moves over a cluster marker.\n         * @name MarkerClusterer#mouseover\n         * @param {Cluster} c The cluster that the mouse moved over.\n         * @event\n         */\n        google.maps.event.trigger(this.cluster.getClusterer(), 'mouseover', this.cluster);\n    };\n    ClusterIcon.prototype.onMouseOut = function () {\n        /**\n         * This event is fired when the mouse moves out of a cluster marker.\n         * @name MarkerClusterer#mouseout\n         * @param {Cluster} c The cluster that the mouse moved out of.\n         * @event\n         */\n        google.maps.event.trigger(this.cluster.getClusterer(), 'mouseout', this.cluster);\n    };\n    ClusterIcon.prototype.onAdd = function () {\n        var _a;\n        this.div = document.createElement('div');\n        this.div.className = this.className;\n        if (this.visible) {\n            this.show();\n        }\n        (_a = this.getPanes()) === null || _a === void 0 ? void 0 : _a.overlayMouseTarget.appendChild(this.div);\n        var map = this.getMap();\n        if (map !== null) {\n            // Fix for Issue 157\n            this.boundsChangedListener = google.maps.event.addListener(map, 'bounds_changed', this.onBoundsChanged);\n            this.div.addEventListener('mousedown', this.onMouseDown);\n            this.div.addEventListener('click', this.onClick);\n            this.div.addEventListener('mouseover', this.onMouseOver);\n            this.div.addEventListener('mouseout', this.onMouseOut);\n        }\n    };\n    ClusterIcon.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.hide();\n            if (this.boundsChangedListener !== null) {\n                google.maps.event.removeListener(this.boundsChangedListener);\n            }\n            this.div.removeEventListener('mousedown', this.onMouseDown);\n            this.div.removeEventListener('click', this.onClick);\n            this.div.removeEventListener('mouseover', this.onMouseOver);\n            this.div.removeEventListener('mouseout', this.onMouseOut);\n            this.div.parentNode.removeChild(this.div);\n            if (this.timeOut !== null) {\n                window.clearTimeout(this.timeOut);\n                this.timeOut = null;\n            }\n            this.div = null;\n        }\n    };\n    ClusterIcon.prototype.draw = function () {\n        if (this.visible && this.div !== null && this.center) {\n            var pos = this.getPosFromLatLng(this.center);\n            this.div.style.top = pos !== null ? \"\".concat(pos.y, \"px\") : '0';\n            this.div.style.left = pos !== null ? \"\".concat(pos.x, \"px\") : '0';\n        }\n    };\n    ClusterIcon.prototype.hide = function () {\n        if (this.div) {\n            this.div.style.display = 'none';\n        }\n        this.visible = false;\n    };\n    ClusterIcon.prototype.show = function () {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.div && this.center) {\n            var divTitle = this.sums === null ||\n                typeof this.sums.title === 'undefined' ||\n                this.sums.title === '' ? this.cluster.getClusterer().getTitle() : this.sums.title;\n            // NOTE: values must be specified in px units\n            var bp = this.backgroundPosition.split(' ');\n            var spriteH = parseInt(((_a = bp[0]) === null || _a === void 0 ? void 0 : _a.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n            var spriteV = parseInt(((_b = bp[1]) === null || _b === void 0 ? void 0 : _b.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n            var pos = this.getPosFromLatLng(this.center);\n            this.div.className = this.className;\n            this.div.setAttribute('style', \"cursor: pointer; position: absolute; top: \".concat(pos !== null ? \"\".concat(pos.y, \"px\") : '0', \"; left: \").concat(pos !== null ? \"\".concat(pos.x, \"px\") : '0', \"; width: \").concat(this.width, \"px; height: \").concat(this.height, \"px; \"));\n            var img = document.createElement('img');\n            img.alt = divTitle;\n            img.src = this.url;\n            img.width = this.width;\n            img.height = this.height;\n            img.setAttribute('style', \"position: absolute; top: \".concat(spriteV, \"px; left: \").concat(spriteH, \"px\"));\n            if (!this.cluster.getClusterer().enableRetinaIcons) {\n                img.style.clip = \"rect(-\".concat(spriteV, \"px, -\").concat(spriteH + this.width, \"px, -\").concat(spriteV + this.height, \", -\").concat(spriteH, \")\");\n            }\n            var textElm = document.createElement('div');\n            textElm.setAttribute('style', \"position: absolute; top: \".concat(this.anchorText[0], \"px; left: \").concat(this.anchorText[1], \"px; color: \").concat(this.textColor, \"; font-size: \").concat(this.textSize, \"px; font-family: \").concat(this.fontFamily, \"; font-weight: \").concat(this.fontWeight, \"; fontStyle: \").concat(this.fontStyle, \"; text-decoration: \").concat(this.textDecoration, \"; text-align: center; width: \").concat(this.width, \"px; line-height: \").concat(this.height, \"px\"));\n            if ((_c = this.sums) === null || _c === void 0 ? void 0 : _c.text)\n                textElm.innerText = \"\".concat((_d = this.sums) === null || _d === void 0 ? void 0 : _d.text);\n            if ((_e = this.sums) === null || _e === void 0 ? void 0 : _e.html)\n                textElm.innerHTML = \"\".concat((_f = this.sums) === null || _f === void 0 ? void 0 : _f.html);\n            this.div.innerHTML = '';\n            this.div.appendChild(img);\n            this.div.appendChild(textElm);\n            this.div.title = divTitle;\n            this.div.style.display = '';\n        }\n        this.visible = true;\n    };\n    ClusterIcon.prototype.useStyle = function (sums) {\n        this.sums = sums;\n        var styles = this.cluster.getClusterer().getStyles();\n        var style = styles[Math.min(styles.length - 1, Math.max(0, sums.index - 1))];\n        if (style) {\n            this.url = style.url;\n            this.height = style.height;\n            this.width = style.width;\n            if (style.className) {\n                this.className = \"\".concat(this.clusterClassName, \" \").concat(style.className);\n            }\n            this.anchorText = style.anchorText || [0, 0];\n            this.anchorIcon = style.anchorIcon || [this.height / 2, this.width / 2];\n            this.textColor = style.textColor || 'black';\n            this.textSize = style.textSize || 11;\n            this.textDecoration = style.textDecoration || 'none';\n            this.fontWeight = style.fontWeight || 'bold';\n            this.fontStyle = style.fontStyle || 'normal';\n            this.fontFamily = style.fontFamily || 'Arial,sans-serif';\n            this.backgroundPosition = style.backgroundPosition || '0 0';\n        }\n    };\n    ClusterIcon.prototype.setCenter = function (center) {\n        this.center = center;\n    };\n    ClusterIcon.prototype.getPosFromLatLng = function (latlng) {\n        var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n        if (pos !== null) {\n            pos.x -= this.anchorIcon[1];\n            pos.y -= this.anchorIcon[0];\n        }\n        return pos;\n    };\n    return ClusterIcon;\n}());\n\n/* global google */\nvar Cluster$1 = /** @class */ (function () {\n    function Cluster(markerClusterer) {\n        this.markerClusterer = markerClusterer;\n        this.map = this.markerClusterer.getMap();\n        this.gridSize = this.markerClusterer.getGridSize();\n        this.minClusterSize = this.markerClusterer.getMinimumClusterSize();\n        this.averageCenter = this.markerClusterer.getAverageCenter();\n        this.markers = [];\n        this.center = undefined;\n        this.bounds = null;\n        this.clusterIcon = new ClusterIcon(this, this.markerClusterer.getStyles());\n        this.getSize = this.getSize.bind(this);\n        this.getMarkers = this.getMarkers.bind(this);\n        this.getCenter = this.getCenter.bind(this);\n        this.getMap = this.getMap.bind(this);\n        this.getClusterer = this.getClusterer.bind(this);\n        this.getBounds = this.getBounds.bind(this);\n        this.remove = this.remove.bind(this);\n        this.addMarker = this.addMarker.bind(this);\n        this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this);\n        this.calculateBounds = this.calculateBounds.bind(this);\n        this.updateIcon = this.updateIcon.bind(this);\n        this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);\n    }\n    Cluster.prototype.getSize = function () {\n        return this.markers.length;\n    };\n    Cluster.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Cluster.prototype.getCenter = function () {\n        return this.center;\n    };\n    Cluster.prototype.getMap = function () {\n        return this.map;\n    };\n    Cluster.prototype.getClusterer = function () {\n        return this.markerClusterer;\n    };\n    Cluster.prototype.getBounds = function () {\n        var bounds = new google.maps.LatLngBounds(this.center, this.center);\n        var markers = this.getMarkers();\n        for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n            var marker = markers_1[_i];\n            var position = marker.getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        return bounds;\n    };\n    Cluster.prototype.remove = function () {\n        this.clusterIcon.setMap(null);\n        this.markers = [];\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        delete this.markers;\n    };\n    Cluster.prototype.addMarker = function (marker) {\n        var _a;\n        if (this.isMarkerAlreadyAdded(marker)) {\n            return false;\n        }\n        if (!this.center) {\n            var position = marker.getPosition();\n            if (position) {\n                this.center = position;\n                this.calculateBounds();\n            }\n        }\n        else {\n            if (this.averageCenter) {\n                var position = marker.getPosition();\n                if (position) {\n                    var length_1 = this.markers.length + 1;\n                    this.center = new google.maps.LatLng((this.center.lat() * (length_1 - 1) + position.lat()) / length_1, (this.center.lng() * (length_1 - 1) + position.lng()) / length_1);\n                    this.calculateBounds();\n                }\n            }\n        }\n        marker.isAdded = true;\n        this.markers.push(marker);\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            // Zoomed in past max zoom, so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount < this.minClusterSize) {\n            // Min cluster size not reached so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount === this.minClusterSize) {\n            // Hide the markers that were showing.\n            for (var _i = 0, _b = this.markers; _i < _b.length; _i++) {\n                var markerElement = _b[_i];\n                markerElement.setMap(null);\n            }\n        }\n        else {\n            marker.setMap(null);\n        }\n        return true;\n    };\n    Cluster.prototype.isMarkerInClusterBounds = function (marker) {\n        if (this.bounds !== null) {\n            var position = marker.getPosition();\n            if (position) {\n                return this.bounds.contains(position);\n            }\n        }\n        return false;\n    };\n    Cluster.prototype.calculateBounds = function () {\n        this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));\n    };\n    Cluster.prototype.updateIcon = function () {\n        var _a;\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            this.clusterIcon.hide();\n            return;\n        }\n        if (mCount < this.minClusterSize) {\n            // Min cluster size not yet reached.\n            this.clusterIcon.hide();\n            return;\n        }\n        if (this.center) {\n            this.clusterIcon.setCenter(this.center);\n        }\n        this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length));\n        this.clusterIcon.show();\n    };\n    Cluster.prototype.isMarkerAlreadyAdded = function (marker) {\n        if (this.markers.includes) {\n            return this.markers.includes(marker);\n        }\n        for (var i = 0; i < this.markers.length; i++) {\n            if (marker === this.markers[i]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Cluster;\n}());\n\n/* global google */\n/**\n * Supports up to 9007199254740991 (Number.MAX_SAFE_INTEGER) markers\n * which is not a problem as max array length is 4294967296 (2**32)\n */\nfunction CALCULATOR(markers, numStyles) {\n    var count = markers.length;\n    var numberOfDigits = count.toString().length;\n    var index = Math.min(numberOfDigits, numStyles);\n    return {\n        text: count.toString(),\n        index: index,\n        title: '',\n    };\n}\nvar BATCH_SIZE = 2000;\nvar BATCH_SIZE_IE = 500;\nvar IMAGE_PATH = 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m';\nvar IMAGE_EXTENSION = 'png';\nvar IMAGE_SIZES = [53, 56, 66, 78, 90];\nvar CLUSTERER_CLASS = 'cluster';\nvar Clusterer = /** @class */ (function () {\n    function Clusterer(map, optMarkers, optOptions) {\n        if (optMarkers === void 0) { optMarkers = []; }\n        if (optOptions === void 0) { optOptions = {}; }\n        this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this);\n        this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this);\n        this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this);\n        this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this);\n        this.addToClosestCluster = this.addToClosestCluster.bind(this);\n        this.getImageExtension = this.getImageExtension.bind(this);\n        this.setImageExtension = this.setImageExtension.bind(this);\n        this.getExtendedBounds = this.getExtendedBounds.bind(this);\n        this.getAverageCenter = this.getAverageCenter.bind(this);\n        this.setAverageCenter = this.setAverageCenter.bind(this);\n        this.getTotalClusters = this.getTotalClusters.bind(this);\n        this.fitMapToMarkers = this.fitMapToMarkers.bind(this);\n        this.getIgnoreHidden = this.getIgnoreHidden.bind(this);\n        this.setIgnoreHidden = this.setIgnoreHidden.bind(this);\n        this.getClusterClass = this.getClusterClass.bind(this);\n        this.setClusterClass = this.setClusterClass.bind(this);\n        this.getTotalMarkers = this.getTotalMarkers.bind(this);\n        this.getZoomOnClick = this.getZoomOnClick.bind(this);\n        this.setZoomOnClick = this.setZoomOnClick.bind(this);\n        this.getBatchSizeIE = this.getBatchSizeIE.bind(this);\n        this.setBatchSizeIE = this.setBatchSizeIE.bind(this);\n        this.createClusters = this.createClusters.bind(this);\n        this.onZoomChanged = this.onZoomChanged.bind(this);\n        this.getImageSizes = this.getImageSizes.bind(this);\n        this.setImageSizes = this.setImageSizes.bind(this);\n        this.getCalculator = this.getCalculator.bind(this);\n        this.setCalculator = this.setCalculator.bind(this);\n        this.removeMarkers = this.removeMarkers.bind(this);\n        this.resetViewport = this.resetViewport.bind(this);\n        this.getImagePath = this.getImagePath.bind(this);\n        this.setImagePath = this.setImagePath.bind(this);\n        this.pushMarkerTo = this.pushMarkerTo.bind(this);\n        this.removeMarker = this.removeMarker.bind(this);\n        this.clearMarkers = this.clearMarkers.bind(this);\n        this.setupStyles = this.setupStyles.bind(this);\n        this.getGridSize = this.getGridSize.bind(this);\n        this.setGridSize = this.setGridSize.bind(this);\n        this.getClusters = this.getClusters.bind(this);\n        this.getMaxZoom = this.getMaxZoom.bind(this);\n        this.setMaxZoom = this.setMaxZoom.bind(this);\n        this.getMarkers = this.getMarkers.bind(this);\n        this.addMarkers = this.addMarkers.bind(this);\n        this.getStyles = this.getStyles.bind(this);\n        this.setStyles = this.setStyles.bind(this);\n        this.addMarker = this.addMarker.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.getTitle = this.getTitle.bind(this);\n        this.setTitle = this.setTitle.bind(this);\n        this.repaint = this.repaint.bind(this);\n        this.onIdle = this.onIdle.bind(this);\n        this.redraw = this.redraw.bind(this);\n        this.onAdd = this.onAdd.bind(this);\n        this.draw = this.draw.bind(this);\n        this.extend = this.extend.bind(this);\n        this.extend(Clusterer, google.maps.OverlayView);\n        this.markers = [];\n        this.clusters = [];\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n        this.gridSize = optOptions.gridSize || 60;\n        this.minClusterSize = optOptions.minimumClusterSize || 2;\n        this.maxZoom = optOptions.maxZoom || null;\n        this.styles = optOptions.styles || [];\n        this.title = optOptions.title || '';\n        this.zoomOnClick = true;\n        if (optOptions.zoomOnClick !== undefined) {\n            this.zoomOnClick = optOptions.zoomOnClick;\n        }\n        this.averageCenter = false;\n        if (optOptions.averageCenter !== undefined) {\n            this.averageCenter = optOptions.averageCenter;\n        }\n        this.ignoreHidden = false;\n        if (optOptions.ignoreHidden !== undefined) {\n            this.ignoreHidden = optOptions.ignoreHidden;\n        }\n        this.enableRetinaIcons = false;\n        if (optOptions.enableRetinaIcons !== undefined) {\n            this.enableRetinaIcons = optOptions.enableRetinaIcons;\n        }\n        this.imagePath = optOptions.imagePath || IMAGE_PATH;\n        this.imageExtension = optOptions.imageExtension || IMAGE_EXTENSION;\n        this.imageSizes = optOptions.imageSizes || IMAGE_SIZES;\n        this.calculator = optOptions.calculator || CALCULATOR;\n        this.batchSize = optOptions.batchSize || BATCH_SIZE;\n        this.batchSizeIE = optOptions.batchSizeIE || BATCH_SIZE_IE;\n        this.clusterClass = optOptions.clusterClass || CLUSTERER_CLASS;\n        if (navigator.userAgent.toLowerCase().indexOf('msie') !== -1) {\n            // Try to avoid IE timeout when processing a huge number of markers:\n            this.batchSize = this.batchSizeIE;\n        }\n        this.timerRefStatic = null;\n        this.setupStyles();\n        this.addMarkers(optMarkers, true);\n        this.setMap(map); // Note: this causes onAdd to be called\n    }\n    Clusterer.prototype.onZoomChanged = function () {\n        var _a, _b;\n        this.resetViewport(false);\n        // Workaround for this Google bug: when map is at level 0 and \"-\" of\n        // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n        // the map doesn't zoom out any further. In this situation, no \"idle\"\n        // event is triggered so the cluster markers that have been removed\n        // do not get redrawn. Same goes for a zoom in at maxZoom.\n        if (((_a = this.getMap()) === null || _a === void 0 ? void 0 : _a.getZoom()) === (this.get('minZoom') || 0) ||\n            ((_b = this.getMap()) === null || _b === void 0 ? void 0 : _b.getZoom()) === this.get('maxZoom')) {\n            google.maps.event.trigger(this, 'idle');\n        }\n    };\n    Clusterer.prototype.onIdle = function () {\n        this.redraw();\n    };\n    Clusterer.prototype.onAdd = function () {\n        var map = this.getMap();\n        this.activeMap = map;\n        this.ready = true;\n        this.repaint();\n        if (map !== null) {\n            // Add the map event listeners\n            this.listeners = [\n                google.maps.event.addListener(map, 'zoom_changed', this.onZoomChanged),\n                google.maps.event.addListener(map, 'idle', this.onIdle),\n            ];\n        }\n    };\n    Clusterer.prototype.onRemove = function () {\n        // Put all the managed markers back on the map:\n        for (var _i = 0, _a = this.markers; _i < _a.length; _i++) {\n            var marker = _a[_i];\n            if (marker.getMap() !== this.activeMap) {\n                marker.setMap(this.activeMap);\n            }\n        }\n        // Remove all clusters:\n        for (var _b = 0, _c = this.clusters; _b < _c.length; _b++) {\n            var cluster = _c[_b];\n            cluster.remove();\n        }\n        this.clusters = [];\n        // Remove map event listeners:\n        for (var _d = 0, _e = this.listeners; _d < _e.length; _d++) {\n            var listener = _e[_d];\n            google.maps.event.removeListener(listener);\n        }\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n    };\n    Clusterer.prototype.draw = function () { return; };\n    Clusterer.prototype.getMap = function () { return null; };\n    Clusterer.prototype.getPanes = function () { return null; };\n    Clusterer.prototype.getProjection = function () {\n        return {\n            fromContainerPixelToLatLng: function () { return null; },\n            fromDivPixelToLatLng: function () { return null; },\n            fromLatLngToContainerPixel: function () { return null; },\n            fromLatLngToDivPixel: function () { return null; },\n            getVisibleRegion: function () { return null; },\n            getWorldWidth: function () { return 0; }\n        };\n    };\n    Clusterer.prototype.setMap = function () { return; };\n    Clusterer.prototype.addListener = function () {\n        return {\n            remove: function () { return; }\n        };\n    };\n    Clusterer.prototype.bindTo = function () { return; };\n    Clusterer.prototype.get = function () { return; };\n    Clusterer.prototype.notify = function () { return; };\n    Clusterer.prototype.set = function () { return; };\n    Clusterer.prototype.setValues = function () { return; };\n    Clusterer.prototype.unbind = function () { return; };\n    Clusterer.prototype.unbindAll = function () { return; };\n    Clusterer.prototype.setupStyles = function () {\n        if (this.styles.length > 0) {\n            return;\n        }\n        for (var i = 0; i < this.imageSizes.length; i++) {\n            this.styles.push({\n                url: \"\".concat(this.imagePath + (i + 1), \".\").concat(this.imageExtension),\n                height: this.imageSizes[i] || 0,\n                width: this.imageSizes[i] || 0,\n            });\n        }\n    };\n    Clusterer.prototype.fitMapToMarkers = function () {\n        var markers = this.getMarkers();\n        var bounds = new google.maps.LatLngBounds();\n        for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n            var marker = markers_1[_i];\n            var position = marker.getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        var map = this.getMap();\n        if (map !== null && 'fitBounds' in map) {\n            map.fitBounds(bounds);\n        }\n    };\n    Clusterer.prototype.getGridSize = function () {\n        return this.gridSize;\n    };\n    Clusterer.prototype.setGridSize = function (gridSize) {\n        this.gridSize = gridSize;\n    };\n    Clusterer.prototype.getMinimumClusterSize = function () {\n        return this.minClusterSize;\n    };\n    Clusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n        this.minClusterSize = minimumClusterSize;\n    };\n    Clusterer.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    Clusterer.prototype.setMaxZoom = function (maxZoom) {\n        this.maxZoom = maxZoom;\n    };\n    Clusterer.prototype.getStyles = function () {\n        return this.styles;\n    };\n    Clusterer.prototype.setStyles = function (styles) {\n        this.styles = styles;\n    };\n    Clusterer.prototype.getTitle = function () {\n        return this.title;\n    };\n    Clusterer.prototype.setTitle = function (title) {\n        this.title = title;\n    };\n    Clusterer.prototype.getZoomOnClick = function () {\n        return this.zoomOnClick;\n    };\n    Clusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n        this.zoomOnClick = zoomOnClick;\n    };\n    Clusterer.prototype.getAverageCenter = function () {\n        return this.averageCenter;\n    };\n    Clusterer.prototype.setAverageCenter = function (averageCenter) {\n        this.averageCenter = averageCenter;\n    };\n    Clusterer.prototype.getIgnoreHidden = function () {\n        return this.ignoreHidden;\n    };\n    Clusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n        this.ignoreHidden = ignoreHidden;\n    };\n    Clusterer.prototype.getEnableRetinaIcons = function () {\n        return this.enableRetinaIcons;\n    };\n    Clusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n        this.enableRetinaIcons = enableRetinaIcons;\n    };\n    Clusterer.prototype.getImageExtension = function () {\n        return this.imageExtension;\n    };\n    Clusterer.prototype.setImageExtension = function (imageExtension) {\n        this.imageExtension = imageExtension;\n    };\n    Clusterer.prototype.getImagePath = function () {\n        return this.imagePath;\n    };\n    Clusterer.prototype.setImagePath = function (imagePath) {\n        this.imagePath = imagePath;\n    };\n    Clusterer.prototype.getImageSizes = function () {\n        return this.imageSizes;\n    };\n    Clusterer.prototype.setImageSizes = function (imageSizes) {\n        this.imageSizes = imageSizes;\n    };\n    Clusterer.prototype.getCalculator = function () {\n        return this.calculator;\n    };\n    Clusterer.prototype.setCalculator = function (calculator) {\n        this.calculator = calculator;\n    };\n    Clusterer.prototype.getBatchSizeIE = function () {\n        return this.batchSizeIE;\n    };\n    Clusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n        this.batchSizeIE = batchSizeIE;\n    };\n    Clusterer.prototype.getClusterClass = function () {\n        return this.clusterClass;\n    };\n    Clusterer.prototype.setClusterClass = function (clusterClass) {\n        this.clusterClass = clusterClass;\n    };\n    Clusterer.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Clusterer.prototype.getTotalMarkers = function () {\n        return this.markers.length;\n    };\n    Clusterer.prototype.getClusters = function () {\n        return this.clusters;\n    };\n    Clusterer.prototype.getTotalClusters = function () {\n        return this.clusters.length;\n    };\n    Clusterer.prototype.addMarker = function (marker, optNoDraw) {\n        this.pushMarkerTo(marker);\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.addMarkers = function (markers, optNoDraw) {\n        for (var key in markers) {\n            if (Object.prototype.hasOwnProperty.call(markers, key)) {\n                var marker = markers[key];\n                if (marker) {\n                    this.pushMarkerTo(marker);\n                }\n            }\n        }\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.pushMarkerTo = function (marker) {\n        var _this = this;\n        // If the marker is draggable add a listener so we can update the clusters on the dragend:\n        if (marker.getDraggable()) {\n            google.maps.event.addListener(marker, 'dragend', function () {\n                if (_this.ready) {\n                    marker.isAdded = false;\n                    _this.repaint();\n                }\n            });\n        }\n        marker.isAdded = false;\n        this.markers.push(marker);\n    };\n    Clusterer.prototype.removeMarker_ = function (marker) {\n        var index = -1;\n        if (this.markers.indexOf) {\n            index = this.markers.indexOf(marker);\n        }\n        else {\n            for (var i = 0; i < this.markers.length; i++) {\n                if (marker === this.markers[i]) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index === -1) {\n            // Marker is not in our list of markers, so do nothing:\n            return false;\n        }\n        marker.setMap(null);\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n        return true;\n    };\n    Clusterer.prototype.removeMarker = function (marker, optNoDraw) {\n        var removed = this.removeMarker_(marker);\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.removeMarkers = function (markers, optNoDraw) {\n        var removed = false;\n        for (var _i = 0, markers_2 = markers; _i < markers_2.length; _i++) {\n            var marker = markers_2[_i];\n            removed = removed || this.removeMarker_(marker);\n        }\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.clearMarkers = function () {\n        this.resetViewport(true);\n        this.markers = [];\n    };\n    Clusterer.prototype.repaint = function () {\n        var oldClusters = this.clusters.slice();\n        this.clusters = [];\n        this.resetViewport(false);\n        this.redraw();\n        // Remove the old clusters.\n        // Do it in a timeout to prevent blinking effect.\n        setTimeout(function timeout() {\n            for (var _i = 0, oldClusters_1 = oldClusters; _i < oldClusters_1.length; _i++) {\n                var oldCluster = oldClusters_1[_i];\n                oldCluster.remove();\n            }\n        }, 0);\n    };\n    Clusterer.prototype.getExtendedBounds = function (bounds) {\n        var projection = this.getProjection();\n        // Convert the points to pixels and the extend out by the grid size.\n        var trPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()));\n        if (trPix !== null) {\n            trPix.x += this.gridSize;\n            trPix.y -= this.gridSize;\n        }\n        var blPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()));\n        if (blPix !== null) {\n            blPix.x -= this.gridSize;\n            blPix.y += this.gridSize;\n        }\n        // Extend the bounds to contain the new bounds.\n        if (trPix !== null) {\n            // Convert the pixel points back to LatLng nw\n            var point1 = projection.fromDivPixelToLatLng(trPix);\n            if (point1 !== null) {\n                bounds.extend(point1);\n            }\n        }\n        if (blPix !== null) {\n            // Convert the pixel points back to LatLng sw\n            var point2 = projection.fromDivPixelToLatLng(blPix);\n            if (point2 !== null) {\n                bounds.extend(point2);\n            }\n        }\n        return bounds;\n    };\n    Clusterer.prototype.redraw = function () {\n        // Redraws all the clusters.\n        this.createClusters(0);\n    };\n    Clusterer.prototype.resetViewport = function (optHide) {\n        // Remove all the clusters\n        for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n            var cluster = _a[_i];\n            cluster.remove();\n        }\n        this.clusters = [];\n        // Reset the markers to not be added and to be removed from the map.\n        for (var _b = 0, _c = this.markers; _b < _c.length; _b++) {\n            var marker = _c[_b];\n            marker.isAdded = false;\n            if (optHide) {\n                marker.setMap(null);\n            }\n        }\n    };\n    Clusterer.prototype.distanceBetweenPoints = function (p1, p2) {\n        var R = 6371; // Radius of the Earth in km\n        var dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n        var dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos((p1.lat() * Math.PI) / 180) *\n                Math.cos((p2.lat() * Math.PI) / 180) *\n                Math.sin(dLon / 2) *\n                Math.sin(dLon / 2);\n        return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));\n    };\n    Clusterer.prototype.isMarkerInBounds = function (marker, bounds) {\n        var position = marker.getPosition();\n        if (position) {\n            return bounds.contains(position);\n        }\n        return false;\n    };\n    Clusterer.prototype.addToClosestCluster = function (marker) {\n        var cluster;\n        var distance = 40000; // Some large number\n        var clusterToAddTo = null;\n        for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n            var clusterElement = _a[_i];\n            cluster = clusterElement;\n            var center = cluster.getCenter();\n            var position = marker.getPosition();\n            if (center && position) {\n                var d = this.distanceBetweenPoints(center, position);\n                if (d < distance) {\n                    distance = d;\n                    clusterToAddTo = cluster;\n                }\n            }\n        }\n        if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n            clusterToAddTo.addMarker(marker);\n        }\n        else {\n            cluster = new Cluster$1(this);\n            cluster.addMarker(marker);\n            this.clusters.push(cluster);\n        }\n    };\n    Clusterer.prototype.createClusters = function (iFirst) {\n        var _this = this;\n        if (!this.ready) {\n            return;\n        }\n        // Cancel previous batch processing if we're working on the first batch:\n        if (iFirst === 0) {\n            /**\n             * This event is fired when the <code>Clusterer</code> begins\n             *  clustering markers.\n             * @name Clusterer#clusteringbegin\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringbegin', this);\n            if (this.timerRefStatic !== null) {\n                window.clearTimeout(this.timerRefStatic);\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                delete this.timerRefStatic;\n            }\n        }\n        var map = this.getMap();\n        var bounds = map !== null && 'getBounds' in map ? map.getBounds() : null;\n        var zoom = (map === null || map === void 0 ? void 0 : map.getZoom()) || 0;\n        // Get our current map view bounds.\n        // Create a new bounds object so we don't affect the map.\n        //\n        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n        var mapBounds = zoom > 3\n            ? new google.maps.LatLngBounds(bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest(), bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast())\n            : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n        var extendedMapBounds = this.getExtendedBounds(mapBounds);\n        var iLast = Math.min(iFirst + this.batchSize, this.markers.length);\n        for (var i = iFirst; i < iLast; i++) {\n            var marker = this.markers[i];\n            if (marker && !marker.isAdded && this.isMarkerInBounds(marker, extendedMapBounds) && (!this.ignoreHidden || (this.ignoreHidden && marker.getVisible()))) {\n                this.addToClosestCluster(marker);\n            }\n        }\n        if (iLast < this.markers.length) {\n            this.timerRefStatic = window.setTimeout(function () {\n                _this.createClusters(iLast);\n            }, 0);\n        }\n        else {\n            this.timerRefStatic = null;\n            /**\n             * This event is fired when the <code>Clusterer</code> stops\n             *  clustering markers.\n             * @name Clusterer#clusteringend\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringend', this);\n            for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n                var cluster = _a[_i];\n                cluster.updateIcon();\n            }\n        }\n    };\n    Clusterer.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            for (var property in object.prototype) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                var prop = property;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.prototype[prop] = object.prototype[prop];\n            }\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return Clusterer;\n}());\n\nvar eventMap$e = {\n    onClick: 'click',\n    onClusteringBegin: 'clusteringbegin',\n    onClusteringEnd: 'clusteringend',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n};\nvar updaterMap$e = {\n    averageCenter: function (instance, averageCenter) {\n        instance.setAverageCenter(averageCenter);\n    },\n    batchSizeIE: function (instance, batchSizeIE) {\n        instance.setBatchSizeIE(batchSizeIE);\n    },\n    calculator: function (instance, calculator) {\n        instance.setCalculator(calculator);\n    },\n    clusterClass: function (instance, clusterClass) {\n        instance.setClusterClass(clusterClass);\n    },\n    enableRetinaIcons: function (instance, enableRetinaIcons) {\n        instance.setEnableRetinaIcons(enableRetinaIcons);\n    },\n    gridSize: function (instance, gridSize) {\n        instance.setGridSize(gridSize);\n    },\n    ignoreHidden: function (instance, ignoreHidden) {\n        instance.setIgnoreHidden(ignoreHidden);\n    },\n    imageExtension: function (instance, imageExtension) {\n        instance.setImageExtension(imageExtension);\n    },\n    imagePath: function (instance, imagePath) {\n        instance.setImagePath(imagePath);\n    },\n    imageSizes: function (instance, imageSizes) {\n        instance.setImageSizes(imageSizes);\n    },\n    maxZoom: function (instance, maxZoom) {\n        instance.setMaxZoom(maxZoom);\n    },\n    minimumClusterSize: function (instance, minimumClusterSize) {\n        instance.setMinimumClusterSize(minimumClusterSize);\n    },\n    styles: function (instance, styles) {\n        instance.setStyles(styles);\n    },\n    title: function (instance, title) {\n        instance.setTitle(title);\n    },\n    zoomOnClick: function (instance, zoomOnClick) {\n        instance.setZoomOnClick(zoomOnClick);\n    },\n};\nvar defaultOptions$4 = {};\nfunction MarkerClustererFunctional(props) {\n    var children = props.children, options = props.options, averageCenter = props.averageCenter, batchSizeIE = props.batchSizeIE, calculator = props.calculator, clusterClass = props.clusterClass, enableRetinaIcons = props.enableRetinaIcons, gridSize = props.gridSize, ignoreHidden = props.ignoreHidden, imageExtension = props.imageExtension, imagePath = props.imagePath, imageSizes = props.imageSizes, maxZoom = props.maxZoom, minimumClusterSize = props.minimumClusterSize, styles = props.styles, title = props.title, zoomOnClick = props.zoomOnClick, onClick = props.onClick, onClusteringBegin = props.onClusteringBegin, onClusteringEnd = props.onClusteringEnd, onMouseOver = props.onMouseOver, onMouseOut = props.onMouseOut, onLoad = props.onLoad, onUnmount = props.onUnmount;\n    var _a = react.useState(null), instance = _a[0], setInstance = _a[1];\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), clickListener = _b[0], setClickListener = _b[1];\n    var _c = react.useState(null), clusteringBeginListener = _c[0], setClusteringBeginListener = _c[1];\n    var _d = react.useState(null), clusteringEndListener = _d[0], setClusteringEndListener = _d[1];\n    var _e = react.useState(null), mouseoutListener = _e[0], setMouseoutListener = _e[1];\n    var _f = react.useState(null), mouseoverListener = _f[0], setMouseoverListener = _f[1];\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, eventMap$e.onMouseOut, onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, eventMap$e.onMouseOver, onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, eventMap$e.onClick, onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onClusteringBegin) {\n            if (clusteringBeginListener !== null) {\n                google.maps.event.removeListener(clusteringBeginListener);\n            }\n            setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringBegin, onClusteringBegin));\n        }\n    }, [onClusteringBegin]);\n    react.useEffect(function () {\n        if (instance && onClusteringEnd) {\n            if (clusteringEndListener !== null) {\n                google.maps.event.removeListener(clusteringEndListener);\n            }\n            setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringEnd, onClusteringEnd));\n        }\n    }, [onClusteringEnd]);\n    react.useEffect(function () {\n        if (typeof averageCenter !== 'undefined' && instance !== null) {\n            updaterMap$e.averageCenter(instance, averageCenter);\n        }\n    }, [instance, averageCenter]);\n    react.useEffect(function () {\n        if (typeof batchSizeIE !== 'undefined' && instance !== null) {\n            updaterMap$e.batchSizeIE(instance, batchSizeIE);\n        }\n    }, [instance, batchSizeIE]);\n    react.useEffect(function () {\n        if (typeof calculator !== 'undefined' && instance !== null) {\n            updaterMap$e.calculator(instance, calculator);\n        }\n    }, [instance, calculator]);\n    react.useEffect(function () {\n        if (typeof clusterClass !== 'undefined' && instance !== null) {\n            updaterMap$e.clusterClass(instance, clusterClass);\n        }\n    }, [instance, clusterClass]);\n    react.useEffect(function () {\n        if (typeof enableRetinaIcons !== 'undefined' && instance !== null) {\n            updaterMap$e.enableRetinaIcons(instance, enableRetinaIcons);\n        }\n    }, [instance, enableRetinaIcons]);\n    react.useEffect(function () {\n        if (typeof gridSize !== 'undefined' && instance !== null) {\n            updaterMap$e.gridSize(instance, gridSize);\n        }\n    }, [instance, gridSize]);\n    react.useEffect(function () {\n        if (typeof ignoreHidden !== 'undefined' && instance !== null) {\n            updaterMap$e.ignoreHidden(instance, ignoreHidden);\n        }\n    }, [instance, ignoreHidden]);\n    react.useEffect(function () {\n        if (typeof imageExtension !== 'undefined' && instance !== null) {\n            updaterMap$e.imageExtension(instance, imageExtension);\n        }\n    }, [instance, imageExtension]);\n    react.useEffect(function () {\n        if (typeof imagePath !== 'undefined' && instance !== null) {\n            updaterMap$e.imagePath(instance, imagePath);\n        }\n    }, [instance, imagePath]);\n    react.useEffect(function () {\n        if (typeof imageSizes !== 'undefined' && instance !== null) {\n            updaterMap$e.imageSizes(instance, imageSizes);\n        }\n    }, [instance, imageSizes]);\n    react.useEffect(function () {\n        if (typeof maxZoom !== 'undefined' && instance !== null) {\n            updaterMap$e.maxZoom(instance, maxZoom);\n        }\n    }, [instance, maxZoom]);\n    react.useEffect(function () {\n        if (typeof minimumClusterSize !== 'undefined' && instance !== null) {\n            updaterMap$e.minimumClusterSize(instance, minimumClusterSize);\n        }\n    }, [instance, minimumClusterSize]);\n    react.useEffect(function () {\n        if (typeof styles !== 'undefined' && instance !== null) {\n            updaterMap$e.styles(instance, styles);\n        }\n    }, [instance, styles]);\n    react.useEffect(function () {\n        if (typeof title !== 'undefined' && instance !== null) {\n            updaterMap$e.title(instance, title);\n        }\n    }, [instance, title]);\n    react.useEffect(function () {\n        if (typeof zoomOnClick !== 'undefined' && instance !== null) {\n            updaterMap$e.zoomOnClick(instance, zoomOnClick);\n        }\n    }, [instance, zoomOnClick]);\n    react.useEffect(function () {\n        if (!map)\n            return;\n        var clustererOptions = __assign({}, (options || defaultOptions$4));\n        var clusterer = new Clusterer(map, [], clustererOptions);\n        if (averageCenter) {\n            updaterMap$e.averageCenter(clusterer, averageCenter);\n        }\n        if (batchSizeIE) {\n            updaterMap$e.batchSizeIE(clusterer, batchSizeIE);\n        }\n        if (calculator) {\n            updaterMap$e.calculator(clusterer, calculator);\n        }\n        if (clusterClass) {\n            updaterMap$e.clusterClass(clusterer, clusterClass);\n        }\n        if (enableRetinaIcons) {\n            updaterMap$e.enableRetinaIcons(clusterer, enableRetinaIcons);\n        }\n        if (gridSize) {\n            updaterMap$e.gridSize(clusterer, gridSize);\n        }\n        if (ignoreHidden) {\n            updaterMap$e.ignoreHidden(clusterer, ignoreHidden);\n        }\n        if (imageExtension) {\n            updaterMap$e.imageExtension(clusterer, imageExtension);\n        }\n        if (imagePath) {\n            updaterMap$e.imagePath(clusterer, imagePath);\n        }\n        if (imageSizes) {\n            updaterMap$e.imageSizes(clusterer, imageSizes);\n        }\n        if (maxZoom) {\n            updaterMap$e.maxZoom(clusterer, maxZoom);\n        }\n        if (minimumClusterSize) {\n            updaterMap$e.minimumClusterSize(clusterer, minimumClusterSize);\n        }\n        if (styles) {\n            updaterMap$e.styles(clusterer, styles);\n        }\n        if (title) {\n            updaterMap$e.title(clusterer, title);\n        }\n        if (zoomOnClick) {\n            updaterMap$e.zoomOnClick(clusterer, zoomOnClick);\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOut, onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOver, onMouseOver));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(clusterer, eventMap$e.onClick, onClick));\n        }\n        if (onClusteringBegin) {\n            setClusteringBeginListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringBegin, onClusteringBegin));\n        }\n        if (onClusteringEnd) {\n            setClusteringEndListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringEnd, onClusteringEnd));\n        }\n        setInstance(clusterer);\n        if (onLoad) {\n            onLoad(clusterer);\n        }\n        return function () {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (clusteringBeginListener !== null) {\n                google.maps.event.removeListener(clusteringBeginListener);\n            }\n            if (clusteringEndListener !== null) {\n                google.maps.event.removeListener(clusteringEndListener);\n            }\n            if (onUnmount) {\n                onUnmount(clusterer);\n            }\n        };\n    }, []);\n    return instance !== null ? children(instance) || null : null;\n}\nvar MarkerClustererF = react.memo(MarkerClustererFunctional);\nvar ClustererComponent = /** @class */ (function (_super) {\n    __extends(ClustererComponent, _super);\n    function ClustererComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            markerClusterer: null,\n        };\n        _this.setClustererCallback = function () {\n            if (_this.state.markerClusterer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.markerClusterer);\n            }\n        };\n        return _this;\n    }\n    ClustererComponent.prototype.componentDidMount = function () {\n        if (this.context) {\n            var markerClusterer_1 = new Clusterer(this.context, [], this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps: {},\n                nextProps: this.props,\n                instance: markerClusterer_1,\n            });\n            this.setState(function () {\n                return {\n                    markerClusterer: markerClusterer_1,\n                };\n            }, this.setClustererCallback);\n        }\n    };\n    ClustererComponent.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.markerClusterer) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.markerClusterer,\n            });\n        }\n    };\n    ClustererComponent.prototype.componentWillUnmount = function () {\n        if (this.state.markerClusterer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.markerClusterer);\n            }\n            unregisterEvents(this.registeredEvents);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.state.markerClusterer.setMap(null);\n        }\n    };\n    ClustererComponent.prototype.render = function () {\n        return this.state.markerClusterer !== null\n            ? this.props.children(this.state.markerClusterer)\n            : null;\n    };\n    ClustererComponent.contextType = MapContext;\n    return ClustererComponent;\n}(react.PureComponent));\n\n// This handler prevents an event in the InfoBox from being passed on to the map.\nfunction cancelHandler(event) {\n    event.cancelBubble = true;\n    if (event.stopPropagation) {\n        event.stopPropagation();\n    }\n}\nvar InfoBox = /** @class */ (function () {\n    function InfoBox(options) {\n        if (options === void 0) { options = {}; }\n        this.getCloseClickHandler = this.getCloseClickHandler.bind(this);\n        this.closeClickHandler = this.closeClickHandler.bind(this);\n        this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this);\n        this.addClickHandler = this.addClickHandler.bind(this);\n        this.getCloseBoxImg = this.getCloseBoxImg.bind(this);\n        this.getBoxWidths = this.getBoxWidths.bind(this);\n        this.setBoxStyle = this.setBoxStyle.bind(this);\n        this.setPosition = this.setPosition.bind(this);\n        this.getPosition = this.getPosition.bind(this);\n        this.setOptions = this.setOptions.bind(this);\n        this.setContent = this.setContent.bind(this);\n        this.setVisible = this.setVisible.bind(this);\n        this.getContent = this.getContent.bind(this);\n        this.getVisible = this.getVisible.bind(this);\n        this.setZIndex = this.setZIndex.bind(this);\n        this.getZIndex = this.getZIndex.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.panBox = this.panBox.bind(this);\n        this.extend = this.extend.bind(this);\n        this.close = this.close.bind(this);\n        this.draw = this.draw.bind(this);\n        this.show = this.show.bind(this);\n        this.hide = this.hide.bind(this);\n        this.open = this.open.bind(this);\n        this.extend(InfoBox, google.maps.OverlayView);\n        // Standard options (in common with google.maps.InfoWindow):\n        this.content = options.content || '';\n        this.disableAutoPan = options.disableAutoPan || false;\n        this.maxWidth = options.maxWidth || 0;\n        this.pixelOffset = options.pixelOffset || new google.maps.Size(0, 0);\n        this.position = options.position || new google.maps.LatLng(0, 0);\n        this.zIndex = options.zIndex || null;\n        // Additional options (unique to InfoBox):\n        this.boxClass = options.boxClass || 'infoBox';\n        this.boxStyle = options.boxStyle || {};\n        this.closeBoxMargin = options.closeBoxMargin || '2px';\n        this.closeBoxURL = options.closeBoxURL || 'http://www.google.com/intl/en_us/mapfiles/close.gif';\n        if (options.closeBoxURL === '') {\n            this.closeBoxURL = '';\n        }\n        this.infoBoxClearance = options.infoBoxClearance || new google.maps.Size(1, 1);\n        if (typeof options.visible === 'undefined') {\n            if (typeof options.isHidden === 'undefined') {\n                options.visible = true;\n            }\n            else {\n                options.visible = !options.isHidden;\n            }\n        }\n        this.isHidden = !options.visible;\n        this.alignBottom = options.alignBottom || false;\n        this.pane = options.pane || 'floatPane';\n        this.enableEventPropagation = options.enableEventPropagation || false;\n        this.div = null;\n        this.closeListener = null;\n        this.moveListener = null;\n        this.mapListener = null;\n        this.contextListener = null;\n        this.eventListeners = null;\n        this.fixedWidthSet = null;\n    }\n    InfoBox.prototype.createInfoBoxDiv = function () {\n        var _this = this;\n        // This handler ignores the current event in the InfoBox and conditionally prevents\n        // the event from being passed on to the map. It is used for the contextmenu event.\n        var ignoreHandler = function (event) {\n            event.returnValue = false;\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            if (!_this.enableEventPropagation) {\n                cancelHandler(event);\n            }\n        };\n        if (!this.div) {\n            this.div = document.createElement('div');\n            this.setBoxStyle();\n            if (typeof this.content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + this.content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(this.content);\n            }\n            var panes = this.getPanes();\n            if (panes !== null) {\n                panes[this.pane].appendChild(this.div); // Add the InfoBox div to the DOM\n            }\n            this.addClickHandler();\n            if (this.div.style.width) {\n                this.fixedWidthSet = true;\n            }\n            else {\n                if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth) {\n                    this.div.style.width = this.maxWidth + 'px';\n                    this.fixedWidthSet = true;\n                }\n                else {\n                    // The following code is needed to overcome problems with MSIE\n                    var bw = this.getBoxWidths();\n                    this.div.style.width = this.div.offsetWidth - bw.left - bw.right + 'px';\n                    this.fixedWidthSet = false;\n                }\n            }\n            this.panBox(this.disableAutoPan);\n            if (!this.enableEventPropagation) {\n                this.eventListeners = [];\n                // Cancel event propagation.\n                // Note: mousemove not included (to resolve Issue 152)\n                var events = [\n                    'mousedown',\n                    'mouseover',\n                    'mouseout',\n                    'mouseup',\n                    'click',\n                    'dblclick',\n                    'touchstart',\n                    'touchend',\n                    'touchmove',\n                ];\n                for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n                    var event_1 = events_1[_i];\n                    this.eventListeners.push(google.maps.event.addListener(this.div, event_1, cancelHandler));\n                }\n                // Workaround for Google bug that causes the cursor to change to a pointer\n                // when the mouse moves over a marker underneath InfoBox.\n                this.eventListeners.push(google.maps.event.addListener(this.div, 'mouseover', function () {\n                    if (_this.div) {\n                        _this.div.style.cursor = 'default';\n                    }\n                }));\n            }\n            this.contextListener = google.maps.event.addListener(this.div, 'contextmenu', ignoreHandler);\n            /**\n             * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.\n             * @name InfoBox#domready\n             * @event\n             */\n            google.maps.event.trigger(this, 'domready');\n        }\n    };\n    InfoBox.prototype.getCloseBoxImg = function () {\n        var img = '';\n        if (this.closeBoxURL !== '') {\n            img = '<img alt=\"\"';\n            img += ' aria-hidden=\"true\"';\n            img += \" src='\" + this.closeBoxURL + \"'\";\n            img += ' align=right'; // Do this because Opera chokes on style='float: right;'\n            img += \" style='\";\n            img += ' position: relative;'; // Required by MSIE\n            img += ' cursor: pointer;';\n            img += ' margin: ' + this.closeBoxMargin + ';';\n            img += \"'>\";\n        }\n        return img;\n    };\n    InfoBox.prototype.addClickHandler = function () {\n        this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== ''\n            ? google.maps.event.addListener(this.div.firstChild, 'click', this.getCloseClickHandler())\n            : null;\n    };\n    InfoBox.prototype.closeClickHandler = function (event) {\n        // 1.0.3 fix: Always prevent propagation of a close box click to the map:\n        event.cancelBubble = true;\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n        /**\n         * This event is fired when the InfoBox's close box is clicked.\n         * @name InfoBox#closeclick\n         * @event\n         */\n        google.maps.event.trigger(this, 'closeclick');\n        this.close();\n    };\n    InfoBox.prototype.getCloseClickHandler = function () {\n        return this.closeClickHandler;\n    };\n    InfoBox.prototype.panBox = function (disablePan) {\n        if (this.div && !disablePan) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var map = this.getMap();\n            // Only pan if attached to map, not panorama\n            if (map instanceof google.maps.Map) {\n                var xOffset = 0;\n                var yOffset = 0;\n                var bounds = map.getBounds();\n                if (bounds && !bounds.contains(this.position)) {\n                    // Marker not in visible area of map, so set center\n                    // of map to the marker position first.\n                    map.setCenter(this.position);\n                }\n                var mapDiv = map.getDiv();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var mapWidth = mapDiv.offsetWidth;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var mapHeight = mapDiv.offsetHeight;\n                var iwOffsetX = this.pixelOffset.width;\n                var iwOffsetY = this.pixelOffset.height;\n                var iwWidth = this.div.offsetWidth;\n                var iwHeight = this.div.offsetHeight;\n                var padX = this.infoBoxClearance.width;\n                var padY = this.infoBoxClearance.height;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var projection = this.getProjection();\n                var pixPosition = projection.fromLatLngToContainerPixel(this.position);\n                if (pixPosition !== null) {\n                    if (pixPosition.x < -iwOffsetX + padX) {\n                        xOffset = pixPosition.x + iwOffsetX - padX;\n                    }\n                    else if (pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth) {\n                        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;\n                    }\n                    if (this.alignBottom) {\n                        if (pixPosition.y < -iwOffsetY + padY + iwHeight) {\n                            yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;\n                        }\n                        else if (pixPosition.y + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                    else {\n                        if (pixPosition.y < -iwOffsetY + padY) {\n                            yOffset = pixPosition.y + iwOffsetY - padY;\n                        }\n                        else if (pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                }\n                if (!(xOffset === 0 && yOffset === 0)) {\n                    // Move the map to the shifted center.\n                    map.panBy(xOffset, yOffset);\n                }\n            }\n        }\n    };\n    InfoBox.prototype.setBoxStyle = function () {\n        if (this.div) {\n            // Apply style values from the style sheet defined in the boxClass parameter:\n            this.div.className = this.boxClass;\n            // Clear existing inline style values:\n            this.div.style.cssText = '';\n            // Apply style values defined in the boxStyle parameter:\n            var boxStyle = this.boxStyle;\n            for (var i in boxStyle) {\n                if (Object.prototype.hasOwnProperty.call(boxStyle, i)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    this.div.style[i] = boxStyle[i];\n                }\n            }\n            // Fix for iOS disappearing InfoBox problem\n            // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad\n            this.div.style.webkitTransform = 'translateZ(0)';\n            // Fix up opacity style for benefit of MSIE\n            if (typeof this.div.style.opacity !== 'undefined' && this.div.style.opacity !== '') {\n                // See http://www.quirksmode.org/css/opacity.html\n                var opacity = parseFloat(this.div.style.opacity || '');\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.div.style.msFilter =\n                    '\"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + opacity * 100 + ')\"';\n                this.div.style.filter = 'alpha(opacity=' + opacity * 100 + ')';\n            }\n            // Apply required styles\n            this.div.style.position = 'absolute';\n            this.div.style.visibility = 'hidden';\n            if (this.zIndex !== null) {\n                this.div.style.zIndex = this.zIndex + '';\n            }\n            if (!this.div.style.overflow) {\n                this.div.style.overflow = 'auto';\n            }\n        }\n    };\n    InfoBox.prototype.getBoxWidths = function () {\n        var bw = { top: 0, bottom: 0, left: 0, right: 0 };\n        if (!this.div) {\n            return bw;\n        }\n        if (document.defaultView) {\n            var ownerDocument = this.div.ownerDocument;\n            var computedStyle = ownerDocument && ownerDocument.defaultView\n                ? ownerDocument.defaultView.getComputedStyle(this.div, '')\n                : null;\n            if (computedStyle) {\n                // The computed styles are always in pixel units (good!)\n                bw.top = parseInt(computedStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(computedStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(computedStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(computedStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        else if (\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        document.documentElement.currentStyle // MSIE\n        ) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var currentStyle = this.div.currentStyle;\n            if (currentStyle) {\n                // The current styles may not be in pixel units, but assume they are (bad!)\n                bw.top = parseInt(currentStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(currentStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(currentStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(currentStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        return bw;\n    };\n    InfoBox.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.div.parentNode.removeChild(this.div);\n            this.div = null;\n        }\n    };\n    InfoBox.prototype.draw = function () {\n        this.createInfoBoxDiv();\n        if (this.div) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var projection = this.getProjection();\n            var pixPosition = projection.fromLatLngToDivPixel(this.position);\n            if (pixPosition !== null) {\n                this.div.style.left = pixPosition.x + this.pixelOffset.width + 'px';\n                if (this.alignBottom) {\n                    this.div.style.bottom = -(pixPosition.y + this.pixelOffset.height) + 'px';\n                }\n                else {\n                    this.div.style.top = pixPosition.y + this.pixelOffset.height + 'px';\n                }\n            }\n            if (this.isHidden) {\n                this.div.style.visibility = 'hidden';\n            }\n            else {\n                this.div.style.visibility = 'visible';\n            }\n        }\n    };\n    InfoBox.prototype.setOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        if (typeof options.boxClass !== 'undefined') {\n            // Must be first\n            this.boxClass = options.boxClass;\n            this.setBoxStyle();\n        }\n        if (typeof options.boxStyle !== 'undefined') {\n            // Must be second\n            this.boxStyle = options.boxStyle;\n            this.setBoxStyle();\n        }\n        if (typeof options.content !== 'undefined') {\n            this.setContent(options.content);\n        }\n        if (typeof options.disableAutoPan !== 'undefined') {\n            this.disableAutoPan = options.disableAutoPan;\n        }\n        if (typeof options.maxWidth !== 'undefined') {\n            this.maxWidth = options.maxWidth;\n        }\n        if (typeof options.pixelOffset !== 'undefined') {\n            this.pixelOffset = options.pixelOffset;\n        }\n        if (typeof options.alignBottom !== 'undefined') {\n            this.alignBottom = options.alignBottom;\n        }\n        if (typeof options.position !== 'undefined') {\n            this.setPosition(options.position);\n        }\n        if (typeof options.zIndex !== 'undefined') {\n            this.setZIndex(options.zIndex);\n        }\n        if (typeof options.closeBoxMargin !== 'undefined') {\n            this.closeBoxMargin = options.closeBoxMargin;\n        }\n        if (typeof options.closeBoxURL !== 'undefined') {\n            this.closeBoxURL = options.closeBoxURL;\n        }\n        if (typeof options.infoBoxClearance !== 'undefined') {\n            this.infoBoxClearance = options.infoBoxClearance;\n        }\n        if (typeof options.isHidden !== 'undefined') {\n            this.isHidden = options.isHidden;\n        }\n        if (typeof options.visible !== 'undefined') {\n            this.isHidden = !options.visible;\n        }\n        if (typeof options.enableEventPropagation !== 'undefined') {\n            this.enableEventPropagation = options.enableEventPropagation;\n        }\n        if (this.div) {\n            this.draw();\n        }\n    };\n    InfoBox.prototype.setContent = function (content) {\n        this.content = content;\n        if (this.div) {\n            if (this.closeListener) {\n                google.maps.event.removeListener(this.closeListener);\n                this.closeListener = null;\n            }\n            // Odd code required to make things work with MSIE.\n            if (!this.fixedWidthSet) {\n                this.div.style.width = '';\n            }\n            if (typeof content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(content);\n            }\n            // Perverse code required to make things work with MSIE.\n            // (Ensures the close box does, in fact, float to the right.)\n            if (!this.fixedWidthSet) {\n                this.div.style.width = this.div.offsetWidth + 'px';\n                if (typeof content === 'string') {\n                    this.div.innerHTML = this.getCloseBoxImg() + content;\n                }\n                else {\n                    this.div.innerHTML = this.getCloseBoxImg();\n                    this.div.appendChild(content);\n                }\n            }\n            this.addClickHandler();\n        }\n        /**\n         * This event is fired when the content of the InfoBox changes.\n         * @name InfoBox#content_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'content_changed');\n    };\n    InfoBox.prototype.setPosition = function (latLng) {\n        this.position = latLng;\n        if (this.div) {\n            this.draw();\n        }\n        /**\n         * This event is fired when the position of the InfoBox changes.\n         * @name InfoBox#position_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'position_changed');\n    };\n    InfoBox.prototype.setVisible = function (isVisible) {\n        this.isHidden = !isVisible;\n        if (this.div) {\n            this.div.style.visibility = this.isHidden ? 'hidden' : 'visible';\n        }\n    };\n    InfoBox.prototype.setZIndex = function (index) {\n        this.zIndex = index;\n        if (this.div) {\n            this.div.style.zIndex = index + '';\n        }\n        /**\n         * This event is fired when the zIndex of the InfoBox changes.\n         * @name InfoBox#zindex_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'zindex_changed');\n    };\n    InfoBox.prototype.getContent = function () {\n        return this.content;\n    };\n    InfoBox.prototype.getPosition = function () {\n        return this.position;\n    };\n    InfoBox.prototype.getZIndex = function () {\n        return this.zIndex;\n    };\n    InfoBox.prototype.getVisible = function () {\n        var map = this.getMap();\n        return typeof map === 'undefined' || map === null ? false : !this.isHidden;\n    };\n    InfoBox.prototype.show = function () {\n        this.isHidden = false;\n        if (this.div) {\n            this.div.style.visibility = 'visible';\n        }\n    };\n    InfoBox.prototype.hide = function () {\n        this.isHidden = true;\n        if (this.div) {\n            this.div.style.visibility = 'hidden';\n        }\n    };\n    InfoBox.prototype.open = function (map, anchor) {\n        var _this = this;\n        if (anchor) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.position = anchor.getPosition();\n            this.moveListener = google.maps.event.addListener(anchor, 'position_changed', function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var position = anchor.getPosition();\n                _this.setPosition(position);\n            });\n            this.mapListener = google.maps.event.addListener(anchor, 'map_changed', function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                _this.setMap(anchor.map);\n            });\n        }\n        this.setMap(map);\n        if (this.div) {\n            this.panBox();\n        }\n    };\n    InfoBox.prototype.close = function () {\n        if (this.closeListener) {\n            google.maps.event.removeListener(this.closeListener);\n            this.closeListener = null;\n        }\n        if (this.eventListeners) {\n            for (var _i = 0, _a = this.eventListeners; _i < _a.length; _i++) {\n                var eventListener = _a[_i];\n                google.maps.event.removeListener(eventListener);\n            }\n            this.eventListeners = null;\n        }\n        if (this.moveListener) {\n            google.maps.event.removeListener(this.moveListener);\n            this.moveListener = null;\n        }\n        if (this.mapListener) {\n            google.maps.event.removeListener(this.mapListener);\n            this.mapListener = null;\n        }\n        if (this.contextListener) {\n            google.maps.event.removeListener(this.contextListener);\n            this.contextListener = null;\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.setMap(null);\n    };\n    InfoBox.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            for (var property in object.prototype) {\n                if (!Object.prototype.hasOwnProperty.call(this, property)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    this.prototype[property] = object.prototype[property];\n                }\n            }\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return InfoBox;\n}());\n\nvar eventMap$d = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$d = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        if (position instanceof google.maps.LatLng) {\n            instance.setPosition(position);\n        }\n        else {\n            instance.setPosition(new google.maps.LatLng(position.lat, position.lng));\n        }\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar defaultOptions$3 = {};\nfunction InfoBoxFunctional(_a) {\n    var children = _a.children, anchor = _a.anchor, options = _a.options, position = _a.position, zIndex = _a.zIndex, onCloseClick = _a.onCloseClick, onDomReady = _a.onDomReady, onContentChanged = _a.onContentChanged, onPositionChanged = _a.onPositionChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), closeClickListener = _c[0], setCloseClickListener = _c[1];\n    var _d = react.useState(null), domReadyClickListener = _d[0], setDomReadyClickListener = _d[1];\n    var _e = react.useState(null), contentChangedClickListener = _e[0], setContentChangedClickListener = _e[1];\n    var _f = react.useState(null), positionChangedClickListener = _f[0], setPositionChangedClickListener = _f[1];\n    var _g = react.useState(null), zIndexChangedClickListener = _g[0], setZindexChangedClickListener = _g[1];\n    var containerElementRef = react.useRef(null);\n    // Order does matter\n    react.useEffect(function () {\n        if (map && instance !== null) {\n            instance.close();\n            if (anchor) {\n                instance.open(map, anchor);\n            }\n            else if (instance.getPosition()) {\n                instance.open(map);\n            }\n        }\n    }, [map, instance, anchor]);\n    react.useEffect(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (position && instance !== null) {\n            var positionLatLng = position instanceof google.maps.LatLng\n                ? position\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                : new google.maps.LatLng(position.lat, position.lng);\n            instance.setPosition(positionLatLng);\n        }\n    }, [position]);\n    react.useEffect(function () {\n        if (typeof zIndex === 'number' && instance !== null) {\n            instance.setZIndex(zIndex);\n        }\n    }, [zIndex]);\n    react.useEffect(function () {\n        if (instance && onCloseClick) {\n            if (closeClickListener !== null) {\n                google.maps.event.removeListener(closeClickListener);\n            }\n            setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n        }\n    }, [onCloseClick]);\n    react.useEffect(function () {\n        if (instance && onDomReady) {\n            if (domReadyClickListener !== null) {\n                google.maps.event.removeListener(domReadyClickListener);\n            }\n            setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n        }\n    }, [onDomReady]);\n    react.useEffect(function () {\n        if (instance && onContentChanged) {\n            if (contentChangedClickListener !== null) {\n                google.maps.event.removeListener(contentChangedClickListener);\n            }\n            setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n        }\n    }, [onContentChanged]);\n    react.useEffect(function () {\n        if (instance && onPositionChanged) {\n            if (positionChangedClickListener !== null) {\n                google.maps.event.removeListener(positionChangedClickListener);\n            }\n            setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    react.useEffect(function () {\n        if (instance && onZindexChanged) {\n            if (zIndexChangedClickListener !== null) {\n                google.maps.event.removeListener(zIndexChangedClickListener);\n            }\n            setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    react.useEffect(function () {\n        if (map) {\n            var _a = options || defaultOptions$3, position_1 = _a.position, infoBoxOptions = __rest$1(_a, [\"position\"]);\n            var positionLatLng = void 0;\n            if (position_1 && !(position_1 instanceof google.maps.LatLng)) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                positionLatLng = new google.maps.LatLng(position_1.lat, position_1.lng);\n            }\n            var infoBox = new InfoBox(__assign(__assign({}, infoBoxOptions), (positionLatLng ? { position: positionLatLng } : {})));\n            containerElementRef.current = document.createElement('div');\n            setInstance(infoBox);\n            if (onCloseClick) {\n                setCloseClickListener(google.maps.event.addListener(infoBox, 'closeclick', onCloseClick));\n            }\n            if (onDomReady) {\n                setDomReadyClickListener(google.maps.event.addListener(infoBox, 'domready', onDomReady));\n            }\n            if (onContentChanged) {\n                setContentChangedClickListener(google.maps.event.addListener(infoBox, 'content_changed', onContentChanged));\n            }\n            if (onPositionChanged) {\n                setPositionChangedClickListener(google.maps.event.addListener(infoBox, 'position_changed', onPositionChanged));\n            }\n            if (onZindexChanged) {\n                setZindexChangedClickListener(google.maps.event.addListener(infoBox, 'zindex_changed', onZindexChanged));\n            }\n            infoBox.setContent(containerElementRef.current);\n            if (anchor) {\n                infoBox.open(map, anchor);\n            }\n            else if (infoBox.getPosition()) {\n                infoBox.open(map);\n            }\n            else {\n                invariant$1(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n            }\n            if (onLoad) {\n                onLoad(infoBox);\n            }\n        }\n        return function () {\n            if (instance !== null) {\n                if (closeClickListener) {\n                    google.maps.event.removeListener(closeClickListener);\n                }\n                if (contentChangedClickListener) {\n                    google.maps.event.removeListener(contentChangedClickListener);\n                }\n                if (domReadyClickListener) {\n                    google.maps.event.removeListener(domReadyClickListener);\n                }\n                if (positionChangedClickListener) {\n                    google.maps.event.removeListener(positionChangedClickListener);\n                }\n                if (zIndexChangedClickListener) {\n                    google.maps.event.removeListener(zIndexChangedClickListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.close();\n            }\n        };\n    }, []);\n    return containerElementRef.current ? ReactDOM.createPortal(react.Children.only(children), containerElementRef.current) : null;\n}\nvar InfoBoxF = react.memo(InfoBoxFunctional);\nvar InfoBoxComponent = /** @class */ (function (_super) {\n    __extends(InfoBoxComponent, _super);\n    function InfoBoxComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = null;\n        _this.state = {\n            infoBox: null,\n        };\n        _this.open = function (infoBox, anchor) {\n            if (anchor) {\n                if (_this.context !== null) {\n                    infoBox.open(_this.context, anchor);\n                }\n            }\n            else if (infoBox.getPosition()) {\n                if (_this.context !== null) {\n                    infoBox.open(_this.context);\n                }\n            }\n            else {\n                invariant$1(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n            }\n        };\n        _this.setInfoBoxCallback = function () {\n            if (_this.state.infoBox !== null && _this.containerElement !== null) {\n                _this.state.infoBox.setContent(_this.containerElement);\n                _this.open(_this.state.infoBox, _this.props.anchor);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.infoBox);\n                }\n            }\n        };\n        return _this;\n    }\n    InfoBoxComponent.prototype.componentDidMount = function () {\n        var _a = this.props.options || {}, position = _a.position, infoBoxOptions = __rest$1(_a, [\"position\"]);\n        var positionLatLng;\n        if (position && !(position instanceof google.maps.LatLng)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            positionLatLng = new google.maps.LatLng(position.lat, position.lng);\n        }\n        var infoBox = new InfoBox(__assign(__assign({}, infoBoxOptions), (positionLatLng ? { position: positionLatLng } : {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$d,\n            eventMap: eventMap$d,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoBox,\n        });\n        this.setState({ infoBox: infoBox }, this.setInfoBoxCallback);\n    };\n    InfoBoxComponent.prototype.componentDidUpdate = function (prevProps) {\n        var infoBox = this.state.infoBox;\n        if (infoBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$d,\n                eventMap: eventMap$d,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: infoBox,\n            });\n        }\n    };\n    InfoBoxComponent.prototype.componentWillUnmount = function () {\n        var onUnmount = this.props.onUnmount;\n        var infoBox = this.state.infoBox;\n        if (infoBox !== null) {\n            if (onUnmount) {\n                onUnmount(infoBox);\n            }\n            unregisterEvents(this.registeredEvents);\n            infoBox.close();\n        }\n    };\n    InfoBoxComponent.prototype.render = function () {\n        return this.containerElement ? ReactDOM.createPortal(react.Children.only(this.props.children), this.containerElement) : null;\n    };\n    InfoBoxComponent.contextType = MapContext;\n    return InfoBoxComponent;\n}(react.PureComponent));\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nvar equal = /*@__PURE__*/getDefaultExportFromCjs(fastDeepEqual);\n\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nclass KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nconst defaultOptions$2 = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nclass Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions$2), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n/**\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MarkerUtils {\n    static isAdvancedMarkerAvailable(map) {\n        return (google.maps.marker &&\n            map.getMapCapabilities().isAdvancedMarkersAvailable === true);\n    }\n    static isAdvancedMarker(marker) {\n        return (google.maps.marker &&\n            marker instanceof google.maps.marker.AdvancedMarkerElement);\n    }\n    static setMap(marker, map) {\n        if (this.isAdvancedMarker(marker)) {\n            marker.map = map;\n        }\n        else {\n            marker.setMap(map);\n        }\n    }\n    static getPosition(marker) {\n        // SuperClusterAlgorithm.calculate expects a LatLng instance so we fake it for Adv Markers\n        if (this.isAdvancedMarker(marker)) {\n            if (marker.position) {\n                if (marker.position instanceof google.maps.LatLng) {\n                    return marker.position;\n                }\n                // since we can't cast to LatLngLiteral for reasons =(\n                if (marker.position.lat && marker.position.lng) {\n                    return new google.maps.LatLng(marker.position.lat, marker.position.lng);\n                }\n            }\n            return new google.maps.LatLng(null);\n        }\n        return marker.getPosition();\n    }\n    static getVisible(marker) {\n        if (this.isAdvancedMarker(marker)) {\n            /**\n             * Always return true for Advanced Markers because the clusterer\n             * uses getVisible as a way to count legacy markers not as an actual\n             * indicator of visibility for some reason. Even when markers are hidden\n             * Marker.getVisible returns `true` and this is used to set the marker count\n             * on the cluster. See the behavior of Cluster.count\n             */\n            return true;\n        }\n        return marker.getVisible();\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Cluster {\n    constructor({ markers, position }) {\n        this.markers = markers;\n        if (position) {\n            if (position instanceof google.maps.LatLng) {\n                this._position = position;\n            }\n            else {\n                this._position = new google.maps.LatLng(position);\n            }\n        }\n    }\n    get bounds() {\n        if (this.markers.length === 0 && !this._position) {\n            return;\n        }\n        const bounds = new google.maps.LatLngBounds(this._position, this._position);\n        for (const marker of this.markers) {\n            bounds.extend(MarkerUtils.getPosition(marker));\n        }\n        return bounds;\n    }\n    get position() {\n        return this._position || this.bounds.getCenter();\n    }\n    /**\n     * Get the count of **visible** markers.\n     */\n    get count() {\n        return this.markers.filter((m) => MarkerUtils.getVisible(m)).length;\n    }\n    /**\n     * Add a marker to the cluster.\n     */\n    push(marker) {\n        this.markers.push(marker);\n    }\n    /**\n     * Cleanup references and remove marker from map.\n     */\n    delete() {\n        if (this.marker) {\n            MarkerUtils.setMap(this.marker, null);\n            this.marker = undefined;\n        }\n        this.markers.length = 0;\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the markers visible in a padded map viewport\n *\n * @param map\n * @param mapCanvasProjection\n * @param markers The list of marker to filter\n * @param viewportPaddingPixels The padding in pixel\n * @returns The list of markers in the padded viewport\n */\nconst filterMarkersToPaddedViewport = (map, mapCanvasProjection, markers, viewportPaddingPixels) => {\n    const extendedMapBounds = extendBoundsToPaddedViewport(map.getBounds(), mapCanvasProjection, viewportPaddingPixels);\n    return markers.filter((marker) => extendedMapBounds.contains(MarkerUtils.getPosition(marker)));\n};\n/**\n * Extends a bounds by a number of pixels in each direction\n */\nconst extendBoundsToPaddedViewport = (bounds, projection, numPixels) => {\n    const { northEast, southWest } = latLngBoundsToPixelBounds(bounds, projection);\n    const extendedPixelBounds = extendPixelBounds({ northEast, southWest }, numPixels);\n    return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n/**\n * Returns the distance between 2 positions.\n *\n * @hidden\n */\nconst distanceBetweenPoints = (p1, p2) => {\n    const R = 6371; // Radius of the Earth in km\n    const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n    const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n    const sinDLat = Math.sin(dLat / 2);\n    const sinDLon = Math.sin(dLon / 2);\n    const a = sinDLat * sinDLat +\n        Math.cos((p1.lat * Math.PI) / 180) *\n            Math.cos((p2.lat * Math.PI) / 180) *\n            sinDLon *\n            sinDLon;\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n};\n/**\n * Converts a LatLng bound to pixels.\n *\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (bounds, projection) => {\n    return {\n        northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n        southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n    };\n};\n/**\n * Extends a pixel bounds by numPixels in all directions.\n *\n * @hidden\n */\nconst extendPixelBounds = ({ northEast, southWest }, numPixels) => {\n    northEast.x += numPixels;\n    northEast.y -= numPixels;\n    southWest.x -= numPixels;\n    southWest.y += numPixels;\n    return { northEast, southWest };\n};\n/**\n * @hidden\n */\nconst pixelBoundsToLatLngBounds = ({ northEast, southWest }, projection) => {\n    const sw = projection.fromDivPixelToLatLng(southWest);\n    const ne = projection.fromDivPixelToLatLng(northEast);\n    return new google.maps.LatLngBounds(sw, ne);\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @hidden\n */\nclass AbstractAlgorithm {\n    constructor({ maxZoom = 16 }) {\n        this.maxZoom = maxZoom;\n    }\n    /**\n     * Helper function to bypass clustering based upon some map state such as\n     * zoom, number of markers, etc.\n     *\n     * ```typescript\n     *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n     *    if (shouldBypassClustering(map)) {\n     *      return this.noop({markers})\n     *    }\n     * }\n     * ```\n     */\n    noop({ markers, }) {\n        return noop$1(markers);\n    }\n}\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nclass AbstractViewportAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var { viewportPadding = 60 } = _a, options = __rest(_a, [\"viewportPadding\"]);\n        super(options);\n        this.viewportPadding = 60;\n        this.viewportPadding = viewportPadding;\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        if (map.getZoom() >= this.maxZoom) {\n            return {\n                clusters: this.noop({\n                    markers,\n                }),\n                changed: false,\n            };\n        }\n        return {\n            clusters: this.cluster({\n                markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n                map,\n                mapCanvasProjection,\n            }),\n        };\n    }\n}\n/**\n * @hidden\n */\nconst noop$1 = (markers) => {\n    const clusters = markers.map((marker) => new Cluster({\n        position: MarkerUtils.getPosition(marker),\n        markers: [marker],\n    }));\n    return clusters;\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default Grid algorithm historically used in Google Maps marker\n * clustering.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n */\nclass GridAlgorithm extends AbstractViewportAlgorithm {\n    constructor(_a) {\n        var { maxDistance = 40000, gridSize = 40 } = _a, options = __rest(_a, [\"maxDistance\", \"gridSize\"]);\n        super(options);\n        this.clusters = [];\n        this.state = { zoom: -1 };\n        this.maxDistance = maxDistance;\n        this.gridSize = gridSize;\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        const state = { zoom: map.getZoom() };\n        let changed = false;\n        if (this.state.zoom >= this.maxZoom && state.zoom >= this.maxZoom) ;\n        else {\n            changed = !equal(this.state, state);\n        }\n        this.state = state;\n        if (map.getZoom() >= this.maxZoom) {\n            return {\n                clusters: this.noop({\n                    markers,\n                }),\n                changed,\n            };\n        }\n        return {\n            clusters: this.cluster({\n                markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n                map,\n                mapCanvasProjection,\n            }),\n        };\n    }\n    cluster({ markers, map, mapCanvasProjection, }) {\n        this.clusters = [];\n        markers.forEach((marker) => {\n            this.addToClosestCluster(marker, map, mapCanvasProjection);\n        });\n        return this.clusters;\n    }\n    addToClosestCluster(marker, map, projection) {\n        let maxDistance = this.maxDistance; // Some large number\n        let cluster = null;\n        for (let i = 0; i < this.clusters.length; i++) {\n            const candidate = this.clusters[i];\n            const distance = distanceBetweenPoints(candidate.bounds.getCenter().toJSON(), MarkerUtils.getPosition(marker).toJSON());\n            if (distance < maxDistance) {\n                maxDistance = distance;\n                cluster = candidate;\n            }\n        }\n        if (cluster &&\n            extendBoundsToPaddedViewport(cluster.bounds, projection, this.gridSize).contains(MarkerUtils.getPosition(marker))) {\n            cluster.push(marker);\n        }\n        else {\n            const cluster = new Cluster({ markers: [marker] });\n            this.clusters.push(cluster);\n        }\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nclass NoopAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var options = __rest(_a, []);\n        super(options);\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        return {\n            clusters: this.cluster({ markers, map, mapCanvasProjection }),\n            changed: false,\n        };\n    }\n    cluster(input) {\n        return this.noop(input);\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nclass SuperClusterAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var { maxZoom, radius = 60 } = _a, options = __rest(_a, [\"maxZoom\", \"radius\"]);\n        super({ maxZoom });\n        this.state = { zoom: -1 };\n        this.superCluster = new Supercluster(Object.assign({ maxZoom: this.maxZoom, radius }, options));\n    }\n    calculate(input) {\n        let changed = false;\n        const state = { zoom: input.map.getZoom() };\n        if (!equal(input.markers, this.markers)) {\n            changed = true;\n            // TODO use proxy to avoid copy?\n            this.markers = [...input.markers];\n            const points = this.markers.map((marker) => {\n                const position = MarkerUtils.getPosition(marker);\n                const coordinates = [position.lng(), position.lat()];\n                return {\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"Point\",\n                        coordinates,\n                    },\n                    properties: { marker },\n                };\n            });\n            this.superCluster.load(points);\n        }\n        if (!changed) {\n            if (this.state.zoom <= this.maxZoom || state.zoom <= this.maxZoom) {\n                changed = !equal(this.state, state);\n            }\n        }\n        this.state = state;\n        if (changed) {\n            this.clusters = this.cluster(input);\n        }\n        return { clusters: this.clusters, changed };\n    }\n    cluster({ map }) {\n        return this.superCluster\n            .getClusters([-180, -90, 180, 90], Math.round(map.getZoom()))\n            .map((feature) => this.transformCluster(feature));\n    }\n    transformCluster({ geometry: { coordinates: [lng, lat], }, properties, }) {\n        if (properties.cluster) {\n            return new Cluster({\n                markers: this.superCluster\n                    .getLeaves(properties.cluster_id, Infinity)\n                    .map((leaf) => leaf.properties.marker),\n                position: { lat, lng },\n            });\n        }\n        const marker = properties.marker;\n        return new Cluster({\n            markers: [marker],\n            position: MarkerUtils.getPosition(marker),\n        });\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nclass ClusterStats {\n    constructor(markers, clusters) {\n        this.markers = { sum: markers.length };\n        const clusterMarkerCounts = clusters.map((a) => a.count);\n        const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n        this.clusters = {\n            count: clusters.length,\n            markers: {\n                mean: clusterMarkerSum / clusters.length,\n                sum: clusterMarkerSum,\n                min: Math.min(...clusterMarkerCounts),\n                max: Math.max(...clusterMarkerCounts),\n            },\n        };\n    }\n}\nclass DefaultRenderer {\n    /**\n     * The default render function for the library used by {@link MarkerClusterer}.\n     *\n     * Currently set to use the following:\n     *\n     * ```typescript\n     * // change color if this cluster has more markers than the mean cluster\n     * const color =\n     *   count > Math.max(10, stats.clusters.markers.mean)\n     *     ? \"#ff0000\"\n     *     : \"#0000ff\";\n     *\n     * // create svg url with fill color\n     * const svg = window.btoa(`\n     * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n     * </svg>`);\n     *\n     * // create marker using svg icon\n     * return new google.maps.Marker({\n     *   position,\n     *   icon: {\n     *     url: `data:image/svg+xml;base64,${svg}`,\n     *     scaledSize: new google.maps.Size(45, 45),\n     *   },\n     *   label: {\n     *     text: String(count),\n     *     color: \"rgba(255,255,255,0.9)\",\n     *     fontSize: \"12px\",\n     *   },\n     *   // adjust zIndex to be above other markers\n     *   zIndex: 1000 + count,\n     * });\n     * ```\n     */\n    render({ count, position }, stats, map) {\n        // change color if this cluster has more markers than the mean cluster\n        const color = count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n        // create svg literal with fill color\n        const svg = `<svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\" width=\"50\" height=\"50\">\n<circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n<circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n<circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n<text x=\"50%\" y=\"50%\" style=\"fill:#fff\" text-anchor=\"middle\" font-size=\"50\" dominant-baseline=\"middle\" font-family=\"roboto,arial,sans-serif\">${count}</text>\n</svg>`;\n        const title = `Cluster of ${count} markers`, \n        // adjust zIndex to be above other markers\n        zIndex = Number(google.maps.Marker.MAX_ZINDEX) + count;\n        if (MarkerUtils.isAdvancedMarkerAvailable(map)) {\n            // create cluster SVG element\n            const div = document.createElement(\"div\");\n            div.innerHTML = svg;\n            const svgEl = div.firstElementChild;\n            svgEl.setAttribute(\"transform\", \"translate(0 25)\");\n            const clusterOptions = {\n                map,\n                position,\n                zIndex,\n                title,\n                content: svgEl,\n            };\n            return new google.maps.marker.AdvancedMarkerElement(clusterOptions);\n        }\n        const clusterOptions = {\n            position,\n            zIndex,\n            title,\n            icon: {\n                url: `data:image/svg+xml;base64,${btoa(svg)}`,\n                anchor: new google.maps.Point(25, 25),\n            },\n        };\n        return new google.maps.Marker(clusterOptions);\n    }\n}\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1, type2) {\n    /* istanbul ignore next */\n    // eslint-disable-next-line prefer-const\n    for (let property in type2.prototype) {\n        type1.prototype[property] = type2.prototype[property];\n    }\n}\n/**\n * @ignore\n */\nclass OverlayViewSafe {\n    constructor() {\n        // MarkerClusterer implements google.maps.OverlayView interface. We use the\n        // extend function to extend MarkerClusterer with google.maps.OverlayView\n        // because it might not always be available when the code is defined so we\n        // look for it at the last possible moment. If it doesn't exist now then\n        // there is no point going ahead :)\n        extend(OverlayViewSafe, google.maps.OverlayView);\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MarkerClustererEvents;\n(function (MarkerClustererEvents) {\n    MarkerClustererEvents[\"CLUSTERING_BEGIN\"] = \"clusteringbegin\";\n    MarkerClustererEvents[\"CLUSTERING_END\"] = \"clusteringend\";\n    MarkerClustererEvents[\"CLUSTER_CLICK\"] = \"click\";\n})(MarkerClustererEvents || (MarkerClustererEvents = {}));\nconst defaultOnClusterClickHandler = (_, cluster, map) => {\n    map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n */\nclass MarkerClusterer extends OverlayViewSafe {\n    constructor({ map, markers = [], algorithmOptions = {}, algorithm = new SuperClusterAlgorithm(algorithmOptions), renderer = new DefaultRenderer(), onClusterClick = defaultOnClusterClickHandler, }) {\n        super();\n        this.markers = [...markers];\n        this.clusters = [];\n        this.algorithm = algorithm;\n        this.renderer = renderer;\n        this.onClusterClick = onClusterClick;\n        if (map) {\n            this.setMap(map);\n        }\n    }\n    addMarker(marker, noDraw) {\n        if (this.markers.includes(marker)) {\n            return;\n        }\n        this.markers.push(marker);\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    addMarkers(markers, noDraw) {\n        markers.forEach((marker) => {\n            this.addMarker(marker, true);\n        });\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    removeMarker(marker, noDraw) {\n        const index = this.markers.indexOf(marker);\n        if (index === -1) {\n            // Marker is not in our list of markers, so do nothing:\n            return false;\n        }\n        MarkerUtils.setMap(marker, null);\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n        if (!noDraw) {\n            this.render();\n        }\n        return true;\n    }\n    removeMarkers(markers, noDraw) {\n        let removed = false;\n        markers.forEach((marker) => {\n            removed = this.removeMarker(marker, true) || removed;\n        });\n        if (removed && !noDraw) {\n            this.render();\n        }\n        return removed;\n    }\n    clearMarkers(noDraw) {\n        this.markers.length = 0;\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    /**\n     * Recalculates and draws all the marker clusters.\n     */\n    render() {\n        const map = this.getMap();\n        if (map instanceof google.maps.Map && map.getProjection()) {\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);\n            const { clusters, changed } = this.algorithm.calculate({\n                markers: this.markers,\n                map,\n                mapCanvasProjection: this.getProjection(),\n            });\n            // Allow algorithms to return flag on whether the clusters/markers have changed.\n            if (changed || changed == undefined) {\n                // Accumulate the markers of the clusters composed of a single marker.\n                // Those clusters directly use the marker.\n                // Clusters with more than one markers use a group marker generated by a renderer.\n                const singleMarker = new Set();\n                for (const cluster of clusters) {\n                    if (cluster.markers.length == 1) {\n                        singleMarker.add(cluster.markers[0]);\n                    }\n                }\n                const groupMarkers = [];\n                // Iterate the clusters that are currently rendered.\n                for (const cluster of this.clusters) {\n                    if (cluster.marker == null) {\n                        continue;\n                    }\n                    if (cluster.markers.length == 1) {\n                        if (!singleMarker.has(cluster.marker)) {\n                            // The marker:\n                            // - was previously rendered because it is from a cluster with 1 marker,\n                            // - should no more be rendered as it is not in singleMarker.\n                            MarkerUtils.setMap(cluster.marker, null);\n                        }\n                    }\n                    else {\n                        // Delay the removal of old group markers to avoid flickering.\n                        groupMarkers.push(cluster.marker);\n                    }\n                }\n                this.clusters = clusters;\n                this.renderClusters();\n                // Delayed removal of the markers of the former groups.\n                requestAnimationFrame(() => groupMarkers.forEach((marker) => MarkerUtils.setMap(marker, null)));\n            }\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);\n        }\n    }\n    onAdd() {\n        this.idleListener = this.getMap().addListener(\"idle\", this.render.bind(this));\n        this.render();\n    }\n    onRemove() {\n        google.maps.event.removeListener(this.idleListener);\n        this.reset();\n    }\n    reset() {\n        this.markers.forEach((marker) => MarkerUtils.setMap(marker, null));\n        this.clusters.forEach((cluster) => cluster.delete());\n        this.clusters = [];\n    }\n    renderClusters() {\n        // Generate stats to pass to renderers.\n        const stats = new ClusterStats(this.markers, this.clusters);\n        const map = this.getMap();\n        this.clusters.forEach((cluster) => {\n            if (cluster.markers.length === 1) {\n                cluster.marker = cluster.markers[0];\n            }\n            else {\n                // Generate the marker to represent the group.\n                cluster.marker = this.renderer.render(cluster, stats, map);\n                // Make sure all individual markers are removed from the map.\n                cluster.markers.forEach((marker) => MarkerUtils.setMap(marker, null));\n                if (this.onClusterClick) {\n                    cluster.marker.addListener(\"click\", \n                    /* istanbul ignore next */\n                    (event) => {\n                        google.maps.event.trigger(this, MarkerClustererEvents.CLUSTER_CLICK, cluster);\n                        this.onClusterClick(event, cluster, map);\n                    });\n                }\n            }\n            MarkerUtils.setMap(cluster.marker, map);\n        });\n    }\n}\n\nvar index_esm = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AbstractAlgorithm: AbstractAlgorithm,\n    AbstractViewportAlgorithm: AbstractViewportAlgorithm,\n    Cluster: Cluster,\n    ClusterStats: ClusterStats,\n    DefaultRenderer: DefaultRenderer,\n    GridAlgorithm: GridAlgorithm,\n    MarkerClusterer: MarkerClusterer,\n    get MarkerClustererEvents () { return MarkerClustererEvents; },\n    NoopAlgorithm: NoopAlgorithm,\n    SuperClusterAlgorithm: SuperClusterAlgorithm,\n    defaultOnClusterClickHandler: defaultOnClusterClickHandler,\n    distanceBetweenPoints: distanceBetweenPoints,\n    extendBoundsToPaddedViewport: extendBoundsToPaddedViewport,\n    extendPixelBounds: extendPixelBounds,\n    filterMarkersToPaddedViewport: filterMarkersToPaddedViewport,\n    noop: noop$1,\n    pixelBoundsToLatLngBounds: pixelBoundsToLatLngBounds\n});\n\nfunction useGoogleMarkerClusterer(options) {\n    var map = useGoogleMap();\n    var _a = react.useState(null), markerClusterer = _a[0], setMarkerClusterer = _a[1];\n    react.useEffect(function () {\n        if (map && markerClusterer === null) {\n            var markerCluster = new MarkerClusterer(__assign(__assign({}, options), { map: map }));\n            setMarkerClusterer(markerCluster);\n        }\n    }, [map]);\n    return markerClusterer;\n}\n/** Wrapper around [@googlemaps/markerclusterer](https://github.com/googlemaps/js-markerclusterer)\n *\n * Accepts {@link  MarkerClustererOptionsSubset} which is a subset of  {@link MarkerClustererOptions}\n */\nfunction GoogleMarkerClusterer(_a) {\n    var children = _a.children, options = _a.options;\n    var markerClusterer = useGoogleMarkerClusterer(options);\n    return markerClusterer !== null ? children(markerClusterer) : null;\n}\nvar GoogleMarkerClusterer$1 = react.memo(GoogleMarkerClusterer);\n\nvar eventMap$c = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$c = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nfunction InfoWindowFunctional(_a) {\n    var children = _a.children, anchor = _a.anchor, options = _a.options, position = _a.position, zIndex = _a.zIndex, onCloseClick = _a.onCloseClick, onDomReady = _a.onDomReady, onContentChanged = _a.onContentChanged, onPositionChanged = _a.onPositionChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), closeclickListener = _c[0], setCloseClickListener = _c[1];\n    var _d = react.useState(null), domreadyclickListener = _d[0], setDomReadyClickListener = _d[1];\n    var _e = react.useState(null), contentchangedclickListener = _e[0], setContentChangedClickListener = _e[1];\n    var _f = react.useState(null), positionchangedclickListener = _f[0], setPositionChangedClickListener = _f[1];\n    var _g = react.useState(null), zindexchangedclickListener = _g[0], setZindexChangedClickListener = _g[1];\n    var containerElementRef = react.useRef(null);\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.close();\n            if (anchor) {\n                instance.open(map, anchor);\n            }\n            else if (instance.getPosition()) {\n                instance.open(map);\n            }\n        }\n    }, [map, instance, anchor]);\n    react.useEffect(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (position && instance !== null) {\n            instance.setPosition(position);\n        }\n    }, [position]);\n    react.useEffect(function () {\n        if (typeof zIndex === 'number' && instance !== null) {\n            instance.setZIndex(zIndex);\n        }\n    }, [zIndex]);\n    react.useEffect(function () {\n        if (instance && onCloseClick) {\n            if (closeclickListener !== null) {\n                google.maps.event.removeListener(closeclickListener);\n            }\n            setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n        }\n    }, [onCloseClick]);\n    react.useEffect(function () {\n        if (instance && onDomReady) {\n            if (domreadyclickListener !== null) {\n                google.maps.event.removeListener(domreadyclickListener);\n            }\n            setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n        }\n    }, [onDomReady]);\n    react.useEffect(function () {\n        if (instance && onContentChanged) {\n            if (contentchangedclickListener !== null) {\n                google.maps.event.removeListener(contentchangedclickListener);\n            }\n            setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n        }\n    }, [onContentChanged]);\n    react.useEffect(function () {\n        if (instance && onPositionChanged) {\n            if (positionchangedclickListener !== null) {\n                google.maps.event.removeListener(positionchangedclickListener);\n            }\n            setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    react.useEffect(function () {\n        if (instance && onZindexChanged) {\n            if (zindexchangedclickListener !== null) {\n                google.maps.event.removeListener(zindexchangedclickListener);\n            }\n            setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    react.useEffect(function () {\n        var infoWindow = new google.maps.InfoWindow(__assign({}, (options || {})));\n        setInstance(infoWindow);\n        containerElementRef.current = document.createElement('div');\n        if (onCloseClick) {\n            setCloseClickListener(google.maps.event.addListener(infoWindow, 'closeclick', onCloseClick));\n        }\n        if (onDomReady) {\n            setDomReadyClickListener(google.maps.event.addListener(infoWindow, 'domready', onDomReady));\n        }\n        if (onContentChanged) {\n            setContentChangedClickListener(google.maps.event.addListener(infoWindow, 'content_changed', onContentChanged));\n        }\n        if (onPositionChanged) {\n            setPositionChangedClickListener(google.maps.event.addListener(infoWindow, 'position_changed', onPositionChanged));\n        }\n        if (onZindexChanged) {\n            setZindexChangedClickListener(google.maps.event.addListener(infoWindow, 'zindex_changed', onZindexChanged));\n        }\n        infoWindow.setContent(containerElementRef.current);\n        if (position) {\n            infoWindow.setPosition(position);\n        }\n        if (zIndex) {\n            infoWindow.setZIndex(zIndex);\n        }\n        if (anchor) {\n            infoWindow.open(map, anchor);\n        }\n        else if (infoWindow.getPosition()) {\n            infoWindow.open(map);\n        }\n        else {\n            invariant$1(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n        }\n        if (onLoad) {\n            onLoad(infoWindow);\n        }\n        return function () {\n            if (closeclickListener) {\n                google.maps.event.removeListener(closeclickListener);\n            }\n            if (contentchangedclickListener) {\n                google.maps.event.removeListener(contentchangedclickListener);\n            }\n            if (domreadyclickListener) {\n                google.maps.event.removeListener(domreadyclickListener);\n            }\n            if (positionchangedclickListener) {\n                google.maps.event.removeListener(positionchangedclickListener);\n            }\n            if (zindexchangedclickListener) {\n                google.maps.event.removeListener(zindexchangedclickListener);\n            }\n            if (onUnmount) {\n                onUnmount(infoWindow);\n            }\n            infoWindow.close();\n        };\n    }, []);\n    return containerElementRef.current ? (ReactDOM.createPortal(react.Children.only(children), containerElementRef.current)) : (null);\n}\nvar InfoWindowF = react.memo(InfoWindowFunctional);\nvar InfoWindow = /** @class */ (function (_super) {\n    __extends(InfoWindow, _super);\n    function InfoWindow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = null;\n        _this.state = {\n            infoWindow: null,\n        };\n        _this.open = function (infoWindow, anchor) {\n            if (anchor) {\n                infoWindow.open(_this.context, anchor);\n            }\n            else if (infoWindow.getPosition()) {\n                infoWindow.open(_this.context);\n            }\n            else {\n                invariant$1(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n            }\n        };\n        _this.setInfoWindowCallback = function () {\n            if (_this.state.infoWindow !== null && _this.containerElement !== null) {\n                _this.state.infoWindow.setContent(_this.containerElement);\n                _this.open(_this.state.infoWindow, _this.props.anchor);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.infoWindow);\n                }\n            }\n        };\n        return _this;\n    }\n    InfoWindow.prototype.componentDidMount = function () {\n        var infoWindow = new google.maps.InfoWindow(__assign({}, (this.props.options || {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$c,\n            eventMap: eventMap$c,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoWindow,\n        });\n        this.setState(function () {\n            return {\n                infoWindow: infoWindow,\n            };\n        }, this.setInfoWindowCallback);\n    };\n    InfoWindow.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$c,\n                eventMap: eventMap$c,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.infoWindow,\n            });\n        }\n    };\n    InfoWindow.prototype.componentWillUnmount = function () {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.infoWindow);\n            }\n            this.state.infoWindow.close();\n        }\n    };\n    InfoWindow.prototype.render = function () {\n        return this.containerElement ? (ReactDOM.createPortal(react.Children.only(this.props.children), this.containerElement)) : (null);\n    };\n    InfoWindow.contextType = MapContext;\n    return InfoWindow;\n}(react.PureComponent));\n\nvar eventMap$b = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$b = {\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    path: function (instance, path) {\n        instance.setPath(path);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nvar defaultOptions$1 = {};\nfunction PolylineFunctional(_a) {\n    var options = _a.options, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, path = _a.path, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = react.useState(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = react.useState(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = react.useState(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = react.useState(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = react.useState(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = react.useState(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = react.useState(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = react.useState(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = react.useState(null), dragListener = _o[0], setDragListener = _o[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    react.useEffect(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    react.useEffect(function () {\n        if (typeof path !== 'undefined' && instance !== null) {\n            instance.setPath(path);\n        }\n    }, [instance, path]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        var polyline = new google.maps.Polyline(__assign(__assign({}, (options || defaultOptions$1)), { map: map }));\n        if (path) {\n            polyline.setPath(path);\n        }\n        if (typeof visible !== 'undefined') {\n            polyline.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            polyline.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            polyline.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(polyline, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(polyline, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(polyline, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(polyline, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(polyline, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(polyline, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(polyline, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(polyline, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(polyline, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(polyline, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(polyline, 'drag', onDrag));\n        }\n        setInstance(polyline);\n        if (onLoad) {\n            onLoad(polyline);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (onUnmount) {\n                onUnmount(polyline);\n            }\n            polyline.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar PolylineF = react.memo(PolylineFunctional);\nvar Polyline = /** @class */ (function (_super) {\n    __extends(Polyline, _super);\n    function Polyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            polyline: null,\n        };\n        _this.setPolylineCallback = function () {\n            if (_this.state.polyline !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.polyline);\n            }\n        };\n        return _this;\n    }\n    Polyline.prototype.componentDidMount = function () {\n        var polyline = new google.maps.Polyline(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$b,\n            eventMap: eventMap$b,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polyline,\n        });\n        this.setState(function setPolyline() {\n            return {\n                polyline: polyline,\n            };\n        }, this.setPolylineCallback);\n    };\n    Polyline.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.polyline !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$b,\n                eventMap: eventMap$b,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.polyline,\n            });\n        }\n    };\n    Polyline.prototype.componentWillUnmount = function () {\n        if (this.state.polyline !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polyline);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polyline.setMap(null);\n        }\n    };\n    Polyline.prototype.render = function () {\n        return null;\n    };\n    Polyline.contextType = MapContext;\n    return Polyline;\n}(react.PureComponent));\n\nvar eventMap$a = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$a = {\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    path: function (instance, path) {\n        instance.setPath(path);\n    },\n    paths: function (instance, paths) {\n        instance.setPaths(paths);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nfunction PolygonFunctional(_a) {\n    var options = _a.options, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, path = _a.path, paths = _a.paths, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = react.useState(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = react.useState(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = react.useState(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = react.useState(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = react.useState(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = react.useState(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = react.useState(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = react.useState(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = react.useState(null), dragListener = _o[0], setDragListener = _o[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    react.useEffect(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    react.useEffect(function () {\n        if (typeof path !== 'undefined' && instance !== null) {\n            instance.setPath(path);\n        }\n    }, [instance, path]);\n    react.useEffect(function () {\n        if (typeof paths !== 'undefined' && instance !== null) {\n            instance.setPaths(paths);\n        }\n    }, [instance, paths]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        var polygon = new google.maps.Polygon(__assign(__assign({}, (options || {})), { map: map }));\n        if (path) {\n            polygon.setPath(path);\n        }\n        if (paths) {\n            polygon.setPaths(paths);\n        }\n        if (typeof visible !== 'undefined') {\n            polygon.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            polygon.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            polygon.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(polygon, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(polygon, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(polygon, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(polygon, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(polygon, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(polygon, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(polygon, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(polygon, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(polygon, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(polygon, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(polygon, 'drag', onDrag));\n        }\n        setInstance(polygon);\n        if (onLoad) {\n            onLoad(polygon);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (onUnmount) {\n                onUnmount(polygon);\n            }\n            polygon.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar PolygonF = react.memo(PolygonFunctional);\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    function Polygon() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            polygon: null,\n        };\n        _this.setPolygonCallback = function () {\n            if (_this.state.polygon !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.polygon);\n            }\n        };\n        return _this;\n    }\n    Polygon.prototype.componentDidMount = function () {\n        var polygon = new google.maps.Polygon(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$a,\n            eventMap: eventMap$a,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polygon,\n        });\n        this.setState(function setPolygon() {\n            return {\n                polygon: polygon,\n            };\n        }, this.setPolygonCallback);\n    };\n    Polygon.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.polygon !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$a,\n                eventMap: eventMap$a,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.polygon,\n            });\n        }\n    };\n    Polygon.prototype.componentWillUnmount = function () {\n        if (this.state.polygon !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polygon);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polygon && this.state.polygon.setMap(null);\n        }\n    };\n    Polygon.prototype.render = function () {\n        return null;\n    };\n    Polygon.contextType = MapContext;\n    return Polygon;\n}(react.PureComponent));\n\nvar eventMap$9 = {\n    onBoundsChanged: 'bounds_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$9 = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nfunction RectangleFunctional(_a) {\n    var options = _a.options, bounds = _a.bounds, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onBoundsChanged = _a.onBoundsChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = react.useState(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = react.useState(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = react.useState(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = react.useState(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = react.useState(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = react.useState(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = react.useState(null), rightClickListener = _l[0], setRightClickListener = _l[1];\n    var _m = react.useState(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = react.useState(null), dragListener = _o[0], setDragListener = _o[1];\n    var _p = react.useState(null), boundsChangedListener = _p[0], setBoundsChangedListener = _p[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    react.useEffect(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    react.useEffect(function () {\n        if (typeof bounds !== 'undefined' && instance !== null) {\n            instance.setBounds(bounds);\n        }\n    }, [instance, bounds]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightClickListener !== null) {\n                google.maps.event.removeListener(rightClickListener);\n            }\n            setRightClickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        if (instance && onBoundsChanged) {\n            if (boundsChangedListener !== null) {\n                google.maps.event.removeListener(boundsChangedListener);\n            }\n            setBoundsChangedListener(google.maps.event.addListener(instance, 'bounds_changed', onBoundsChanged));\n        }\n    }, [onBoundsChanged]);\n    react.useEffect(function () {\n        var rectangle = new google.maps.Rectangle(__assign(__assign({}, (options || {})), { map: map }));\n        if (typeof visible !== 'undefined') {\n            rectangle.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            rectangle.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            rectangle.setDraggable(draggable);\n        }\n        if (typeof bounds !== 'undefined') {\n            rectangle.setBounds(bounds);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(rectangle, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(rectangle, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(rectangle, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(rectangle, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(rectangle, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(rectangle, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(rectangle, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(rectangle, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightClickListener(google.maps.event.addListener(rectangle, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(rectangle, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(rectangle, 'drag', onDrag));\n        }\n        if (onBoundsChanged) {\n            setBoundsChangedListener(google.maps.event.addListener(rectangle, 'bounds_changed', onBoundsChanged));\n        }\n        setInstance(rectangle);\n        if (onLoad) {\n            onLoad(rectangle);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightClickListener !== null) {\n                google.maps.event.removeListener(rightClickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            if (boundsChangedListener !== null) {\n                google.maps.event.removeListener(boundsChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(rectangle);\n            }\n            rectangle.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar RectangleF = react.memo(RectangleFunctional);\nvar Rectangle = /** @class */ (function (_super) {\n    __extends(Rectangle, _super);\n    function Rectangle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            rectangle: null,\n        };\n        _this.setRectangleCallback = function () {\n            if (_this.state.rectangle !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.rectangle);\n            }\n        };\n        return _this;\n    }\n    Rectangle.prototype.componentDidMount = function () {\n        var rectangle = new google.maps.Rectangle(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$9,\n            eventMap: eventMap$9,\n            prevProps: {},\n            nextProps: this.props,\n            instance: rectangle,\n        });\n        this.setState(function setRectangle() {\n            return {\n                rectangle: rectangle,\n            };\n        }, this.setRectangleCallback);\n    };\n    Rectangle.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.rectangle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$9,\n                eventMap: eventMap$9,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.rectangle,\n            });\n        }\n    };\n    Rectangle.prototype.componentWillUnmount = function () {\n        if (this.state.rectangle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.rectangle);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.rectangle.setMap(null);\n        }\n    };\n    Rectangle.prototype.render = function () {\n        return null;\n    };\n    Rectangle.contextType = MapContext;\n    return Rectangle;\n}(react.PureComponent));\n\nvar eventMap$8 = {\n    onCenterChanged: 'center_changed',\n    onRadiusChanged: 'radius_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$8 = {\n    center: function (instance, center) {\n        instance.setCenter(center);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    radius: function (instance, radius) {\n        instance.setRadius(radius);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nvar defaultOptions = {};\nfunction CircleFunctional(_a) {\n    var options = _a.options, center = _a.center, radius = _a.radius, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onCenterChanged = _a.onCenterChanged, onRadiusChanged = _a.onRadiusChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = react.useState(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = react.useState(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = react.useState(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = react.useState(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = react.useState(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = react.useState(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = react.useState(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = react.useState(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = react.useState(null), dragListener = _o[0], setDragListener = _o[1];\n    var _p = react.useState(null), centerChangedListener = _p[0], setCenterChangedListener = _p[1];\n    var _q = react.useState(null), radiusChangedListener = _q[0], setRadiusChangedListener = _q[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    react.useEffect(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    react.useEffect(function () {\n        if (typeof radius === 'number' && instance !== null) {\n            instance.setRadius(radius);\n        }\n    }, [instance, radius]);\n    react.useEffect(function () {\n        if (typeof center !== 'undefined' && instance !== null) {\n            instance.setCenter(center);\n        }\n    }, [instance, center]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    react.useEffect(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    react.useEffect(function () {\n        if (instance && onCenterChanged) {\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            setCenterChangedListener(google.maps.event.addListener(instance, 'center_changed', onCenterChanged));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onRadiusChanged) {\n            if (radiusChangedListener !== null) {\n                google.maps.event.removeListener(radiusChangedListener);\n            }\n            setRadiusChangedListener(google.maps.event.addListener(instance, 'radius_changed', onRadiusChanged));\n        }\n    }, [onRadiusChanged]);\n    react.useEffect(function () {\n        var circle = new google.maps.Circle(__assign(__assign({}, (options || defaultOptions)), { map: map }));\n        if (typeof radius === 'number') {\n            circle.setRadius(radius);\n        }\n        if (typeof center !== 'undefined') {\n            circle.setCenter(center);\n        }\n        if (typeof radius === 'number') {\n            circle.setRadius(radius);\n        }\n        if (typeof visible !== 'undefined') {\n            circle.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            circle.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            circle.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(circle, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(circle, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(circle, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(circle, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(circle, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(circle, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(circle, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(circle, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(circle, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(circle, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(circle, 'drag', onDrag));\n        }\n        if (onCenterChanged) {\n            setCenterChangedListener(google.maps.event.addListener(circle, 'center_changed', onCenterChanged));\n        }\n        if (onRadiusChanged) {\n            setRadiusChangedListener(google.maps.event.addListener(circle, 'radius_changed', onRadiusChanged));\n        }\n        setInstance(circle);\n        if (onLoad) {\n            onLoad(circle);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            if (radiusChangedListener !== null) {\n                google.maps.event.removeListener(radiusChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(circle);\n            }\n            circle.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar CircleF = react.memo(CircleFunctional);\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            circle: null,\n        };\n        _this.setCircleCallback = function () {\n            if (_this.state.circle !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.circle);\n            }\n        };\n        return _this;\n    }\n    Circle.prototype.componentDidMount = function () {\n        var circle = new google.maps.Circle(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$8,\n            eventMap: eventMap$8,\n            prevProps: {},\n            nextProps: this.props,\n            instance: circle,\n        });\n        this.setState(function setCircle() {\n            return {\n                circle: circle,\n            };\n        }, this.setCircleCallback);\n    };\n    Circle.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.circle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$8,\n                eventMap: eventMap$8,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.circle,\n            });\n        }\n    };\n    Circle.prototype.componentWillUnmount = function () {\n        var _a;\n        if (this.state.circle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.circle);\n            }\n            unregisterEvents(this.registeredEvents);\n            (_a = this.state.circle) === null || _a === void 0 ? void 0 : _a.setMap(null);\n        }\n    };\n    Circle.prototype.render = function () {\n        return null;\n    };\n    Circle.contextType = MapContext;\n    return Circle;\n}(react.PureComponent));\n\nvar eventMap$7 = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n    onAddFeature: 'addfeature',\n    onRemoveFeature: 'removefeature',\n    onRemoveProperty: 'removeproperty',\n    onSetGeometry: 'setgeometry',\n    onSetProperty: 'setproperty',\n};\nvar updaterMap$7 = {\n    add: function (instance, feature) {\n        instance.add(feature);\n    },\n    addgeojson: function (instance, geojson, options) {\n        instance.addGeoJson(geojson, options);\n    },\n    contains: function (instance, feature) {\n        instance.contains(feature);\n    },\n    foreach: function (instance, callback) {\n        instance.forEach(callback);\n    },\n    loadgeojson: function (instance, url, options, callback) {\n        instance.loadGeoJson(url, options, callback);\n    },\n    overridestyle: function (instance, feature, style) {\n        instance.overrideStyle(feature, style);\n    },\n    remove: function (instance, feature) {\n        instance.remove(feature);\n    },\n    revertstyle: function (instance, feature) {\n        instance.revertStyle(feature);\n    },\n    controlposition: function (instance, controlPosition) {\n        instance.setControlPosition(controlPosition);\n    },\n    controls: function (instance, controls) {\n        instance.setControls(controls);\n    },\n    drawingmode: function (instance, mode) {\n        instance.setDrawingMode(mode);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    style: function (instance, style) {\n        instance.setStyle(style);\n    },\n    togeojson: function (instance, callback) {\n        instance.toGeoJson(callback);\n    },\n};\nfunction DataFunctional(_a) {\n    var options = _a.options, onClick = _a.onClick, onDblClick = _a.onDblClick, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onAddFeature = _a.onAddFeature, onRemoveFeature = _a.onRemoveFeature, onRemoveProperty = _a.onRemoveProperty, onSetGeometry = _a.onSetGeometry, onSetProperty = _a.onSetProperty, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    var _c = react.useState(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = react.useState(null), mousedownListener = _d[0], setMousedownListener = _d[1];\n    var _e = react.useState(null), mousemoveListener = _e[0], setMousemoveListener = _e[1];\n    var _f = react.useState(null), mouseoutListener = _f[0], setMouseoutListener = _f[1];\n    var _g = react.useState(null), mouseoverListener = _g[0], setMouseoverListener = _g[1];\n    var _h = react.useState(null), mouseupListener = _h[0], setMouseupListener = _h[1];\n    var _j = react.useState(null), rightclickListener = _j[0], setRightclickListener = _j[1];\n    var _k = react.useState(null), clickListener = _k[0], setClickListener = _k[1];\n    var _l = react.useState(null), addFeatureListener = _l[0], setAddFeatureListener = _l[1];\n    var _m = react.useState(null), removeFeatureListener = _m[0], setRemoveFeatureListener = _m[1];\n    var _o = react.useState(null), removePropertyListener = _o[0], setRemovePropertyListener = _o[1];\n    var _p = react.useState(null), setGeometryListener = _p[0], setSetGeometryListener = _p[1];\n    var _q = react.useState(null), setPropertyListener = _q[0], setSetPropertyListener = _q[1];\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    react.useEffect(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    react.useEffect(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    react.useEffect(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    react.useEffect(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    react.useEffect(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    react.useEffect(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    react.useEffect(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    react.useEffect(function () {\n        if (instance && onAddFeature) {\n            if (addFeatureListener !== null) {\n                google.maps.event.removeListener(addFeatureListener);\n            }\n            setAddFeatureListener(google.maps.event.addListener(instance, 'addfeature', onAddFeature));\n        }\n    }, [onAddFeature]);\n    react.useEffect(function () {\n        if (instance && onRemoveFeature) {\n            if (removeFeatureListener !== null) {\n                google.maps.event.removeListener(removeFeatureListener);\n            }\n            setRemoveFeatureListener(google.maps.event.addListener(instance, 'removefeature', onRemoveFeature));\n        }\n    }, [onRemoveFeature]);\n    react.useEffect(function () {\n        if (instance && onRemoveProperty) {\n            if (removePropertyListener !== null) {\n                google.maps.event.removeListener(removePropertyListener);\n            }\n            setRemovePropertyListener(google.maps.event.addListener(instance, 'removeproperty', onRemoveProperty));\n        }\n    }, [onRemoveProperty]);\n    react.useEffect(function () {\n        if (instance && onSetGeometry) {\n            if (setGeometryListener !== null) {\n                google.maps.event.removeListener(setGeometryListener);\n            }\n            setSetGeometryListener(google.maps.event.addListener(instance, 'setgeometry', onSetGeometry));\n        }\n    }, [onSetGeometry]);\n    react.useEffect(function () {\n        if (instance && onSetProperty) {\n            if (setPropertyListener !== null) {\n                google.maps.event.removeListener(setPropertyListener);\n            }\n            setSetPropertyListener(google.maps.event.addListener(instance, 'setproperty', onSetProperty));\n        }\n    }, [onSetProperty]);\n    react.useEffect(function () {\n        if (map !== null) {\n            var data = new google.maps.Data(__assign(__assign({}, (options || {})), { map: map }));\n            if (onDblClick) {\n                setDblclickListener(google.maps.event.addListener(data, 'dblclick', onDblClick));\n            }\n            if (onMouseDown) {\n                setMousedownListener(google.maps.event.addListener(data, 'mousedown', onMouseDown));\n            }\n            if (onMouseMove) {\n                setMousemoveListener(google.maps.event.addListener(data, 'mousemove', onMouseMove));\n            }\n            if (onMouseOut) {\n                setMouseoutListener(google.maps.event.addListener(data, 'mouseout', onMouseOut));\n            }\n            if (onMouseOver) {\n                setMouseoverListener(google.maps.event.addListener(data, 'mouseover', onMouseOver));\n            }\n            if (onMouseUp) {\n                setMouseupListener(google.maps.event.addListener(data, 'mouseup', onMouseUp));\n            }\n            if (onRightClick) {\n                setRightclickListener(google.maps.event.addListener(data, 'rightclick', onRightClick));\n            }\n            if (onClick) {\n                setClickListener(google.maps.event.addListener(data, 'click', onClick));\n            }\n            if (onAddFeature) {\n                setAddFeatureListener(google.maps.event.addListener(data, 'addfeature', onAddFeature));\n            }\n            if (onRemoveFeature) {\n                setRemoveFeatureListener(google.maps.event.addListener(data, 'removefeature', onRemoveFeature));\n            }\n            if (onRemoveProperty) {\n                setRemovePropertyListener(google.maps.event.addListener(data, 'removeproperty', onRemoveProperty));\n            }\n            if (onSetGeometry) {\n                setSetGeometryListener(google.maps.event.addListener(data, 'setgeometry', onSetGeometry));\n            }\n            if (onSetProperty) {\n                setSetPropertyListener(google.maps.event.addListener(data, 'setproperty', onSetProperty));\n            }\n            setInstance(data);\n            if (onLoad) {\n                onLoad(data);\n            }\n        }\n        return function () {\n            if (instance) {\n                if (dblclickListener !== null) {\n                    google.maps.event.removeListener(dblclickListener);\n                }\n                if (mousedownListener !== null) {\n                    google.maps.event.removeListener(mousedownListener);\n                }\n                if (mousemoveListener !== null) {\n                    google.maps.event.removeListener(mousemoveListener);\n                }\n                if (mouseoutListener !== null) {\n                    google.maps.event.removeListener(mouseoutListener);\n                }\n                if (mouseoverListener !== null) {\n                    google.maps.event.removeListener(mouseoverListener);\n                }\n                if (mouseupListener !== null) {\n                    google.maps.event.removeListener(mouseupListener);\n                }\n                if (rightclickListener !== null) {\n                    google.maps.event.removeListener(rightclickListener);\n                }\n                if (clickListener !== null) {\n                    google.maps.event.removeListener(clickListener);\n                }\n                if (addFeatureListener !== null) {\n                    google.maps.event.removeListener(addFeatureListener);\n                }\n                if (removeFeatureListener !== null) {\n                    google.maps.event.removeListener(removeFeatureListener);\n                }\n                if (removePropertyListener !== null) {\n                    google.maps.event.removeListener(removePropertyListener);\n                }\n                if (setGeometryListener !== null) {\n                    google.maps.event.removeListener(setGeometryListener);\n                }\n                if (setPropertyListener !== null) {\n                    google.maps.event.removeListener(setPropertyListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar DataF = react.memo(DataFunctional);\nvar Data = /** @class */ (function (_super) {\n    __extends(Data, _super);\n    function Data() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            data: null,\n        };\n        _this.setDataCallback = function () {\n            if (_this.state.data !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.data);\n            }\n        };\n        return _this;\n    }\n    Data.prototype.componentDidMount = function () {\n        if (this.context !== null) {\n            var data_1 = new google.maps.Data(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$7,\n                eventMap: eventMap$7,\n                prevProps: {},\n                nextProps: this.props,\n                instance: data_1,\n            });\n            this.setState(function () {\n                return {\n                    data: data_1,\n                };\n            }, this.setDataCallback);\n        }\n    };\n    Data.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.data !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$7,\n                eventMap: eventMap$7,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.data,\n            });\n        }\n    };\n    Data.prototype.componentWillUnmount = function () {\n        if (this.state.data !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.data);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.data) {\n                this.state.data.setMap(null);\n            }\n        }\n    };\n    Data.prototype.render = function () {\n        return null;\n    };\n    Data.contextType = MapContext;\n    return Data;\n}(react.PureComponent));\n\nvar eventMap$6 = {\n    onClick: 'click',\n    onDefaultViewportChanged: 'defaultviewport_changed',\n    onStatusChanged: 'status_changed',\n};\nvar updaterMap$6 = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    url: function (instance, url) {\n        instance.setUrl(url);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar KmlLayer = /** @class */ (function (_super) {\n    __extends(KmlLayer, _super);\n    function KmlLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            kmlLayer: null,\n        };\n        _this.setKmlLayerCallback = function () {\n            if (_this.state.kmlLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.kmlLayer);\n            }\n        };\n        return _this;\n    }\n    KmlLayer.prototype.componentDidMount = function () {\n        var kmlLayer = new google.maps.KmlLayer(__assign(__assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$6,\n            eventMap: eventMap$6,\n            prevProps: {},\n            nextProps: this.props,\n            instance: kmlLayer,\n        });\n        this.setState(function setLmlLayer() {\n            return {\n                kmlLayer: kmlLayer,\n            };\n        }, this.setKmlLayerCallback);\n    };\n    KmlLayer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.kmlLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$6,\n                eventMap: eventMap$6,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.kmlLayer,\n            });\n        }\n    };\n    KmlLayer.prototype.componentWillUnmount = function () {\n        if (this.state.kmlLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.kmlLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.kmlLayer.setMap(null);\n        }\n    };\n    KmlLayer.prototype.render = function () {\n        return null;\n    };\n    KmlLayer.contextType = MapContext;\n    return KmlLayer;\n}(react.PureComponent));\n\nfunction getOffsetOverride(containerElement, getPixelPositionOffset) {\n    return typeof getPixelPositionOffset === 'function'\n        ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight)\n        : {\n            x: 0,\n            y: 0,\n        };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLng(inst, Type) { return new Type(inst.lat, inst.lng); }\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLngBounds(inst, Type) {\n    return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ensureOfType(inst, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return inst instanceof type ? inst : factory(inst, type);\n}\nfunction ensureOfTypeBounds(inst, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return inst instanceof type ? inst : factory(inst, type);\n}\nfunction getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {\n    var ne = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n    var sw = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n    if (ne && sw) {\n        return {\n            left: \"\".concat(sw.x + offset.x, \"px\"),\n            top: \"\".concat(ne.y + offset.y, \"px\"),\n            width: \"\".concat(ne.x - sw.x - offset.x, \"px\"),\n            height: \"\".concat(sw.y - ne.y - offset.y, \"px\"),\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n}\nfunction getLayoutStylesByPosition(mapCanvasProjection, offset, position) {\n    var point = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(position);\n    if (point) {\n        var x = point.x, y = point.y;\n        return {\n            left: \"\".concat(x + offset.x, \"px\"),\n            top: \"\".concat(y + offset.y, \"px\"),\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n}\nfunction getLayoutStyles(mapCanvasProjection, offset, bounds, position) {\n    return bounds !== undefined\n        ? getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfTypeBounds(bounds, google.maps.LatLngBounds, createLatLngBounds))\n        : getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));\n}\nfunction arePositionsEqual(currentPosition, previousPosition) {\n    return currentPosition.left === previousPosition.left\n        && currentPosition.top === previousPosition.top\n        && currentPosition.width === previousPosition.height\n        && currentPosition.height === previousPosition.height;\n}\n\nfunction createOverlay(container, pane, position, bounds, getPixelPositionOffset) {\n    var Overlay = /** @class */ (function (_super) {\n        __extends(Overlay, _super);\n        function Overlay(container, pane, position, bounds) {\n            var _this = _super.call(this) || this;\n            _this.container = container;\n            _this.pane = pane;\n            _this.position = position;\n            _this.bounds = bounds;\n            return _this;\n        }\n        Overlay.prototype.onAdd = function () {\n            var _a;\n            var pane = (_a = this.getPanes()) === null || _a === void 0 ? void 0 : _a[this.pane];\n            pane === null || pane === void 0 ? void 0 : pane.appendChild(this.container);\n        };\n        Overlay.prototype.draw = function () {\n            var projection = this.getProjection();\n            var offset = __assign({}, (this.container\n                ? getOffsetOverride(this.container, getPixelPositionOffset)\n                : {\n                    x: 0,\n                    y: 0,\n                }));\n            var layoutStyles = getLayoutStyles(projection, offset, this.bounds, this.position);\n            for (var _i = 0, _a = Object.entries(layoutStyles); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], value = _b[1];\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.container.style[key] = value;\n            }\n        };\n        Overlay.prototype.onRemove = function () {\n            if (this.container.parentNode !== null) {\n                this.container.parentNode.removeChild(this.container);\n            }\n        };\n        return Overlay;\n    }(google.maps.OverlayView));\n    return new Overlay(container, pane, position, bounds);\n}\n\nfunction convertToLatLngString(latLngLike) {\n    if (!latLngLike) {\n        return '';\n    }\n    var latLng = latLngLike instanceof google.maps.LatLng\n        ? latLngLike\n        : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);\n    return latLng + '';\n}\nfunction convertToLatLngBoundsString(latLngBoundsLike) {\n    if (!latLngBoundsLike) {\n        return '';\n    }\n    var latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds\n        ? latLngBoundsLike\n        : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));\n    return latLngBounds + '';\n}\nvar FLOAT_PANE = \"floatPane\";\nvar MAP_PANE = \"mapPane\";\nvar MARKER_LAYER = \"markerLayer\";\nvar OVERLAY_LAYER = \"overlayLayer\";\nvar OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\";\nfunction OverlayViewFunctional(_a) {\n    var position = _a.position, bounds = _a.bounds, mapPaneName = _a.mapPaneName, zIndex = _a.zIndex, onLoad = _a.onLoad, onUnmount = _a.onUnmount, getPixelPositionOffset = _a.getPixelPositionOffset, children = _a.children;\n    var map = react.useContext(MapContext);\n    var container = react.useMemo(function () {\n        var div = document.createElement('div');\n        div.style.position = 'absolute';\n        return div;\n    }, []);\n    var overlay = react.useMemo(function () {\n        return createOverlay(container, mapPaneName, position, bounds, getPixelPositionOffset);\n    }, [container, mapPaneName, position, bounds]);\n    react.useEffect(function () {\n        onLoad === null || onLoad === void 0 ? void 0 : onLoad(overlay);\n        overlay === null || overlay === void 0 ? void 0 : overlay.setMap(map);\n        return function () {\n            onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(overlay);\n            overlay === null || overlay === void 0 ? void 0 : overlay.setMap(null);\n        };\n    }, [map, overlay]);\n    // to move the container to the foreground and background\n    react.useEffect(function () {\n        container.style.zIndex = \"\".concat(zIndex);\n    }, [zIndex, container]);\n    return ReactDOM__namespace.createPortal(children, container);\n}\nvar OverlayViewF = react.memo(OverlayViewFunctional);\nvar OverlayView = /** @class */ (function (_super) {\n    __extends(OverlayView, _super);\n    function OverlayView(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            paneEl: null,\n            containerStyle: {\n                // set initial position\n                position: 'absolute',\n            },\n        };\n        _this.updatePane = function () {\n            var mapPaneName = _this.props.mapPaneName;\n            // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes\n            var mapPanes = _this.overlayView.getPanes();\n            invariant$1(!!mapPaneName, \"OverlayView requires props.mapPaneName but got %s\", mapPaneName);\n            if (mapPanes) {\n                _this.setState({\n                    paneEl: mapPanes[mapPaneName],\n                });\n            }\n            else {\n                _this.setState({\n                    paneEl: null,\n                });\n            }\n        };\n        _this.onAdd = function () {\n            var _a, _b;\n            _this.updatePane();\n            (_b = (_a = _this.props).onLoad) === null || _b === void 0 ? void 0 : _b.call(_a, _this.overlayView);\n        };\n        _this.onPositionElement = function () {\n            var _a;\n            var mapCanvasProjection = _this.overlayView.getProjection();\n            var offset = __assign({ x: 0, y: 0 }, (_this.containerRef.current\n                ? getOffsetOverride(_this.containerRef.current, _this.props.getPixelPositionOffset)\n                : {}));\n            var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, _this.props.bounds, _this.props.position);\n            var left = (_a = _this.state.containerStyle, _a.left), top = _a.top, width = _a.width, height = _a.height;\n            if (!arePositionsEqual(layoutStyles, { left: left, top: top, width: width, height: height })) {\n                _this.setState({\n                    containerStyle: {\n                        top: layoutStyles.top || 0,\n                        left: layoutStyles.left || 0,\n                        width: layoutStyles.width || 0,\n                        height: layoutStyles.height || 0,\n                        position: 'absolute',\n                    },\n                });\n            }\n        };\n        _this.draw = function () {\n            _this.onPositionElement();\n        };\n        _this.onRemove = function () {\n            var _a, _b;\n            _this.setState(function () { return ({\n                paneEl: null,\n            }); });\n            (_b = (_a = _this.props).onUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, _this.overlayView);\n        };\n        _this.containerRef = react.createRef();\n        // You must implement three methods: onAdd(), draw(), and onRemove().\n        var overlayView = new google.maps.OverlayView();\n        overlayView.onAdd = _this.onAdd;\n        overlayView.draw = _this.draw;\n        overlayView.onRemove = _this.onRemove;\n        _this.overlayView = overlayView;\n        return _this;\n    }\n    OverlayView.prototype.componentDidMount = function () {\n        this.overlayView.setMap(this.context);\n    };\n    OverlayView.prototype.componentDidUpdate = function (prevProps) {\n        var prevPositionString = convertToLatLngString(prevProps.position);\n        var positionString = convertToLatLngString(this.props.position);\n        var prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);\n        var boundsString = convertToLatLngBoundsString(this.props.bounds);\n        if (prevPositionString !== positionString ||\n            prevBoundsString !== boundsString) {\n            this.overlayView.draw();\n        }\n        if (prevProps.mapPaneName !== this.props.mapPaneName) {\n            this.updatePane();\n        }\n    };\n    OverlayView.prototype.componentWillUnmount = function () {\n        this.overlayView.setMap(null);\n    };\n    OverlayView.prototype.render = function () {\n        var paneEl = this.state.paneEl;\n        if (paneEl) {\n            return ReactDOM__namespace.createPortal(jsxRuntime.jsx(\"div\", { ref: this.containerRef, style: this.state.containerStyle, children: react.Children.only(this.props.children) }), paneEl);\n        }\n        else {\n            return null;\n        }\n    };\n    OverlayView.FLOAT_PANE = \"floatPane\";\n    OverlayView.MAP_PANE = \"mapPane\";\n    OverlayView.MARKER_LAYER = \"markerLayer\";\n    OverlayView.OVERLAY_LAYER = \"overlayLayer\";\n    OverlayView.OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\";\n    OverlayView.contextType = MapContext;\n    return OverlayView;\n}(react.PureComponent));\n\nfunction noop() { return; }\n\nvar eventMap$5 = {\n    onDblClick: 'dblclick',\n    onClick: 'click',\n};\nvar updaterMap$5 = {\n    opacity: function (instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n};\nfunction GroundOverlayFunctional(_a) {\n    var url = _a.url, bounds = _a.bounds, options = _a.options, visible = _a.visible;\n    var map = react.useContext(MapContext);\n    var imageBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n    var groundOverlay = react.useMemo(function () {\n        var overlay = new google.maps.GroundOverlay(url, imageBounds, __assign({}, options));\n        return overlay;\n    }, []);\n    react.useEffect(function () {\n        if (groundOverlay !== null) {\n            groundOverlay.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (typeof url !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.set(\"url\", url);\n            groundOverlay.setMap(map);\n        }\n    }, [groundOverlay, url]);\n    react.useEffect(function () {\n        if (typeof visible !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.setOpacity(visible ? 1 : 0);\n        }\n    }, [groundOverlay, visible]);\n    react.useEffect(function () {\n        var newBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n        if (typeof bounds !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.set(\"bounds\", newBounds);\n            groundOverlay.setMap(map);\n        }\n    }, [groundOverlay, bounds]);\n    return null;\n}\nvar GroundOverlayF = react.memo(GroundOverlayFunctional);\nvar GroundOverlay = /** @class */ (function (_super) {\n    __extends(GroundOverlay, _super);\n    function GroundOverlay() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            groundOverlay: null,\n        };\n        _this.setGroundOverlayCallback = function () {\n            if (_this.state.groundOverlay !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.groundOverlay);\n            }\n        };\n        return _this;\n    }\n    GroundOverlay.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.url || !!this.props.bounds, \"For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655\");\n        var groundOverlay = new google.maps.GroundOverlay(this.props.url, this.props.bounds, __assign(__assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$5,\n            eventMap: eventMap$5,\n            prevProps: {},\n            nextProps: this.props,\n            instance: groundOverlay,\n        });\n        this.setState(function setGroundOverlay() {\n            return {\n                groundOverlay: groundOverlay,\n            };\n        }, this.setGroundOverlayCallback);\n    };\n    GroundOverlay.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.groundOverlay !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$5,\n                eventMap: eventMap$5,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.groundOverlay,\n            });\n        }\n    };\n    GroundOverlay.prototype.componentWillUnmount = function () {\n        if (this.state.groundOverlay) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.groundOverlay);\n            }\n            this.state.groundOverlay.setMap(null);\n        }\n    };\n    GroundOverlay.prototype.render = function () {\n        return null;\n    };\n    GroundOverlay.defaultProps = {\n        onLoad: noop,\n    };\n    GroundOverlay.contextType = MapContext;\n    return GroundOverlay;\n}(react.PureComponent));\n\nvar eventMap$4 = {};\nvar updaterMap$4 = {\n    data: function (instance, data) {\n        instance.setData(data);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction HeatmapLayerFunctional(_a) {\n    var data = _a.data, onLoad = _a.onLoad, onUnmount = _a.onUnmount, options = _a.options;\n    var map = react.useContext(MapContext);\n    var _b = react.useState(null), instance = _b[0], setInstance = _b[1];\n    react.useEffect(function () {\n        if (!google.maps.visualization) {\n            invariant$1(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} in useJsApiScript? %s', google.maps.visualization);\n        }\n    }, []);\n    react.useEffect(function () {\n        invariant$1(!!data, 'data property is required in HeatmapLayer %s', data);\n    }, [data]);\n    // Order does matter\n    react.useEffect(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    react.useEffect(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    react.useEffect(function () {\n        var heatmapLayer = new google.maps.visualization.HeatmapLayer(__assign(__assign({}, (options || {})), { data: data, map: map }));\n        setInstance(heatmapLayer);\n        if (onLoad) {\n            onLoad(heatmapLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar HeatmapLayerF = react.memo(HeatmapLayerFunctional);\nvar HeatmapLayer = /** @class */ (function (_super) {\n    __extends(HeatmapLayer, _super);\n    function HeatmapLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            heatmapLayer: null,\n        };\n        _this.setHeatmapLayerCallback = function () {\n            if (_this.state.heatmapLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.heatmapLayer);\n            }\n        };\n        return _this;\n    }\n    HeatmapLayer.prototype.componentDidMount = function () {\n        invariant$1(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} to <LoadScript />? %s', google.maps.visualization);\n        invariant$1(!!this.props.data, 'data property is required in HeatmapLayer %s', this.props.data);\n        var heatmapLayer = new google.maps.visualization.HeatmapLayer(__assign(__assign({}, (this.props.options || {})), { data: this.props.data, map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps: {},\n            nextProps: this.props,\n            instance: heatmapLayer,\n        });\n        this.setState(function setHeatmapLayer() {\n            return {\n                heatmapLayer: heatmapLayer,\n            };\n        }, this.setHeatmapLayerCallback);\n    };\n    HeatmapLayer.prototype.componentDidUpdate = function (prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps: prevProps,\n            nextProps: this.props,\n            instance: this.state.heatmapLayer,\n        });\n    };\n    HeatmapLayer.prototype.componentWillUnmount = function () {\n        if (this.state.heatmapLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.heatmapLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.heatmapLayer.setMap(null);\n        }\n    };\n    HeatmapLayer.prototype.render = function () {\n        return null;\n    };\n    HeatmapLayer.contextType = MapContext;\n    return HeatmapLayer;\n}(react.PureComponent));\n\nvar eventMap$3 = {\n    onCloseClick: 'closeclick',\n    onPanoChanged: 'pano_changed',\n    onPositionChanged: 'position_changed',\n    onPovChanged: 'pov_changed',\n    onResize: 'resize',\n    onStatusChanged: 'status_changed',\n    onVisibleChanged: 'visible_changed',\n    onZoomChanged: 'zoom_changed',\n};\nvar updaterMap$3 = {\n    register: function (instance, provider, options) {\n        instance.registerPanoProvider(provider, options);\n    },\n    links: function (instance, links) {\n        instance.setLinks(links);\n    },\n    motionTracking: function (instance, motionTracking) {\n        instance.setMotionTracking(motionTracking);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    pano: function (instance, pano) {\n        instance.setPano(pano);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    pov: function (instance, pov) {\n        instance.setPov(pov);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zoom: function (instance, zoom) {\n        instance.setZoom(zoom);\n    },\n};\nvar StreetViewPanorama = /** @class */ (function (_super) {\n    __extends(StreetViewPanorama, _super);\n    function StreetViewPanorama() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            streetViewPanorama: null,\n        };\n        _this.setStreetViewPanoramaCallback = function () {\n            if (_this.state.streetViewPanorama !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.streetViewPanorama);\n            }\n        };\n        return _this;\n    }\n    StreetViewPanorama.prototype.componentDidMount = function () {\n        var _a, _b;\n        var streetViewPanorama = (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.getStreetView()) !== null && _b !== void 0 ? _b : null;\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$3,\n            eventMap: eventMap$3,\n            prevProps: {},\n            nextProps: this.props,\n            instance: streetViewPanorama,\n        });\n        this.setState(function () {\n            return {\n                streetViewPanorama: streetViewPanorama,\n            };\n        }, this.setStreetViewPanoramaCallback);\n    };\n    StreetViewPanorama.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.streetViewPanorama !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$3,\n                eventMap: eventMap$3,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.streetViewPanorama,\n            });\n        }\n    };\n    StreetViewPanorama.prototype.componentWillUnmount = function () {\n        if (this.state.streetViewPanorama !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.streetViewPanorama);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.streetViewPanorama.setVisible(false);\n        }\n    };\n    StreetViewPanorama.prototype.render = function () {\n        return null;\n    };\n    StreetViewPanorama.contextType = MapContext;\n    return StreetViewPanorama;\n}(react.PureComponent));\n\nvar StreetViewService = /** @class */ (function (_super) {\n    __extends(StreetViewService, _super);\n    function StreetViewService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            streetViewService: null,\n        };\n        _this.setStreetViewServiceCallback = function () {\n            if (_this.state.streetViewService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.streetViewService);\n            }\n        };\n        return _this;\n    }\n    StreetViewService.prototype.componentDidMount = function () {\n        var streetViewService = new google.maps.StreetViewService();\n        this.setState(function setStreetViewService() {\n            return {\n                streetViewService: streetViewService,\n            };\n        }, this.setStreetViewServiceCallback);\n    };\n    StreetViewService.prototype.componentWillUnmount = function () {\n        if (this.state.streetViewService !== null && this.props.onUnmount) {\n            this.props.onUnmount(this.state.streetViewService);\n        }\n    };\n    StreetViewService.prototype.render = function () {\n        return null;\n    };\n    StreetViewService.contextType = MapContext;\n    return StreetViewService;\n}(react.PureComponent));\n\nvar DirectionsService = /** @class */ (function (_super) {\n    __extends(DirectionsService, _super);\n    function DirectionsService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            directionsService: null,\n        };\n        _this.setDirectionsServiceCallback = function () {\n            if (_this.state.directionsService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.directionsService);\n            }\n        };\n        return _this;\n    }\n    DirectionsService.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.options, 'DirectionsService expected options object as parameter, but got %s', this.props.options);\n        var directionsService = new google.maps.DirectionsService();\n        this.setState(function setDirectionsService() {\n            return {\n                directionsService: directionsService,\n            };\n        }, this.setDirectionsServiceCallback);\n    };\n    DirectionsService.prototype.componentDidUpdate = function () {\n        if (this.state.directionsService !== null) {\n            this.state.directionsService.route(this.props.options, this.props.callback);\n        }\n    };\n    DirectionsService.prototype.componentWillUnmount = function () {\n        if (this.state.directionsService !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsService);\n            }\n        }\n    };\n    DirectionsService.prototype.render = function () {\n        return null;\n    };\n    return DirectionsService;\n}(react.PureComponent));\n\nvar eventMap$2 = {\n    onDirectionsChanged: 'directions_changed',\n};\nvar updaterMap$2 = {\n    directions: function (instance, directions) {\n        instance.setDirections(directions);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    panel: function (instance, panel) {\n        instance.setPanel(panel);\n    },\n    routeIndex: function (instance, routeIndex) {\n        instance.setRouteIndex(routeIndex);\n    },\n};\nvar DirectionsRenderer = /** @class */ (function (_super) {\n    __extends(DirectionsRenderer, _super);\n    function DirectionsRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            directionsRenderer: null,\n        };\n        _this.setDirectionsRendererCallback = function () {\n            if (_this.state.directionsRenderer !== null) {\n                _this.state.directionsRenderer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.directionsRenderer);\n                }\n            }\n        };\n        return _this;\n    }\n    DirectionsRenderer.prototype.componentDidMount = function () {\n        var directionsRenderer = new google.maps.DirectionsRenderer(this.props.options);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$2,\n            eventMap: eventMap$2,\n            prevProps: {},\n            nextProps: this.props,\n            instance: directionsRenderer,\n        });\n        this.setState(function setDirectionsRenderer() {\n            return {\n                directionsRenderer: directionsRenderer,\n            };\n        }, this.setDirectionsRendererCallback);\n    };\n    DirectionsRenderer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.directionsRenderer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$2,\n                eventMap: eventMap$2,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.directionsRenderer,\n            });\n        }\n    };\n    DirectionsRenderer.prototype.componentWillUnmount = function () {\n        if (this.state.directionsRenderer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsRenderer);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.directionsRenderer) {\n                this.state.directionsRenderer.setMap(null);\n            }\n        }\n    };\n    DirectionsRenderer.prototype.render = function () {\n        return jsxRuntime.jsx(jsxRuntime.Fragment, {});\n    };\n    DirectionsRenderer.contextType = MapContext;\n    return DirectionsRenderer;\n}(react.PureComponent));\n\nvar DistanceMatrixService = /** @class */ (function (_super) {\n    __extends(DistanceMatrixService, _super);\n    function DistanceMatrixService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            distanceMatrixService: null,\n        };\n        _this.setDistanceMatrixServiceCallback = function () {\n            if (_this.state.distanceMatrixService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.distanceMatrixService);\n            }\n        };\n        return _this;\n    }\n    DistanceMatrixService.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.options, 'DistanceMatrixService expected options object as parameter, but go %s', this.props.options);\n        var distanceMatrixService = new google.maps.DistanceMatrixService();\n        this.setState(function setDistanceMatrixService() {\n            return {\n                distanceMatrixService: distanceMatrixService,\n            };\n        }, this.setDistanceMatrixServiceCallback);\n    };\n    DistanceMatrixService.prototype.componentDidUpdate = function () {\n        if (this.state.distanceMatrixService !== null) {\n            this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);\n        }\n    };\n    DistanceMatrixService.prototype.componentWillUnmount = function () {\n        if (this.state.distanceMatrixService !== null && this.props.onUnmount) {\n            this.props.onUnmount(this.state.distanceMatrixService);\n        }\n    };\n    DistanceMatrixService.prototype.render = function () {\n        return null;\n    };\n    return DistanceMatrixService;\n}(react.PureComponent));\n\nvar eventMap$1 = {\n    onPlacesChanged: 'places_changed',\n};\nvar updaterMap$1 = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n};\nvar StandaloneSearchBox = /** @class */ (function (_super) {\n    __extends(StandaloneSearchBox, _super);\n    function StandaloneSearchBox() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = react.createRef();\n        _this.state = {\n            searchBox: null,\n        };\n        _this.setSearchBoxCallback = function () {\n            if (_this.state.searchBox !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.searchBox);\n            }\n        };\n        return _this;\n    }\n    StandaloneSearchBox.prototype.componentDidMount = function () {\n        invariant$1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        if (this.containerElement !== null && this.containerElement.current !== null) {\n            var input = this.containerElement.current.querySelector('input');\n            if (input !== null) {\n                var searchBox_1 = new google.maps.places.SearchBox(input, this.props.options);\n                this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                    updaterMap: updaterMap$1,\n                    eventMap: eventMap$1,\n                    prevProps: {},\n                    nextProps: this.props,\n                    instance: searchBox_1,\n                });\n                this.setState(function setSearchBox() {\n                    return {\n                        searchBox: searchBox_1,\n                    };\n                }, this.setSearchBoxCallback);\n            }\n        }\n    };\n    StandaloneSearchBox.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.searchBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$1,\n                eventMap: eventMap$1,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.searchBox,\n            });\n        }\n    };\n    StandaloneSearchBox.prototype.componentWillUnmount = function () {\n        if (this.state.searchBox !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.searchBox);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    StandaloneSearchBox.prototype.render = function () {\n        return jsxRuntime.jsx(\"div\", { ref: this.containerElement, children: react.Children.only(this.props.children) });\n    };\n    StandaloneSearchBox.contextType = MapContext;\n    return StandaloneSearchBox;\n}(react.PureComponent));\n\nvar eventMap = {\n    onPlaceChanged: 'place_changed',\n};\nvar updaterMap = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    restrictions: function (instance, restrictions) {\n        instance.setComponentRestrictions(restrictions);\n    },\n    fields: function (instance, fields) {\n        instance.setFields(fields);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    types: function (instance, types) {\n        instance.setTypes(types);\n    },\n};\nvar Autocomplete = /** @class */ (function (_super) {\n    __extends(Autocomplete, _super);\n    function Autocomplete() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = react.createRef();\n        _this.state = {\n            autocomplete: null,\n        };\n        _this.setAutocompleteCallback = function () {\n            if (_this.state.autocomplete !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.autocomplete);\n            }\n        };\n        return _this;\n    }\n    Autocomplete.prototype.componentDidMount = function () {\n        var _a;\n        invariant$1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        // TODO: why current could be equal null?\n        var input = (_a = this.containerElement.current) === null || _a === void 0 ? void 0 : _a.querySelector('input');\n        if (input) {\n            var autocomplete_1 = new google.maps.places.Autocomplete(input, this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap,\n                eventMap: eventMap,\n                prevProps: {},\n                nextProps: this.props,\n                instance: autocomplete_1,\n            });\n            this.setState(function () {\n                return {\n                    autocomplete: autocomplete_1,\n                };\n            }, this.setAutocompleteCallback);\n        }\n    };\n    Autocomplete.prototype.componentDidUpdate = function (prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap,\n            eventMap: eventMap,\n            prevProps: prevProps,\n            nextProps: this.props,\n            instance: this.state.autocomplete,\n        });\n    };\n    Autocomplete.prototype.componentWillUnmount = function () {\n        if (this.state.autocomplete !== null) {\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    Autocomplete.prototype.render = function () {\n        return jsxRuntime.jsx(\"div\", { ref: this.containerElement, className: this.props.className, children: react.Children.only(this.props.children) });\n    };\n    Autocomplete.defaultProps = {\n        className: ''\n    };\n    Autocomplete.contextType = MapContext;\n    return Autocomplete;\n}(react.PureComponent));\n\nexports.Autocomplete = Autocomplete;\nexports.BicyclingLayer = BicyclingLayer;\nexports.BicyclingLayerF = BicyclingLayerF;\nexports.Circle = Circle;\nexports.CircleF = CircleF;\nexports.Data = Data;\nexports.DataF = DataF;\nexports.DirectionsRenderer = DirectionsRenderer;\nexports.DirectionsService = DirectionsService;\nexports.DistanceMatrixService = DistanceMatrixService;\nexports.DrawingManager = DrawingManager;\nexports.DrawingManagerF = DrawingManagerF;\nexports.FLOAT_PANE = FLOAT_PANE;\nexports.GoogleMap = GoogleMap;\nexports.GoogleMapsMarkerClusterer = index_esm;\nexports.GoogleMarkerClusterer = GoogleMarkerClusterer$1;\nexports.GroundOverlay = GroundOverlay;\nexports.GroundOverlayF = GroundOverlayF;\nexports.HeatmapLayer = HeatmapLayer;\nexports.HeatmapLayerF = HeatmapLayerF;\nexports.InfoBox = InfoBoxComponent;\nexports.InfoBoxF = InfoBoxF;\nexports.InfoWindow = InfoWindow;\nexports.InfoWindowF = InfoWindowF;\nexports.KmlLayer = KmlLayer;\nexports.LoadScript = LoadScript;\nexports.LoadScriptNext = LoadScriptNext$1;\nexports.MAP_PANE = MAP_PANE;\nexports.MARKER_LAYER = MARKER_LAYER;\nexports.MapContext = MapContext;\nexports.Marker = Marker;\nexports.MarkerClusterer = ClustererComponent;\nexports.MarkerClustererF = MarkerClustererF;\nexports.MarkerF = MarkerF;\nexports.OVERLAY_LAYER = OVERLAY_LAYER;\nexports.OVERLAY_MOUSE_TARGET = OVERLAY_MOUSE_TARGET;\nexports.OverlayView = OverlayView;\nexports.OverlayViewF = OverlayViewF;\nexports.Polygon = Polygon;\nexports.PolygonF = PolygonF;\nexports.Polyline = Polyline;\nexports.PolylineF = PolylineF;\nexports.Rectangle = Rectangle;\nexports.RectangleF = RectangleF;\nexports.StandaloneSearchBox = StandaloneSearchBox;\nexports.StreetViewPanorama = StreetViewPanorama;\nexports.StreetViewService = StreetViewService;\nexports.TrafficLayer = TrafficLayer;\nexports.TrafficLayerF = TrafficLayerF;\nexports.TransitLayer = TransitLayer;\nexports.TransitLayerF = TransitLayerF;\nexports.useGoogleMap = useGoogleMap;\nexports.useJsApiLoader = useJsApiLoader;\nexports.useLoadScript = useLoadScript;\n//# sourceMappingURL=cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWdvb2dsZS1tYXBzL2FwaS9kaXN0L2Nqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGlCQUFpQixtQkFBTyxDQUFDLG1JQUFtQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLGdIQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsYUFBb0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyw4SEFBOEgsc0ZBQXNGLEdBQUcsR0FBRztBQUM5UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUtBQXVLLHVIQUF1SCxHQUFHLEdBQUc7QUFDNVU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1DQUFtQyxpQkFBaUI7QUFDM0c7QUFDQSwyRkFBMkYsSUFBSTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiOztBQUVBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBLGtCQUFrQix1TEFBdUw7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw4QkFBOEIsTUFBTSx3Q0FBd0M7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxHQUFHO0FBQzlEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0RUFBNEUsZ0JBQWdCLE1BQU0sVUFBVTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMkJBQTJCLE1BQU0sbUJBQW1CO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGLHdGQUF3RixnQkFBZ0IsTUFBTSxVQUFVO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RiwyQkFBMkIsTUFBTSxtQkFBbUI7QUFDNUk7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5REFBeUQsb0VBQW9FLFVBQVUsTUFBTSxvQkFBb0I7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwwRkFBMEYsbUJBQW1CLE1BQU0sK0JBQStCO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0IsOERBQThELGdFQUFnRSxrQ0FBa0Msb0NBQW9DO0FBQ3JSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNEJBQTRCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHVDQUF1Qyx5Q0FBeUMsb0NBQW9DLHlDQUF5QywyQ0FBMkMsMkNBQTJDLHdDQUF3QyxtREFBbUQsb0JBQW9CLGtDQUFrQztBQUNuYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QywrQ0FBK0M7QUFDL0MsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRSxnREFBZ0QsY0FBYztBQUM5RCxzREFBc0QsY0FBYztBQUNwRSxnREFBZ0QsY0FBYztBQUM5RCw0Q0FBNEMsY0FBYztBQUMxRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsNENBQTRDO0FBQzVDLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUMsa0RBQWtEO0FBQ2xELCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVEQUF1RDtBQUMxRjtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDLHFDQUFxQztBQUNyQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsdUNBQXVDLDJCQUEyQixJQUFJO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHVDQUF1QywyQkFBMkIsSUFBSTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbU9BQW1POztBQUVqUCxtQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsc0JBQXNCLFFBQVE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLDRGQUE0RixTQUFTOztBQUVyRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxVQUFVO0FBQ3ZFOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVUsc0JBQXNCLGNBQWM7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7O0FBRUEsZ0RBQWdELGFBQWEsZ0JBQWdCOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1QkFBdUI7O0FBRXRDOztBQUVBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckIsZ0NBQWdDLFlBQVk7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsb0RBQW9ELHNCQUFzQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUM7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGdCQUFnQixTQUFTO0FBQ3pCLHVCQUF1QjtBQUN2Qiw2REFBNkQsK0JBQStCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZLDBCQUEwQixlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVMsSUFBSTtBQUNqRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQSwrSUFBK0ksTUFBTTtBQUNySjtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsVUFBVTtBQUM1RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3Qyw2SUFBNkk7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsY0FBYyxVQUFVO0FBQ2hHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwyQkFBMkI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0VBQW9FLG9DQUFvQyxVQUFVO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDJCQUEyQixNQUFNLG1CQUFtQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0VBQWtFLGdCQUFnQixNQUFNLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMkJBQTJCLE1BQU0sbUJBQW1CO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNFQUFzRSxnQkFBZ0IsTUFBTSxVQUFVO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDJCQUEyQixNQUFNLG1CQUFtQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdFQUFnRSxrQ0FBa0MsVUFBVTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkIsTUFBTSxtQkFBbUI7QUFDcEg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0IsTUFBTSxVQUFVO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMkJBQTJCLE1BQU0sbUJBQW1CO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlCQUF5QixtQkFBbUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnRUFBZ0UsZ0JBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG1EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw4R0FBOEc7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJrQkFBMmtCLElBQUk7QUFDL2tCLGlIQUFpSCx5QkFBeUIsbUJBQW1CO0FBQzdKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLG1CQUFtQjtBQUN6RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwRkFBMEYsZ0JBQWdCLE1BQU0sc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixtQkFBbUI7QUFDckc7QUFDQSwwRkFBMEYsMkJBQTJCLE1BQU0sMENBQTBDO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0ZBQWdGO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlIQUFpSDtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxlQUFlO0FBQ2YsWUFBWTtBQUNaLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1nb29nbGUtbWFwcy9hcGkvZGlzdC9janMuanM/NjM0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBqc3hSdW50aW1lID0gcmVxdWlyZSgncmVhY3QvanN4LXJ1bnRpbWUnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdERPTV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0RE9NKTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QkMShzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyJDEodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBOT0RFX0VOViA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG52YXIgaW52YXJpYW50XzEgPSBpbnZhcmlhbnQ7XG5cbnZhciBpbnZhcmlhbnQkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpbnZhcmlhbnRfMSk7XG5cbnZhciBNYXBDb250ZXh0ID0gcmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUdvb2dsZU1hcCgpIHtcbiAgICBpbnZhcmlhbnQkMSghIXJlYWN0LnVzZUNvbnRleHQsICd1c2VHb29nbGVNYXAgaXMgUmVhY3QgaG9vayBhbmQgcmVxdWlyZXMgUmVhY3QgdmVyc2lvbiAxNi44KycpO1xuICAgIHZhciBtYXAgPSByZWFjdC51c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIGludmFyaWFudCQxKCEhbWFwLCAndXNlR29vZ2xlTWFwIG5lZWRzIGEgR29vZ2xlTWFwIGF2YWlsYWJsZSB1cCBpbiB0aGUgdHJlZScpO1xuICAgIHJldHVybiBtYXA7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBmbiwgYWNjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIHJlZHVjZXIobmV3QWNjLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZuKG5ld0FjYywgb2JqW2tleV0sIGtleSk7XG4gICAgfSwgYWNjKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBmbihvYmpba2V5XSwga2V5KTtcbiAgICB9KTtcbn1cblxuLyogZ2xvYmFsIGdvb2dsZSAqL1xuZnVuY3Rpb24gYXBwbHlVcGRhdGVyVG9OZXh0UHJvcHMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudXBkYXRlck1hcCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucHJldlByb3BzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5uZXh0UHJvcHMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmluc3RhbmNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB2YXIgbWFwID0ge307XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB2YXIgaXRlciA9IGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHRWYWx1ZSAhPT0gcHJldlByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIG1hcFtrZXldID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgZm4oaW5zdGFuY2UsIG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvckVhY2godXBkYXRlck1hcCwgaXRlcik7XG4gICAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByb3BzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5pbnN0YW5jZSwgZXZlbnRNYXApIHtcbiAgICB2YXIgcmVnaXN0ZXJlZExpc3QgPSByZWR1Y2UoZXZlbnRNYXAsIGZ1bmN0aW9uIHJlZHVjZXIoYWNjLCBnb29nbGVFdmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb25FdmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tvbkV2ZW50TmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBnb29nbGVFdmVudE5hbWUsIHByb3BzW29uRXZlbnROYW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZWdpc3RlcmVkTGlzdDtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJFdmVudChyZWdpc3RlcmVkKSB7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVnaXN0ZXJlZCk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnRzKGV2ZW50cykge1xuICAgIGlmIChldmVudHMgPT09IHZvaWQgMCkgeyBldmVudHMgPSBbXTsgfVxuICAgIGV2ZW50cy5mb3JFYWNoKHVucmVnaXN0ZXJFdmVudCk7XG59XG5mdW5jdGlvbiBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKF9hKSB7XG4gICAgdmFyIHVwZGF0ZXJNYXAgPSBfYS51cGRhdGVyTWFwLCBldmVudE1hcCA9IF9hLmV2ZW50TWFwLCBwcmV2UHJvcHMgPSBfYS5wcmV2UHJvcHMsIG5leHRQcm9wcyA9IF9hLm5leHRQcm9wcywgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICB2YXIgcmVnaXN0ZXJlZEV2ZW50cyA9IHJlZ2lzdGVyRXZlbnRzKG5leHRQcm9wcywgaW5zdGFuY2UsIGV2ZW50TWFwKTtcbiAgICBhcHBseVVwZGF0ZXJUb05leHRQcm9wcyh1cGRhdGVyTWFwLCBwcmV2UHJvcHMsIG5leHRQcm9wcywgaW5zdGFuY2UpO1xuICAgIHJldHVybiByZWdpc3RlcmVkRXZlbnRzO1xufVxuXG52YXIgZXZlbnRNYXAkaSA9IHtcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICAgIG9uQm91bmRzQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICBvbkNlbnRlckNoYW5nZWQ6ICdjZW50ZXJfY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkhlYWRpbmdDaGFuZ2VkOiAnaGVhZGluZ19jaGFuZ2VkJyxcbiAgICBvbklkbGU6ICdpZGxlJyxcbiAgICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJlc2l6ZTogJ3Jlc2l6ZScsXG4gICAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gICAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAkaSA9IHtcbiAgICBleHRyYU1hcFR5cGVzOiBmdW5jdGlvbiAobWFwLCBleHRyYSkge1xuICAgICAgICBleHRyYS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hFeHRyYShpdCwgaSkge1xuICAgICAgICAgICAgbWFwLm1hcFR5cGVzLnNldChTdHJpbmcoaSksIGl0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjZW50ZXI6IGZ1bmN0aW9uIChtYXAsIGNlbnRlcikge1xuICAgICAgICBtYXAuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfSxcbiAgICBjbGlja2FibGVJY29uczogZnVuY3Rpb24gKG1hcCwgY2xpY2thYmxlKSB7XG4gICAgICAgIG1hcC5zZXRDbGlja2FibGVJY29ucyhjbGlja2FibGUpO1xuICAgIH0sXG4gICAgaGVhZGluZzogZnVuY3Rpb24gKG1hcCwgaGVhZGluZykge1xuICAgICAgICBtYXAuc2V0SGVhZGluZyhoZWFkaW5nKTtcbiAgICB9LFxuICAgIG1hcFR5cGVJZDogZnVuY3Rpb24gKG1hcCwgbWFwVHlwZUlkKSB7XG4gICAgICAgIG1hcC5zZXRNYXBUeXBlSWQobWFwVHlwZUlkKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcbiAgICAgICAgbWFwLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBzdHJlZXRWaWV3OiBmdW5jdGlvbiAobWFwLCBzdHJlZXRWaWV3KSB7XG4gICAgICAgIG1hcC5zZXRTdHJlZXRWaWV3KHN0cmVldFZpZXcpO1xuICAgIH0sXG4gICAgdGlsdDogZnVuY3Rpb24gKG1hcCwgdGlsdCkge1xuICAgICAgICBtYXAuc2V0VGlsdCh0aWx0KTtcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uIChtYXAsIHpvb20pIHtcbiAgICAgICAgbWFwLnNldFpvb20oem9vbSk7XG4gICAgfSxcbn07XG4vLyBUT0RPOiB1bmZpbmlzaGVkIVxuZnVuY3Rpb24gR29vZ2xlTWFwRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvcHRpb25zID0gX2Eub3B0aW9ucywgaWQgPSBfYS5pZCwgbWFwQ29udGFpbmVyU3R5bGUgPSBfYS5tYXBDb250YWluZXJTdHlsZSwgbWFwQ29udGFpbmVyQ2xhc3NOYW1lID0gX2EubWFwQ29udGFpbmVyQ2xhc3NOYW1lLCBjZW50ZXIgPSBfYS5jZW50ZXIsIFxuICAgIC8vIGNsaWNrYWJsZUljb25zLFxuICAgIC8vIGV4dHJhTWFwVHlwZXMsXG4gICAgLy8gaGVhZGluZyxcbiAgICAvLyBtYXBUeXBlSWQsXG4gICAgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRGJsQ2xpY2sgPSBfYS5vbkRibENsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCwgb25Nb3VzZU1vdmUgPSBfYS5vbk1vdXNlTW92ZSwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VEb3duID0gX2Eub25Nb3VzZURvd24sIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBcbiAgICAvLyBvbk1hcFR5cGVJZENoYW5nZWQsXG4gICAgLy8gb25UaWxlc0xvYWRlZCxcbiAgICAvLyBvbkJvdW5kc0NoYW5nZWQsXG4gICAgb25DZW50ZXJDaGFuZ2VkID0gX2Eub25DZW50ZXJDaGFuZ2VkLCBcbiAgICAvLyBvbkhlYWRpbmdDaGFuZ2VkLFxuICAgIC8vIG9uSWRsZSxcbiAgICAvLyBvblByb2plY3Rpb25DaGFuZ2VkLFxuICAgIC8vIG9uUmVzaXplLFxuICAgIC8vIG9uVGlsdENoYW5nZWQsXG4gICAgLy8gb25ab29tQ2hhbmdlZCxcbiAgICBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgX2IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbWFwID0gX2JbMF0sIHNldE1hcCA9IF9iWzFdO1xuICAgIHZhciByZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgLy8gY29uc3QgW2V4dHJhTWFwVHlwZXNMaXN0ZW5lciwgc2V0RXh0cmFNYXBUeXBlc0xpc3RlbmVyXSA9IHVzZVN0YXRlPGdvb2dsZS5tYXBzLk1hcHNFdmVudExpc3RlbmVyIHwgbnVsbD4obnVsbClcbiAgICB2YXIgX2MgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2VudGVyQ2hhbmdlZExpc3RlbmVyID0gX2NbMF0sIHNldENlbnRlckNoYW5nZWRMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkYmxjbGlja0xpc3RlbmVyID0gX2RbMF0sIHNldERibGNsaWNrTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ2VuZExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdlbmRMaXN0ZW5lciA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkcmFnc3RhcnRMaXN0ZW5lciA9IF9mWzBdLCBzZXREcmFnc3RhcnRMaXN0ZW5lciA9IF9mWzFdO1xuICAgIHZhciBfZyA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZWRvd25MaXN0ZW5lciA9IF9nWzBdLCBzZXRNb3VzZWRvd25MaXN0ZW5lciA9IF9nWzFdO1xuICAgIHZhciBfaCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW1vdmVMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW1vdmVMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW91dExpc3RlbmVyID0gX2pbMF0sIHNldE1vdXNlb3V0TGlzdGVuZXIgPSBfalsxXTtcbiAgICB2YXIgX2sgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2VvdmVyTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2VvdmVyTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2V1cExpc3RlbmVyID0gX2xbMF0sIHNldE1vdXNldXBMaXN0ZW5lciA9IF9sWzFdO1xuICAgIHZhciBfbSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCByaWdodGNsaWNrTGlzdGVuZXIgPSBfbVswXSwgc2V0UmlnaHRjbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGNsaWNrTGlzdGVuZXIgPSBfb1swXSwgc2V0Q2xpY2tMaXN0ZW5lciA9IF9vWzFdO1xuICAgIHZhciBfcCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkcmFnTGlzdGVuZXIgPSBfcFswXSwgc2V0RHJhZ0xpc3RlbmVyID0gX3BbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBtYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW21hcCwgb3B0aW9uc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgIT09IG51bGwgJiYgdHlwZW9mIGNlbnRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hcC5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXAsIGNlbnRlcl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25EYmxDbGljaykge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnRW5kXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZURvd25dKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VNb3ZlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZVVwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZHJhZycsIG9uRHJhZykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25DZW50ZXJDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoY2VudGVyQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2VudGVyQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENlbnRlckNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdjZW50ZXJfY2hhbmdlZCcsIG9uQ2VudGVyQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gcmVmLmN1cnJlbnQgPT09IG51bGxcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBuZXcgZ29vZ2xlLm1hcHMuTWFwKHJlZi5jdXJyZW50LCBvcHRpb25zKTtcbiAgICAgICAgc2V0TWFwKG1hcCk7XG4gICAgICAgIGlmIChtYXAgIT09IG51bGwgJiYgb25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQobWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KG1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHsgaWQ6IGlkLCByZWY6IHJlZiwgc3R5bGU6IG1hcENvbnRhaW5lclN0eWxlLCBjbGFzc05hbWU6IG1hcENvbnRhaW5lckNsYXNzTmFtZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWUuanN4KE1hcENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1hcCwgY2hpbGRyZW46IG1hcCAhPT0gbnVsbCA/IGNoaWxkcmVuIDoganN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwge30pIH0pIH0pKTtcbn1cbnJlYWN0Lm1lbW8oR29vZ2xlTWFwRnVuY3Rpb25hbCk7XG52YXIgR29vZ2xlTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHb29nbGVNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR29vZ2xlTWFwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMubWFwUmVmID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMubWFwUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcChfdGhpcy5tYXBSZWYsIF90aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wYW5UbyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSBfdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5UbyhsYXRMbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRNYXBDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5tYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5tYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgX3RoaXMubWFwUmVmID0gcmVmO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdvb2dsZU1hcC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRpLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGksXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IG1hcCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TWFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0TWFwQ2FsbGJhY2spO1xuICAgIH07XG4gICAgR29vZ2xlTWFwLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRpLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRpLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5tYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR29vZ2xlTWFwLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdvb2dsZU1hcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHsgaWQ6IHRoaXMucHJvcHMuaWQsIHJlZjogdGhpcy5nZXRSZWYsIHN0eWxlOiB0aGlzLnByb3BzLm1hcENvbnRhaW5lclN0eWxlLCBjbGFzc05hbWU6IHRoaXMucHJvcHMubWFwQ29udGFpbmVyQ2xhc3NOYW1lLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goTWFwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5zdGF0ZS5tYXAsIGNoaWxkcmVuOiB0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiBqc3hSdW50aW1lLmpzeChqc3hSdW50aW1lLkZyYWdtZW50LCB7fSkgfSkgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEdvb2dsZU1hcDtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGluamVjdFNjcmlwdChfYSkge1xuICAgIHZhciB1cmwgPSBfYS51cmwsIGlkID0gX2EuaWQsIG5vbmNlID0gX2Eubm9uY2U7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZG9jdW1lbnQgaXMgdW5kZWZpbmVkJykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gaW5qZWN0U2NyaXB0Q2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBleGlzdGluZ1NjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgdmFyIHdpbmRvd1dpdGhHb29nbGVNYXAgPSB3aW5kb3c7XG4gICAgICAgIGlmIChleGlzdGluZ1NjcmlwdCkge1xuICAgICAgICAgICAgLy8gU2FtZSBzY3JpcHQgaWQvdXJsOiBrZWVwIHNhbWUgc2NyaXB0XG4gICAgICAgICAgICB2YXIgZGF0YVN0YXRlQXR0cmlidXRlID0gZXhpc3RpbmdTY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJyk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdTY3JpcHQuc3JjID09PSB1cmwgJiYgZGF0YVN0YXRlQXR0cmlidXRlICE9PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTdGF0ZUF0dHJpYnV0ZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxJbml0TWFwXzEgPSB3aW5kb3dXaXRoR29vZ2xlTWFwLmluaXRNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVycm9yQ2FsbGJhY2tfMSA9IGV4aXN0aW5nU2NyaXB0Lm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1dpdGhHb29nbGVNYXAuaW5pdE1hcCA9IGZ1bmN0aW9uIGluaXRNYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbml0TWFwXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluaXRNYXBfMSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvckNhbGxiYWNrXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yQ2FsbGJhY2tfMShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYW1lIHNjcmlwdCBpZCwgYnV0IGVpdGhlclxuICAgICAgICAgICAgLy8gMS4gcmVxdWVzdGVkIFVSTCBpcyBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIDIuIHNjcmlwdCBmYWlsZWQgdG8gbG9hZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdTY3JpcHQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICBzY3JpcHQuaWQgPSBpZDtcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Lm5vbmNlID0gbm9uY2UgfHwgJyc7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dXaXRoR29vZ2xlTWFwLmluaXRNYXAgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ3JlYWR5Jyk7XG4gICAgICAgICAgICByZXNvbHZlKGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignaW5qZWN0U2NyaXB0IGVycm9yOiAnLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzR29vZ2xlRm9udFN0eWxlKGVsZW1lbnQpIHtcbiAgICAvLyAnUm9ib3RvJyBvciAnR29vZ2xlIFNhbnMgVGV4dCcgZm9udCBkb3dubG9hZFxuICAgIHZhciBocmVmID0gZWxlbWVudC5ocmVmO1xuICAgIGlmIChocmVmICYmIChocmVmLmluZGV4T2YoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG8nKSA9PT0gMCB8fFxuICAgICAgICBocmVmLmluZGV4T2YoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Hb29nbGUrU2FucytUZXh0JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBmb250IHN0eWxlIGVsZW1lbnRzXG4gICAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdHlsZScgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVTaGVldCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0LnJlcGxhY2UoJ1xcclxcbicsICcnKS5pbmRleE9mKCcuZ20tc3R5bGUnKSA9PT0gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSAnJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGZvbnQgc3R5bGUgZWxlbWVudHMgZm9yIG90aGVyIGJyb3dzZXJzXG4gICAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdHlsZScgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKCdcXHJcXG4nLCAnJykuaW5kZXhPZignLmdtLXN0eWxlJykgPT09IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyB3aGVuIGdvb2dsZSB0cmllcyB0byBhZGQgZW1wdHkgc3R5bGVcbiAgICBpZiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0eWxlJyAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgIWVsZW1lbnQuc3R5bGVTaGVldCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgIWVsZW1lbnQuaW5uZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBQcmV2ZW50aW5nIHRoZSBHb29nbGUgTWFwcyBsaWJyYXJ5IGZyb20gZG93bmxvYWRpbmcgYW4gZXh0cmEgZm9udFxuZnVuY3Rpb24gcHJldmVudEdvb2dsZUZvbnRzKCkge1xuICAgIC8vIHdlIG92ZXJyaWRlIHRoZXNlIG1ldGhvZHMgb25seSBmb3Igb25lIHBhcnRpY3VsYXIgaGVhZCBlbGVtZW50XG4gICAgLy8gZGVmYXVsdCBtZXRob2RzIGZvciBvdGhlciBlbGVtZW50cyBhcmUgbm90IGFmZmVjdGVkXG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGlmIChoZWFkKSB7XG4gICAgICAgIHZhciB0cnVlSW5zZXJ0QmVmb3JlXzEgPSBoZWFkLmluc2VydEJlZm9yZS5iaW5kKGhlYWQpO1xuICAgICAgICAvLyBUT0RPOiBhZGRpbmcgcmV0dXJuIGJlZm9yZSByZWZsZWN0IHNvbHZlcyB0aGUgVFMgaXNzdWVcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFpc0dvb2dsZUZvbnRTdHlsZShuZXdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuYXBwbHkodHJ1ZUluc2VydEJlZm9yZV8xLCBoZWFkLCBbbmV3RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cnVlQXBwZW5kXzEgPSBoZWFkLmFwcGVuZENoaWxkLmJpbmQoaGVhZCk7XG4gICAgICAgIC8vIFRPRE86IGFkZGluZyByZXR1cm4gYmVmb3JlIHJlZmxlY3Qgc29sdmVzIHRoZSBUUyBpc3N1ZVxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQodGV4dE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghaXNHb29nbGVGb250U3R5bGUodGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5hcHBseSh0cnVlQXBwZW5kXzEsIGhlYWQsIFt0ZXh0Tm9kZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUxvYWRTY3JpcHRVcmwoX2EpIHtcbiAgICB2YXIgZ29vZ2xlTWFwc0FwaUtleSA9IF9hLmdvb2dsZU1hcHNBcGlLZXksIGdvb2dsZU1hcHNDbGllbnRJZCA9IF9hLmdvb2dsZU1hcHNDbGllbnRJZCwgX2IgPSBfYS52ZXJzaW9uLCB2ZXJzaW9uID0gX2IgPT09IHZvaWQgMCA/ICd3ZWVrbHknIDogX2IsIGxhbmd1YWdlID0gX2EubGFuZ3VhZ2UsIHJlZ2lvbiA9IF9hLnJlZ2lvbiwgbGlicmFyaWVzID0gX2EubGlicmFyaWVzLCBjaGFubmVsID0gX2EuY2hhbm5lbCwgbWFwSWRzID0gX2EubWFwSWRzLCBhdXRoUmVmZXJyZXJQb2xpY3kgPSBfYS5hdXRoUmVmZXJyZXJQb2xpY3k7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIGludmFyaWFudCQxKChnb29nbGVNYXBzQXBpS2V5ICYmIGdvb2dsZU1hcHNDbGllbnRJZCkgfHwgIShnb29nbGVNYXBzQXBpS2V5ICYmIGdvb2dsZU1hcHNDbGllbnRJZCksICdZb3UgbmVlZCB0byBzcGVjaWZ5IGVpdGhlciBnb29nbGVNYXBzQXBpS2V5IG9yIGdvb2dsZU1hcHNDbGllbnRJZCBmb3IgQHJlYWN0LWdvb2dsZS1tYXBzL2FwaSBsb2FkIHNjcmlwdCB0byB3b3JrLiBZb3UgY2Fubm90IHVzZSBib3RoIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gICAgaWYgKGdvb2dsZU1hcHNBcGlLZXkpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJrZXk9XCIuY29uY2F0KGdvb2dsZU1hcHNBcGlLZXkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ29vZ2xlTWFwc0NsaWVudElkKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiY2xpZW50PVwiLmNvbmNhdChnb29nbGVNYXBzQ2xpZW50SWQpKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJ2PVwiLmNvbmNhdCh2ZXJzaW9uKSk7XG4gICAgfVxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICBwYXJhbXMucHVzaChcImxhbmd1YWdlPVwiLmNvbmNhdChsYW5ndWFnZSkpO1xuICAgIH1cbiAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwicmVnaW9uPVwiLmNvbmNhdChyZWdpb24pKTtcbiAgICB9XG4gICAgaWYgKGxpYnJhcmllcyAmJiBsaWJyYXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwibGlicmFyaWVzPVwiLmNvbmNhdChsaWJyYXJpZXMuc29ydCgpLmpvaW4oJywnKSkpO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImNoYW5uZWw9XCIuY29uY2F0KGNoYW5uZWwpKTtcbiAgICB9XG4gICAgaWYgKG1hcElkcyAmJiBtYXBJZHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwibWFwX2lkcz1cIi5jb25jYXQobWFwSWRzLmpvaW4oJywnKSkpO1xuICAgIH1cbiAgICBpZiAoYXV0aFJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiYXV0aF9yZWZlcnJlcl9wb2xpY3k9XCIuY29uY2F0KGF1dGhSZWZlcnJlclBvbGljeSkpO1xuICAgIH1cbiAgICBwYXJhbXMucHVzaCgnY2FsbGJhY2s9aW5pdE1hcCcpO1xuICAgIHJldHVybiBcImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz9cIi5jb25jYXQocGFyYW1zLmpvaW4oJyYnKSk7XG59XG5cbnZhciBjbGVhbmluZ1VwID0gZmFsc2U7XG5mdW5jdGlvbiBEZWZhdWx0TG9hZGluZ0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGpzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHsgY2hpbGRyZW46IFwiTG9hZGluZy4uLlwiIH0pO1xufVxudmFyIGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMgPSB7XG4gICAgaWQ6ICdzY3JpcHQtbG9hZGVyJyxcbiAgICB2ZXJzaW9uOiAnd2Vla2x5Jyxcbn07XG52YXIgTG9hZFNjcmlwdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9hZFNjcmlwdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2FkU2NyaXB0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hlY2sgPSByZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jbGVhbnVwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkZWxldGUgd2luZG93Lmdvb2dsZS5tYXBzO1xuICAgICAgICAgICAgX3RoaXMuaW5qZWN0U2NyaXB0KCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzQ2xlYW5pbmdVcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlciQxKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJvbWlzZUNhbGxiYWNrKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsZWFuaW5nVXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVyXzEgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gaW50ZXJ2YWwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGVhbmluZ1VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShwcm9taXNlQ2FsbGJhY2spXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICAgICAgX3RoaXMuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFuaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF90aGlzLnByb3BzLmlkKTtcbiAgICAgICAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAgICAgLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NyaXB0LnNyYyA9PT0gJ3N0cmluZycgJiYgc2NyaXB0LnNyYy5pbmNsdWRlcygnbWFwcy5nb29nbGVhcGlzJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2goc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyKGxpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxpbmsuaHJlZiA9PT0gJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG86MzAwLDQwMCw1MDAsNzAwfEdvb2dsZStTYW5zJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2gobGluaykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAgICAgLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHN0eWxlLmlubmVyVGV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmlubmVyVGV4dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmlubmVyVGV4dC5pbmNsdWRlcygnLmdtLScpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbmplY3RTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIHByZXZlbnRHb29nbGVGb250cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW52YXJpYW50JDEoISFfdGhpcy5wcm9wcy5pZCwgJ0xvYWRTY3JpcHQgcmVxdWlyZXMgXCJpZFwiIHByb3AgdG8gYmUgYSBzdHJpbmc6ICVzJywgX3RoaXMucHJvcHMuaWQpO1xuICAgICAgICAgICAgdmFyIGluamVjdFNjcmlwdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IF90aGlzLnByb3BzLmlkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBfdGhpcy5wcm9wcy5ub25jZSxcbiAgICAgICAgICAgICAgICB1cmw6IG1ha2VMb2FkU2NyaXB0VXJsKF90aGlzLnByb3BzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbmplY3RTY3JpcHQoaW5qZWN0U2NyaXB0T3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG9hZGVkKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcXG4gICAgICAgICAgVGhlcmUgaGFzIGJlZW4gYW4gRXJyb3Igd2l0aCBsb2FkaW5nIEdvb2dsZSBNYXBzIEFQSSBzY3JpcHQsIHBsZWFzZSBjaGVjayB0aGF0IHlvdSBwcm92aWRlZCBjb3JyZWN0IGdvb2dsZSBBUEkga2V5IChcIi5jb25jYXQoX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgLnByb3BzLmdvb2dsZU1hcHNBcGlLZXkgfHwgJy0nLCBcIikgb3IgQ2xpZW50IElEIChcIikuY29uY2F0KF90aGlzLnByb3BzLmdvb2dsZU1hcHNDbGllbnRJZCB8fFxuICAgICAgICAgICAgICAgICAgICAnLScsIFwiKSB0byA8TG9hZFNjcmlwdCAvPlxcbiAgICAgICAgICBPdGhlcndpc2UgaXQgaXMgYSBOZXR3b3JrIGlzc3VlLlxcbiAgICAgICAgXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvYWRTY3JpcHQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgIWNsZWFuaW5nVXApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnb29nbGUgYXBpIGlzIGFscmVhZHkgcHJlc2VudGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0NsZWFuaW5nVXAoKVxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuaW5qZWN0U2NyaXB0KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhdCBpbmplY3Rpbmcgc2NyaXB0IGFmdGVyIGNsZWFuaW5nIHVwOiAnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvYWRTY3JpcHQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubGlicmFyaWVzICE9PSBwcmV2UHJvcHMubGlicmFyaWVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIHdhcm5pbmchIExvYWRTY3JpcHQgaGFzIGJlZW4gcmVsb2FkZWQgdW5pbnRlbnRpb25hbGx5ISBZb3Ugc2hvdWxkIG5vdCBwYXNzIGBsaWJyYXJpZXNgIHByb3AgYXMgbmV3IGFycmF5LiBQbGVhc2Uga2VlcCBhbiBhcnJheSBvZiBsaWJyYXJpZXMgYXMgc3RhdGljIGNsYXNzIHByb3BlcnR5IGZvciBDb21wb25lbnRzIGFuZCBQdXJlQ29tcG9uZW50cywgb3IganVzdCBhIGNvbnN0IHZhcmlhYmxlIG91dHNpZGUgb2YgY29tcG9uZW50LCBvciBzb21ld2hlcmUgaW4gY29uZmlnIGZpbGVzIG9yIEVOViB2YXJpYWJsZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyICYmIHByZXZQcm9wcy5sYW5ndWFnZSAhPT0gdGhpcy5wcm9wcy5sYW5ndWFnZSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0byB1c2UgZ0RTRlAgbWF5YmUuLi4gd2FpdCBmb3IgaG9va3MgcmVmYWN0b3JpbmcuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldExvYWRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzLmNsZWFudXBDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvYWRTY3JpcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5jaGVjay5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93Lmdvb2dsZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5pbmdVcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9hZFNjcmlwdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4cyhqc3hSdW50aW1lLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goXCJkaXZcIiwgeyByZWY6IHRoaXMuY2hlY2sgfSksIHRoaXMuc3RhdGUubG9hZGVkXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMubG9hZGluZ0VsZW1lbnQgfHwganN4UnVudGltZS5qc3goRGVmYXVsdExvYWRpbmdFbGVtZW50LCB7fSldIH0pKTtcbiAgICB9O1xuICAgIExvYWRTY3JpcHQuZGVmYXVsdFByb3BzID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcztcbiAgICByZXR1cm4gTG9hZFNjcmlwdDtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtcmVnZXggKi9cbnZhciBwcmV2aW91c2x5TG9hZGVkVXJsO1xuZnVuY3Rpb24gdXNlTG9hZFNjcmlwdChfYSkge1xuICAgIHZhciBfYiA9IF9hLmlkLCBpZCA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0TG9hZFNjcmlwdFByb3BzLmlkIDogX2IsIF9jID0gX2EudmVyc2lvbiwgdmVyc2lvbiA9IF9jID09PSB2b2lkIDAgPyBkZWZhdWx0TG9hZFNjcmlwdFByb3BzLnZlcnNpb24gOiBfYywgbm9uY2UgPSBfYS5ub25jZSwgZ29vZ2xlTWFwc0FwaUtleSA9IF9hLmdvb2dsZU1hcHNBcGlLZXksIGdvb2dsZU1hcHNDbGllbnRJZCA9IF9hLmdvb2dsZU1hcHNDbGllbnRJZCwgbGFuZ3VhZ2UgPSBfYS5sYW5ndWFnZSwgcmVnaW9uID0gX2EucmVnaW9uLCBsaWJyYXJpZXMgPSBfYS5saWJyYXJpZXMsIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcgPSBfYS5wcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nLCBjaGFubmVsID0gX2EuY2hhbm5lbCwgbWFwSWRzID0gX2EubWFwSWRzLCBhdXRoUmVmZXJyZXJQb2xpY3kgPSBfYS5hdXRoUmVmZXJyZXJQb2xpY3k7XG4gICAgdmFyIGlzTW91bnRlZCA9IHJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdmFyIF9kID0gcmVhY3QudXNlU3RhdGUoZmFsc2UpLCBpc0xvYWRlZCA9IF9kWzBdLCBzZXRMb2FkZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSByZWFjdC51c2VTdGF0ZSh1bmRlZmluZWQpLCBsb2FkRXJyb3IgPSBfZVswXSwgc2V0TG9hZEVycm9yID0gX2VbMV07XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIHRyYWNrTW91bnRlZFN0YXRlKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gYXBwbHlQcmV2ZW50R29vZ2xlRm9udHMoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZ10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiB2YWxpZGF0ZUxvYWRlZFN0YXRlKCkge1xuICAgICAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgICAgICAgIGludmFyaWFudCQxKCEhd2luZG93Lmdvb2dsZSwgJ3VzZUxvYWRTY3JpcHQgd2FzIG1hcmtlZCBhcyBsb2FkZWQsIGJ1dCB3aW5kb3cuZ29vZ2xlIGlzIG5vdCBwcmVzZW50LiBTb21ldGhpbmcgd2VudCB3cm9uZy4nKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0xvYWRlZF0pO1xuICAgIHZhciB1cmwgPSBtYWtlTG9hZFNjcmlwdFVybCh7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIGdvb2dsZU1hcHNBcGlLZXk6IGdvb2dsZU1hcHNBcGlLZXksXG4gICAgICAgIGdvb2dsZU1hcHNDbGllbnRJZDogZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICBsaWJyYXJpZXM6IGxpYnJhcmllcyxcbiAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgbWFwSWRzOiBtYXBJZHMsXG4gICAgICAgIGF1dGhSZWZlcnJlclBvbGljeTogYXV0aFJlZmVycmVyUG9saWN5XG4gICAgfSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIGxvYWRTY3JpcHRBbmRNb2RpZnlMb2FkZWRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRMb2FkZWRJZk1vdW50ZWQoKSB7XG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNseUxvYWRlZFVybCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgcHJldmlvdXNseUxvYWRlZFVybCA9PT0gdXJsKSB7XG4gICAgICAgICAgICBzZXRMb2FkZWRJZk1vdW50ZWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbmplY3RTY3JpcHQoeyBpZDogaWQsIHVybDogdXJsLCBub25jZTogbm9uY2UgfSlcbiAgICAgICAgICAgIC50aGVuKHNldExvYWRlZElmTW91bnRlZClcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiBoYW5kbGVJbmplY3RFcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldExvYWRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXFxuICAgICAgICBUaGVyZSBoYXMgYmVlbiBhbiBFcnJvciB3aXRoIGxvYWRpbmcgR29vZ2xlIE1hcHMgQVBJIHNjcmlwdCwgcGxlYXNlIGNoZWNrIHRoYXQgeW91IHByb3ZpZGVkIGNvcnJlY3QgZ29vZ2xlIEFQSSBrZXkgKFwiLmNvbmNhdChnb29nbGVNYXBzQXBpS2V5IHx8XG4gICAgICAgICAgICAgICAgJy0nLCBcIikgb3IgQ2xpZW50IElEIChcIikuY29uY2F0KGdvb2dsZU1hcHNDbGllbnRJZCB8fCAnLScsIFwiKVxcbiAgICAgICAgT3RoZXJ3aXNlIGl0IGlzIGEgTmV0d29yayBpc3N1ZS5cXG4gICAgICBcIikpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBbaWQsIHVybCwgbm9uY2VdKTtcbiAgICB2YXIgcHJldkxpYnJhcmllcyA9IHJlYWN0LnVzZVJlZigpO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiBjaGVja1BlcmZvcm1hbmNlKCkge1xuICAgICAgICBpZiAocHJldkxpYnJhcmllcy5jdXJyZW50ICYmIGxpYnJhcmllcyAhPT0gcHJldkxpYnJhcmllcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIHdhcm5pbmchIExvYWRTY3JpcHQgaGFzIGJlZW4gcmVsb2FkZWQgdW5pbnRlbnRpb25hbGx5ISBZb3Ugc2hvdWxkIG5vdCBwYXNzIGBsaWJyYXJpZXNgIHByb3AgYXMgbmV3IGFycmF5LiBQbGVhc2Uga2VlcCBhbiBhcnJheSBvZiBsaWJyYXJpZXMgYXMgc3RhdGljIGNsYXNzIHByb3BlcnR5IGZvciBDb21wb25lbnRzIGFuZCBQdXJlQ29tcG9uZW50cywgb3IganVzdCBhIGNvbnN0IHZhcmlhYmxlIG91dHNpZGUgb2YgY29tcG9uZW50LCBvciBzb21ld2hlcmUgaW4gY29uZmlnIGZpbGVzIG9yIEVOViB2YXJpYWJsZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2TGlicmFyaWVzLmN1cnJlbnQgPSBsaWJyYXJpZXM7XG4gICAgfSwgW2xpYnJhcmllc10pO1xuICAgIHJldHVybiB7IGlzTG9hZGVkOiBpc0xvYWRlZCwgbG9hZEVycm9yOiBsb2FkRXJyb3IsIHVybDogdXJsIH07XG59XG5cbnZhciBkZWZhdWx0TG9hZGluZ0VsZW1lbnQgPSBqc3hSdW50aW1lLmpzeChEZWZhdWx0TG9hZGluZ0VsZW1lbnQsIHt9KTtcbmZ1bmN0aW9uIExvYWRTY3JpcHROZXh0KF9hKSB7XG4gICAgdmFyIGxvYWRpbmdFbGVtZW50ID0gX2EubG9hZGluZ0VsZW1lbnQsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25FcnJvciA9IF9hLm9uRXJyb3IsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaG9va09wdGlvbnMgPSBfX3Jlc3QkMShfYSwgW1wibG9hZGluZ0VsZW1lbnRcIiwgXCJvbkxvYWRcIiwgXCJvbkVycm9yXCIsIFwib25Vbm1vdW50XCIsIFwiY2hpbGRyZW5cIl0pO1xuICAgIHZhciBfYiA9IHVzZUxvYWRTY3JpcHQoaG9va09wdGlvbnMpLCBpc0xvYWRlZCA9IF9iLmlzTG9hZGVkLCBsb2FkRXJyb3IgPSBfYi5sb2FkRXJyb3I7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIGhhbmRsZU9uTG9hZCgpIHtcbiAgICAgICAgaWYgKGlzTG9hZGVkICYmIHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgfSwgW2lzTG9hZGVkLCBvbkxvYWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gaGFuZGxlT25FcnJvcigpIHtcbiAgICAgICAgaWYgKGxvYWRFcnJvciAmJiB0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25FcnJvcihsb2FkRXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgW2xvYWRFcnJvciwgb25FcnJvcl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiBoYW5kbGVPblVubW91bnQoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgb25Vbm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW29uVW5tb3VudF0pO1xuICAgIHJldHVybiBpc0xvYWRlZCA/IGNoaWxkcmVuIDogbG9hZGluZ0VsZW1lbnQgfHwgZGVmYXVsdExvYWRpbmdFbGVtZW50O1xufVxudmFyIExvYWRTY3JpcHROZXh0JDEgPSByZWFjdC5tZW1vKExvYWRTY3JpcHROZXh0KTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG52YXIgZmFzdERlZXBFcXVhbCQxID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0LlxuICpcbiAqICAgICAgSHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSUQgPSBcIl9fZ29vZ2xlTWFwc1NjcmlwdElkXCI7XG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIFtbTG9hZGVyXV0uXG4gKi9cbnZhciBMb2FkZXJTdGF0dXM7XG4oZnVuY3Rpb24gKExvYWRlclN0YXR1cykge1xuICAgIExvYWRlclN0YXR1c1tMb2FkZXJTdGF0dXNbXCJJTklUSUFMSVpFRFwiXSA9IDBdID0gXCJJTklUSUFMSVpFRFwiO1xuICAgIExvYWRlclN0YXR1c1tMb2FkZXJTdGF0dXNbXCJMT0FESU5HXCJdID0gMV0gPSBcIkxPQURJTkdcIjtcbiAgICBMb2FkZXJTdGF0dXNbTG9hZGVyU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDJdID0gXCJTVUNDRVNTXCI7XG4gICAgTG9hZGVyU3RhdHVzW0xvYWRlclN0YXR1c1tcIkZBSUxVUkVcIl0gPSAzXSA9IFwiRkFJTFVSRVwiO1xufSkoTG9hZGVyU3RhdHVzIHx8IChMb2FkZXJTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBbW0xvYWRlcl1dIG1ha2VzIGl0IGVhc2llciB0byBhZGQgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgdG8geW91ciBhcHBsaWNhdGlvblxuICogZHluYW1pY2FsbHkgdXNpbmdcbiAqIFtQcm9taXNlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZSkuXG4gKiBJdCB3b3JrcyBieSBkeW5hbWljYWxseSBjcmVhdGluZyBhbmQgYXBwZW5kaW5nIGEgc2NyaXB0IG5vZGUgdG8gdGhlIHRoZVxuICogZG9jdW1lbnQgaGVhZCBhbmQgd3JhcHBpbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHNvIGFzIHRvIHJldHVybiBhIHByb21pc2UuXG4gKlxuICogYGBgXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgTG9hZGVyKHtcbiAqICAgYXBpS2V5OiBcIlwiLFxuICogICB2ZXJzaW9uOiBcIndlZWtseVwiLFxuICogICBsaWJyYXJpZXM6IFtcInBsYWNlc1wiXVxuICogfSk7XG4gKlxuICogbG9hZGVyLmxvYWQoKS50aGVuKChnb29nbGUpID0+IHtcbiAqICAgY29uc3QgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcCguLi4pXG4gKiB9KVxuICogYGBgXG4gKi9cbmNsYXNzIExvYWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMb2FkZXIgdXNpbmcgW1tMb2FkZXJPcHRpb25zXV0uIE5vIGRlZmF1bHRzIGFyZSBzZXRcbiAgICAgKiB1c2luZyB0aGlzIGxpYnJhcnksIGluc3RlYWQgdGhlIGRlZmF1bHRzIGFyZSBzZXQgYnkgdGhlIEdvb2dsZSBNYXBzXG4gICAgICogSmF2YVNjcmlwdCBBUEkgc2VydmVyLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbG9hZGVyID0gTG9hZGVyKHthcGlLZXksIHZlcnNpb246ICd3ZWVrbHknLCBsaWJyYXJpZXM6IFsncGxhY2VzJ119KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGFwaUtleSwgYXV0aFJlZmVycmVyUG9saWN5LCBjaGFubmVsLCBjbGllbnQsIGlkID0gREVGQVVMVF9JRCwgbGFuZ3VhZ2UsIGxpYnJhcmllcyA9IFtdLCBtYXBJZHMsIG5vbmNlLCByZWdpb24sIHJldHJpZXMgPSAzLCB1cmwgPSBcImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qc1wiLCB2ZXJzaW9uLCB9KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuYXV0aFJlZmVycmVyUG9saWN5ID0gYXV0aFJlZmVycmVyUG9saWN5O1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5pZCA9IGlkIHx8IERFRkFVTFRfSUQ7IC8vIERvIG5vdCBhbGxvdyBlbXB0eSBzdHJpbmdcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLmxpYnJhcmllcyA9IGxpYnJhcmllcztcbiAgICAgICAgdGhpcy5tYXBJZHMgPSBtYXBJZHM7XG4gICAgICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBpZiAoTG9hZGVyLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoIWZhc3REZWVwRXF1YWwkMSh0aGlzLm9wdGlvbnMsIExvYWRlci5pbnN0YW5jZS5vcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9hZGVyIG11c3Qgbm90IGJlIGNhbGxlZCBhZ2FpbiB3aXRoIGRpZmZlcmVudCBvcHRpb25zLiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9ICE9PSAke0pTT04uc3RyaW5naWZ5KExvYWRlci5pbnN0YW5jZS5vcHRpb25zKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMb2FkZXIuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgTG9hZGVyLmluc3RhbmNlID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGlicmFyaWVzOiB0aGlzLmxpYnJhcmllcyxcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgICAgICAgIG1hcElkczogdGhpcy5tYXBJZHMsXG4gICAgICAgICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBhdXRoUmVmZXJyZXJQb2xpY3k6IHRoaXMuYXV0aFJlZmVycmVyUG9saWN5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyU3RhdHVzLkZBSUxVUkU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIExvYWRlclN0YXR1cy5TVUNDRVNTO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2FkZXJTdGF0dXMuTE9BRElORztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTG9hZGVyU3RhdHVzLklOSVRJQUxJWkVEO1xuICAgIH1cbiAgICBnZXQgZmFpbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb25lICYmICF0aGlzLmxvYWRpbmcgJiYgdGhpcy5lcnJvcnMubGVuZ3RoID49IHRoaXMucmV0cmllcyArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZVVybCByZXR1cm5zIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgdXJsIGdpdmVuIHRoZSBbW0xvYWRlck9wdGlvbnNdXS5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGNyZWF0ZVVybCgpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsO1xuICAgICAgICB1cmwgKz0gYD9jYWxsYmFjaz1fX2dvb2dsZU1hcHNDYWxsYmFja2A7XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgdXJsICs9IGAma2V5PSR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZjaGFubmVsPSR7dGhpcy5jaGFubmVsfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZjbGllbnQ9JHt0aGlzLmNsaWVudH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpYnJhcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZsaWJyYXJpZXM9JHt0aGlzLmxpYnJhcmllcy5qb2luKFwiLFwiKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZsYW5ndWFnZT0ke3RoaXMubGFuZ3VhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWdpb24pIHtcbiAgICAgICAgICAgIHVybCArPSBgJnJlZ2lvbj0ke3RoaXMucmVnaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbikge1xuICAgICAgICAgICAgdXJsICs9IGAmdj0ke3RoaXMudmVyc2lvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcElkcykge1xuICAgICAgICAgICAgdXJsICs9IGAmbWFwX2lkcz0ke3RoaXMubWFwSWRzLmpvaW4oXCIsXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0aFJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZhdXRoX3JlZmVycmVyX3BvbGljeT0ke3RoaXMuYXV0aFJlZmVycmVyUG9saWN5fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgZGVsZXRlU2NyaXB0KCkge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgKiBAZGVwcmVjYXRlZCwgdXNlIGltcG9ydExpYnJhcnkoKSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9taXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAZGVwcmVjYXRlZCwgdXNlIGltcG9ydExpYnJhcnkoKSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGxvYWRQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkQ2FsbGJhY2soKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93Lmdvb2dsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcG9ydExpYnJhcnkobmFtZSkge1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCB3aXRoIGEgY2FsbGJhY2suXG4gICAgICogQGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRMaWJyYXJ5KCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBsb2FkQ2FsbGJhY2soZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChmbik7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNjcmlwdCBvbiBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBzZXRTY3JpcHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSkge1xuICAgICAgICAgICAgLy8gVE9ETyB3cmFwIG9uZXJyb3IgY2FsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZSBzY3JpcHQgd2FzIGxvYWRlZCBlbHNld2hlcmVcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBrZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIGxpYnJhcmllczogdGhpcy5saWJyYXJpZXMubGVuZ3RoICYmIHRoaXMubGlicmFyaWVzLFxuICAgICAgICAgICAgdjogdGhpcy52ZXJzaW9uLFxuICAgICAgICAgICAgbWFwSWRzOiB0aGlzLm1hcElkcyxcbiAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgICAgICAgIGF1dGhSZWZlcnJlclBvbGljeTogdGhpcy5hdXRoUmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGtlZXAgdGhlIFVSTCBtaW5pbWFsOlxuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChrZXkpID0+ICFwYXJhbXNba2V5XSAmJiBkZWxldGUgcGFyYW1zW2tleV0pO1xuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuZ29vZ2xlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmltcG9ydExpYnJhcnkpKSB7XG4gICAgICAgICAgICAvLyB0d2Vha2VkIGNvcHkgb2YgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbG9hZC1tYXBzLWpzLWFwaSNkeW5hbWljLWxpYnJhcnktaW1wb3J0XG4gICAgICAgICAgICAvLyB3aGljaCBhbHNvIHNldHMgdGhlIGJhc2UgdXJsLCB0aGUgaWQsIGFuZCB0aGUgbm9uY2VcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICAgICAgICAoKGcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbGV0IGgsIGEsIGssIHAgPSBcIlRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSVwiLCBjID0gXCJnb29nbGVcIiwgbCA9IFwiaW1wb3J0TGlicmFyeVwiLCBxID0gXCJfX2liX19cIiwgbSA9IGRvY3VtZW50LCBiID0gd2luZG93O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBiID0gYltjXSB8fCAoYltjXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGIubWFwcyB8fCAoYi5tYXBzID0ge30pLCByID0gbmV3IFNldCgpLCBlID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB1ID0gKCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGggfHwgKGggPSBuZXcgUHJvbWlzZSgoZiwgbikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIChhID0gbS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgYS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0KFwibGlicmFyaWVzXCIsIFsuLi5yXSArIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiBnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zZXQoay5yZXBsYWNlKC9bQS1aXS9nLCAodCkgPT4gXCJfXCIgKyB0WzBdLnRvTG93ZXJDYXNlKCkpLCBnW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXQoXCJjYWxsYmFja1wiLCBjICsgXCIubWFwcy5cIiArIHEpO1xuICAgICAgICAgICAgICAgICAgICBhLnNyYyA9IHRoaXMudXJsICsgYD9gICsgZTtcbiAgICAgICAgICAgICAgICAgICAgZFtxXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgIGEub25lcnJvciA9ICgpID0+IChoID0gbihFcnJvcihwICsgXCIgY291bGQgbm90IGxvYWQuXCIpKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgYS5ub25jZSA9IHRoaXMubm9uY2UgfHwgKChfYSA9IG0ucXVlcnlTZWxlY3RvcihcInNjcmlwdFtub25jZV1cIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub25jZSkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbS5oZWFkLmFwcGVuZChhKTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkW2xdID8gY29uc29sZS53YXJuKHAgKyBcIiBvbmx5IGxvYWRzIG9uY2UuIElnbm9yaW5nOlwiLCBnKSA6IChkW2xdID0gKGYsIC4uLm4pID0+IHIuYWRkKGYpICYmIHUoKS50aGVuKCgpID0+IGRbbF0oZiwgLi4ubikpKTtcbiAgICAgICAgICAgIH0pKHBhcmFtcyk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpbGUgbW9zdCBsaWJyYXJpZXMgcG9wdWxhdGUgdGhlIGdsb2JhbCBuYW1lc3BhY2Ugd2hlbiBsb2FkZWQgdmlhIGJvb3RzdHJhcCBwYXJhbXMsXG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciBcIm1hcmtlclwiIHdoZW4gdXNlZCB3aXRoIHRoZSBpbmxpbmUgYm9vdHN0cmFwIGxvYWRlclxuICAgICAgICAvLyAoYW5kIG1heWJlIG90aGVycyBpbiB0aGUgZnV0dXJlKS4gU28gZW5zdXJlIHRoZXJlIGlzIGFuIGltcG9ydExpYnJhcnkgZm9yIGVhY2g6XG4gICAgICAgIGNvbnN0IGxpYnJhcnlQcm9taXNlcyA9IHRoaXMubGlicmFyaWVzLm1hcCgobGlicmFyeSkgPT4gdGhpcy5pbXBvcnRMaWJyYXJ5KGxpYnJhcnkpKTtcbiAgICAgICAgLy8gZW5zdXJlIGF0IGxlYXN0IG9uZSBsaWJyYXJ5LCB0byBraWNrIG9mZiBsb2FkaW5nLi4uXG4gICAgICAgIGlmICghbGlicmFyeVByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGlicmFyeVByb21pc2VzLnB1c2godGhpcy5pbXBvcnRMaWJyYXJ5KFwiY29yZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5hbGwobGlicmFyeVByb21pc2VzKS50aGVuKCgpID0+IHRoaXMuY2FsbGJhY2soKSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBlcnJvciB9KTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICAgICAgICAgIHRoaXMubG9hZEVycm9yQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGxvYWRlciBzdGF0ZS5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5kZWxldGVTY3JpcHQoKTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLm9uZXJyb3JFdmVudCA9IG51bGw7XG4gICAgfVxuICAgIHJlc2V0SWZSZXRyeWluZ0ZhaWxlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmFpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZEVycm9yQ2FsbGJhY2soZSkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUpO1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoIDw9IHRoaXMucmV0cmllcykge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmVycm9ycy5sZW5ndGggKiBNYXRoLnBvdygyLCB0aGlzLmVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgR29vZ2xlIE1hcHMgc2NyaXB0LCByZXRyeWluZyBpbiAke2RlbGF5fSBtcy5gKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlU2NyaXB0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTY3JpcHQoKTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25lcnJvckV2ZW50ID0gZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiB7XG4gICAgICAgICAgICBjYih0aGlzLm9uZXJyb3JFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLnJlc2V0SWZSZXRyeWluZ0ZhaWxlZCgpO1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG9ydCBjaXJjdWl0IGFuZCB3YXJuIGlmIGdvb2dsZS5tYXBzIGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgd2luZG93Lmdvb2dsZS5tYXBzLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJHb29nbGUgTWFwcyBhbHJlYWR5IGxvYWRlZCBvdXRzaWRlIEBnb29nbGVtYXBzL2pzLWFwaS1sb2FkZXIuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgbWF5IHJlc3VsdCBpbiB1bmRlc2lyYWJsZSBiZWhhdmlvciBhcyBvcHRpb25zIGFuZCBzY3JpcHQgcGFyYW1ldGVycyBtYXkgbm90IG1hdGNoLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZykgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNjcmlwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdExpYnJhcmllcyA9IFsnbWFwcyddO1xuZnVuY3Rpb24gdXNlSnNBcGlMb2FkZXIoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5pZCwgaWQgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy5pZCA6IF9iLCBfYyA9IF9hLnZlcnNpb24sIHZlcnNpb24gPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy52ZXJzaW9uIDogX2MsIG5vbmNlID0gX2Eubm9uY2UsIGdvb2dsZU1hcHNBcGlLZXkgPSBfYS5nb29nbGVNYXBzQXBpS2V5LCBcbiAgICAvLyBnb29nbGVNYXBzQ2xpZW50SWQsXG4gICAgbGFuZ3VhZ2UgPSBfYS5sYW5ndWFnZSwgcmVnaW9uID0gX2EucmVnaW9uLCBfZCA9IF9hLmxpYnJhcmllcywgbGlicmFyaWVzID0gX2QgPT09IHZvaWQgMCA/IGRlZmF1bHRMaWJyYXJpZXMgOiBfZCwgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZyA9IF9hLnByZXZlbnRHb29nbGVGb250c0xvYWRpbmcsIFxuICAgIC8vIGNoYW5uZWwsXG4gICAgbWFwSWRzID0gX2EubWFwSWRzLCBhdXRoUmVmZXJyZXJQb2xpY3kgPSBfYS5hdXRoUmVmZXJyZXJQb2xpY3k7XG4gICAgdmFyIGlzTW91bnRlZCA9IHJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUoZmFsc2UpLCBpc0xvYWRlZCA9IF9lWzBdLCBzZXRMb2FkZWQgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSByZWFjdC51c2VTdGF0ZSh1bmRlZmluZWQpLCBsb2FkRXJyb3IgPSBfZlswXSwgc2V0TG9hZEVycm9yID0gX2ZbMV07XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uIHRyYWNrTW91bnRlZFN0YXRlKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgbG9hZGVyID0gcmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9hZGVyKHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGFwaUtleTogZ29vZ2xlTWFwc0FwaUtleSxcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgICBsaWJyYXJpZXM6IGxpYnJhcmllcyxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSB8fCAnZW4nLFxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb24gfHwgJ1VTJyxcbiAgICAgICAgICAgIG1hcElkczogbWFwSWRzIHx8IFtdLFxuICAgICAgICAgICAgbm9uY2U6IG5vbmNlIHx8ICcnLFxuICAgICAgICAgICAgYXV0aFJlZmVycmVyUG9saWN5OiBhdXRoUmVmZXJyZXJQb2xpY3kgfHwgJ29yaWdpbicsXG4gICAgICAgIH0pO1xuICAgIH0sIFtpZCwgZ29vZ2xlTWFwc0FwaUtleSwgdmVyc2lvbiwgbGlicmFyaWVzLCBsYW5ndWFnZSwgcmVnaW9uLCBtYXBJZHMsIG5vbmNlLCBhdXRoUmVmZXJyZXJQb2xpY3ldKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gZWZmZWN0KCkge1xuICAgICAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExvYWRlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZ10pO1xuICAgIHZhciBwcmV2TGlicmFyaWVzID0gcmVhY3QudXNlUmVmKCk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByZXZMaWJyYXJpZXMuY3VycmVudCAmJiBsaWJyYXJpZXMgIT09IHByZXZMaWJyYXJpZXMuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQZXJmb3JtYW5jZSB3YXJuaW5nISBMb2FkU2NyaXB0IGhhcyBiZWVuIHJlbG9hZGVkIHVuaW50ZW50aW9uYWxseSEgWW91IHNob3VsZCBub3QgcGFzcyBgbGlicmFyaWVzYCBwcm9wIGFzIG5ldyBhcnJheS4gUGxlYXNlIGtlZXAgYW4gYXJyYXkgb2YgbGlicmFyaWVzIGFzIHN0YXRpYyBjbGFzcyBwcm9wZXJ0eSBmb3IgQ29tcG9uZW50cyBhbmQgUHVyZUNvbXBvbmVudHMsIG9yIGp1c3QgYSBjb25zdCB2YXJpYWJsZSBvdXRzaWRlIG9mIGNvbXBvbmVudCwgb3Igc29tZXdoZXJlIGluIGNvbmZpZyBmaWxlcyBvciBFTlYgdmFyaWFibGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkxpYnJhcmllcy5jdXJyZW50ID0gbGlicmFyaWVzO1xuICAgIH0sIFtsaWJyYXJpZXNdKTtcbiAgICByZXR1cm4geyBpc0xvYWRlZDogaXNMb2FkZWQsIGxvYWRFcnJvcjogbG9hZEVycm9yIH07XG59XG5cbnZhciBldmVudE1hcCRoID0ge307XG52YXIgdXBkYXRlck1hcCRoID0ge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gVHJhZmZpY0xheWVyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYWZmaWNMYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFmZmljTGF5ZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBzZXRJbnN0YW5jZSh0cmFmZmljTGF5ZXIpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQodHJhZmZpY0xheWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvblVubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIFRyYWZmaWNMYXllckYgPSByZWFjdC5tZW1vKFRyYWZmaWNMYXllckZ1bmN0aW9uYWwpO1xudmFyIFRyYWZmaWNMYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhZmZpY0xheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYWZmaWNMYXllcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdHJhZmZpY0xheWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRUcmFmZmljTGF5ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnRyYWZmaWNMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFmZmljTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhZmZpY0xheWVyID0gbmV3IGdvb2dsZS5tYXBzLlRyYWZmaWNMYXllcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGgsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkaCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogdHJhZmZpY0xheWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRUcmFmZmljTGF5ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRyYWZmaWNMYXllcjogdHJhZmZpY0xheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRUcmFmZmljTGF5ZXJDYWxsYmFjayk7XG4gICAgfTtcbiAgICBUcmFmZmljTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudHJhZmZpY0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGgsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGgsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnRyYWZmaWNMYXllcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFmZmljTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUudHJhZmZpY0xheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhZmZpY0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhZmZpY0xheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVHJhZmZpY0xheWVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gVHJhZmZpY0xheWVyO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIEJpY3ljbGluZ0xheWVyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gcmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpY3ljbGluZ0xheWVyID0gbmV3IGdvb2dsZS5tYXBzLkJpY3ljbGluZ0xheWVyKCk7XG4gICAgICAgIHNldEluc3RhbmNlKGJpY3ljbGluZ0xheWVyKTtcbiAgICAgICAgYmljeWNsaW5nTGF5ZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZChiaWN5Y2xpbmdMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChiaWN5Y2xpbmdMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGJpY3ljbGluZ0xheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmljeWNsaW5nTGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBCaWN5Y2xpbmdMYXllckYgPSByZWFjdC5tZW1vKEJpY3ljbGluZ0xheWVyRnVuY3Rpb25hbCk7XG52YXIgQmljeWNsaW5nTGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpY3ljbGluZ0xheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpY3ljbGluZ0xheWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBiaWN5Y2xpbmdMYXllcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0QmljeWNsaW5nTGF5ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyLnNldE1hcChfdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJpY3ljbGluZ0xheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpY3ljbGluZ0xheWVyID0gbmV3IGdvb2dsZS5tYXBzLkJpY3ljbGluZ0xheWVyKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiaWN5Y2xpbmdMYXllcjogYmljeWNsaW5nTGF5ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldEJpY3ljbGluZ0xheWVyQ2FsbGJhY2spO1xuICAgIH07XG4gICAgQmljeWNsaW5nTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmljeWNsaW5nTGF5ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBCaWN5Y2xpbmdMYXllci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEJpY3ljbGluZ0xheWVyO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIFRyYW5zaXRMYXllckZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFuc2l0TGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhbnNpdExheWVyKCk7XG4gICAgICAgIHNldEluc3RhbmNlKHRyYW5zaXRMYXllcik7XG4gICAgICAgIHRyYW5zaXRMYXllci5zZXRNYXAobWFwKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKHRyYW5zaXRMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBUcmFuc2l0TGF5ZXJGID0gcmVhY3QubWVtbyhUcmFuc2l0TGF5ZXJGdW5jdGlvbmFsKTtcbnZhciBUcmFuc2l0TGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYW5zaXRMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc2l0TGF5ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRMYXllcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0VHJhbnNpdExheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUudHJhbnNpdExheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUudHJhbnNpdExheWVyLnNldE1hcChfdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmFuc2l0TGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhbnNpdExheWVyID0gbmV3IGdvb2dsZS5tYXBzLlRyYW5zaXRMYXllcigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFRyYW5zaXRMYXllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdExheWVyOiB0cmFuc2l0TGF5ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFRyYW5zaXRMYXllckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFRyYW5zaXRMYXllci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRyYW5zaXRMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc2l0TGF5ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUcmFuc2l0TGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBUcmFuc2l0TGF5ZXI7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJGcgPSB7XG4gICAgb25DaXJjbGVDb21wbGV0ZTogJ2NpcmNsZWNvbXBsZXRlJyxcbiAgICBvbk1hcmtlckNvbXBsZXRlOiAnbWFya2VyY29tcGxldGUnLFxuICAgIG9uT3ZlcmxheUNvbXBsZXRlOiAnb3ZlcmxheWNvbXBsZXRlJyxcbiAgICBvblBvbHlnb25Db21wbGV0ZTogJ3BvbHlnb25jb21wbGV0ZScsXG4gICAgb25Qb2x5bGluZUNvbXBsZXRlOiAncG9seWxpbmVjb21wbGV0ZScsXG4gICAgb25SZWN0YW5nbGVDb21wbGV0ZTogJ3JlY3RhbmdsZWNvbXBsZXRlJyxcbn07XG52YXIgdXBkYXRlck1hcCRnID0ge1xuICAgIGRyYXdpbmdNb2RlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYXdpbmdNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERyYXdpbmdNb2RlKGRyYXdpbmdNb2RlKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gRHJhd2luZ01hbmFnZXJGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkcmF3aW5nTW9kZSA9IF9hLmRyYXdpbmdNb2RlLCBvbkNpcmNsZUNvbXBsZXRlID0gX2Eub25DaXJjbGVDb21wbGV0ZSwgb25NYXJrZXJDb21wbGV0ZSA9IF9hLm9uTWFya2VyQ29tcGxldGUsIG9uT3ZlcmxheUNvbXBsZXRlID0gX2Eub25PdmVybGF5Q29tcGxldGUsIG9uUG9seWdvbkNvbXBsZXRlID0gX2Eub25Qb2x5Z29uQ29tcGxldGUsIG9uUG9seWxpbmVDb21wbGV0ZSA9IF9hLm9uUG9seWxpbmVDb21wbGV0ZSwgb25SZWN0YW5nbGVDb21wbGV0ZSA9IF9hLm9uUmVjdGFuZ2xlQ29tcGxldGUsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50O1xuICAgIHZhciBtYXAgPSByZWFjdC51c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9iWzBdLCBzZXRJbnN0YW5jZSA9IF9iWzFdO1xuICAgIHZhciBfYyA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjaXJjbGVjb21wbGV0ZUxpc3RlbmVyID0gX2NbMF0sIHNldENpcmNsZUNvbXBsZXRlTGlzdGVuZXIgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbWFya2VyY29tcGxldGVMaXN0ZW5lciA9IF9kWzBdLCBzZXRNYXJrZXJDb21wbGV0ZUxpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG92ZXJsYXljb21wbGV0ZUxpc3RlbmVyID0gX2VbMF0sIHNldE92ZXJsYXlDb21wbGV0ZUxpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyID0gX2ZbMF0sIHNldFBvbHlnb25Db21wbGV0ZUxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHBvbHlsaW5lY29tcGxldGVMaXN0ZW5lciA9IF9nWzBdLCBzZXRQb2x5bGluZUNvbXBsZXRlTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSByZWFjdC51c2VTdGF0ZShudWxsKSwgcmVjdGFuZ2xlY29tcGxldGVMaXN0ZW5lciA9IF9oWzBdLCBzZXRSZWN0YW5nbGVDb21wbGV0ZUxpc3RlbmVyID0gX2hbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRyYXdpbmdNb2RlICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXREcmF3aW5nTW9kZShkcmF3aW5nTW9kZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYXdpbmdNb2RlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2lyY2xlQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChjaXJjbGVjb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2lyY2xlY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaXJjbGVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2lyY2xlY29tcGxldGUnLCBvbkNpcmNsZUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9uQ2lyY2xlQ29tcGxldGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25NYXJrZXJDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtYXJrZXJjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1hcmtlckNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtYXJrZXJjb21wbGV0ZScsIG9uTWFya2VyQ29tcGxldGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb25NYXJrZXJDb21wbGV0ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk92ZXJsYXlDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJsYXljb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIob3ZlcmxheWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0T3ZlcmxheUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdvdmVybGF5Y29tcGxldGUnLCBvbk92ZXJsYXlDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvbk92ZXJsYXlDb21wbGV0ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblBvbHlnb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9seWdvbmNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9seWdvbkNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb2x5Z29uY29tcGxldGUnLCBvblBvbHlnb25Db21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvblBvbHlnb25Db21wbGV0ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblBvbHlsaW5lQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9seWxpbmVjb21wbGV0ZScsIG9uUG9seWxpbmVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvblBvbHlsaW5lQ29tcGxldGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SZWN0YW5nbGVDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZWN0YW5nbGVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJlY3RhbmdsZUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZWN0YW5nbGVjb21wbGV0ZScsIG9uUmVjdGFuZ2xlQ29tcGxldGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb25SZWN0YW5nbGVDb21wbGV0ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhZ29vZ2xlLm1hcHMuZHJhd2luZywgXCJEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1snZHJhd2luZyddfSBpbiB0aGUgVVJMPyAlc1wiLCBnb29nbGUubWFwcy5kcmF3aW5nKTtcbiAgICAgICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAoZHJhd2luZ01vZGUpIHtcbiAgICAgICAgICAgIGRyYXdpbmdNYW5hZ2VyLnNldERyYXdpbmdNb2RlKGRyYXdpbmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DaXJjbGVDb21wbGV0ZSkge1xuICAgICAgICAgICAgc2V0Q2lyY2xlQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ2NpcmNsZWNvbXBsZXRlJywgb25DaXJjbGVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1hcmtlckNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRNYXJrZXJDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAnbWFya2VyY29tcGxldGUnLCBvbk1hcmtlckNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uT3ZlcmxheUNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRPdmVybGF5Q29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ292ZXJsYXljb21wbGV0ZScsIG9uT3ZlcmxheUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUG9seWdvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRQb2x5Z29uQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ3BvbHlnb25jb21wbGV0ZScsIG9uUG9seWdvbkNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUG9seWxpbmVDb21wbGV0ZSkge1xuICAgICAgICAgICAgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncG9seWxpbmVjb21wbGV0ZScsIG9uUG9seWxpbmVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJlY3RhbmdsZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRSZWN0YW5nbGVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncmVjdGFuZ2xlY29tcGxldGUnLCBvblJlY3RhbmdsZUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5zdGFuY2UoZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2lyY2xlY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjaXJjbGVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobWFya2VyY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5Y29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihvdmVybGF5Y29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb2x5Z29uY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9seWxpbmVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVjdGFuZ2xlY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBEcmF3aW5nTWFuYWdlckYgPSByZWFjdC5tZW1vKERyYXdpbmdNYW5hZ2VyRnVuY3Rpb25hbCk7XG52YXIgRHJhd2luZ01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYXdpbmdNYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYXdpbmdNYW5hZ2VyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJhd2luZ01hbmFnZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldERyYXdpbmdNYW5hZ2VyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW52YXJpYW50JDEoISFnb29nbGUubWFwcy5kcmF3aW5nLCBcIkRpZCB5b3UgaW5jbHVkZSBwcm9wIGxpYnJhcmllcz17WydkcmF3aW5nJ119IGluIHRoZSBVUkw/ICVzXCIsIGdvb2dsZS5tYXBzLmRyYXdpbmcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoX19hc3NpZ24oX19hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRnLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGcsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXREcmF3aW5nTWFuYWdlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHJhd2luZ01hbmFnZXI6IGRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREcmF3aW5nTWFuYWdlckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGcsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGcsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRHJhd2luZ01hbmFnZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBEcmF3aW5nTWFuYWdlcjtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkZiA9IHtcbiAgICBvbkFuaW1hdGlvbkNoYW5nZWQ6ICdhbmltYXRpb25fY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkNsaWNrYWJsZUNoYW5nZWQ6ICdjbGlja2FibGVfY2hhbmdlZCcsXG4gICAgb25DdXJzb3JDaGFuZ2VkOiAnY3Vyc29yX2NoYW5nZWQnLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnZ2FibGVDaGFuZ2VkOiAnZHJhZ2dhYmxlX2NoYW5nZWQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbkZsYXRDaGFuZ2VkOiAnZmxhdF9jaGFuZ2VkJyxcbiAgICBvbkljb25DaGFuZ2VkOiAnaWNvbl9jaGFuZ2VkJyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgICBvblNoYXBlQ2hhbmdlZDogJ3NoYXBlX2NoYW5nZWQnLFxuICAgIG9uVGl0bGVDaGFuZ2VkOiAndGl0bGVfY2hhbmdlZCcsXG4gICAgb25WaXNpYmxlQ2hhbmdlZDogJ3Zpc2libGVfY2hhbmdlZCcsXG4gICAgb25aaW5kZXhDaGFuZ2VkOiAnemluZGV4X2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJGYgPSB7XG4gICAgYW5pbWF0aW9uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGFuaW1hdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICB9LFxuICAgIGNsaWNrYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjbGlja2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2xpY2thYmxlKGNsaWNrYWJsZSk7XG4gICAgfSxcbiAgICBjdXJzb3I6IGZ1bmN0aW9uIChpbnN0YW5jZSwgY3Vyc29yKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH0sXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGljb246IGZ1bmN0aW9uIChpbnN0YW5jZSwgaWNvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRJY29uKGljb24pO1xuICAgIH0sXG4gICAgbGFiZWw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbGFiZWwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TGFiZWwobGFiZWwpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wYWNpdHk6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3BhY2l0eSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBzaGFwZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzaGFwZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRTaGFwZShzaGFwZSk7XG4gICAgfSxcbiAgICB0aXRsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0aXRsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxuICAgIHpJbmRleDogZnVuY3Rpb24gKGluc3RhbmNlLCB6SW5kZXgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkNSA9IHt9O1xuZnVuY3Rpb24gTWFya2VyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCBvcHRpb25zID0gX2Eub3B0aW9ucywgY2x1c3RlcmVyID0gX2EuY2x1c3RlcmVyLCBub0NsdXN0ZXJlclJlZHJhdyA9IF9hLm5vQ2x1c3RlcmVyUmVkcmF3LCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBhbmltYXRpb24gPSBfYS5hbmltYXRpb24sIGNsaWNrYWJsZSA9IF9hLmNsaWNrYWJsZSwgY3Vyc29yID0gX2EuY3Vyc29yLCBpY29uID0gX2EuaWNvbiwgbGFiZWwgPSBfYS5sYWJlbCwgb3BhY2l0eSA9IF9hLm9wYWNpdHksIHNoYXBlID0gX2Euc2hhcGUsIHRpdGxlID0gX2EudGl0bGUsIHpJbmRleCA9IF9hLnpJbmRleCwgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRGJsQ2xpY2sgPSBfYS5vbkRibENsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBvbkNsaWNrYWJsZUNoYW5nZWQgPSBfYS5vbkNsaWNrYWJsZUNoYW5nZWQsIG9uQ3Vyc29yQ2hhbmdlZCA9IF9hLm9uQ3Vyc29yQ2hhbmdlZCwgb25BbmltYXRpb25DaGFuZ2VkID0gX2Eub25BbmltYXRpb25DaGFuZ2VkLCBvbkRyYWdnYWJsZUNoYW5nZWQgPSBfYS5vbkRyYWdnYWJsZUNoYW5nZWQsIG9uRmxhdENoYW5nZWQgPSBfYS5vbkZsYXRDaGFuZ2VkLCBvbkljb25DaGFuZ2VkID0gX2Eub25JY29uQ2hhbmdlZCwgb25Qb3NpdGlvbkNoYW5nZWQgPSBfYS5vblBvc2l0aW9uQ2hhbmdlZCwgb25TaGFwZUNoYW5nZWQgPSBfYS5vblNoYXBlQ2hhbmdlZCwgb25UaXRsZUNoYW5nZWQgPSBfYS5vblRpdGxlQ2hhbmdlZCwgb25WaXNpYmxlQ2hhbmdlZCA9IF9hLm9uVmlzaWJsZUNoYW5nZWQsIG9uWmluZGV4Q2hhbmdlZCA9IF9hLm9uWmluZGV4Q2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9nWzFdO1xuICAgIHZhciBfaCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfalswXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9rWzBdLCBzZXRSaWdodGNsaWNrTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX2xbMV07XG4gICAgdmFyIF9tID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9tWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyID0gX29bMF0sIHNldENsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lciA9IF9vWzFdO1xuICAgIHZhciBfcCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjdXJzb3JDaGFuZ2VkTGlzdGVuZXIgPSBfcFswXSwgc2V0Q3Vyc29yQ2hhbmdlZExpc3RlbmVyID0gX3BbMV07XG4gICAgdmFyIF9xID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lciA9IF9xWzBdLCBzZXRBbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIgPSBfcVsxXTtcbiAgICB2YXIgX3IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyID0gX3JbMF0sIHNldERyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lciA9IF9yWzFdO1xuICAgIHZhciBfcyA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBmbGF0Q2hhbmdlZExpc3RlbmVyID0gX3NbMF0sIHNldEZsYXRDaGFuZ2VkTGlzdGVuZXIgPSBfc1sxXTtcbiAgICB2YXIgX3QgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgaWNvbkNoYW5nZWRMaXN0ZW5lciA9IF90WzBdLCBzZXRJY29uQ2hhbmdlZExpc3RlbmVyID0gX3RbMV07XG4gICAgdmFyIF91ID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyID0gX3VbMF0sIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyID0gX3VbMV07XG4gICAgdmFyIF92ID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHNoYXBlQ2hhbmdlZExpc3RlbmVyID0gX3ZbMF0sIHNldFNoYXBlQ2hhbmdlZExpc3RlbmVyID0gX3ZbMV07XG4gICAgdmFyIF93ID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHRpdGxlQ2hhbmdlZExpc3RlbmVyID0gX3dbMF0sIHNldFRpdGxlQ2hhbmdlZExpc3RlbmVyID0gX3dbMV07XG4gICAgdmFyIF94ID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHZpc2libGVDaGFuZ2VkTGlzdGVuZXIgPSBfeFswXSwgc2V0VmlzaWJsZUNoYW5nZWRMaXN0ZW5lciA9IF94WzFdO1xuICAgIHZhciBfeSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCB6SW5kZXhDaGFuZ2VkTGlzdGVuZXIgPSBfeVswXSwgc2V0WmluZGV4Q2hhbmdlZExpc3RlbmVyID0gX3lbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgcG9zaXRpb25dKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLnNldEFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgIH0sIFtpbnN0YW5jZSwgYW5pbWF0aW9uXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ0VuZF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ1N0YXJ0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZURvd25dKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2thYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGlja2FibGVfY2hhbmdlZCcsIG9uQ2xpY2thYmxlQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2thYmxlQ2hhbmdlZF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkN1cnNvckNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3JDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjdXJzb3JDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q3Vyc29yQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY3Vyc29yX2NoYW5nZWQnLCBvbkN1cnNvckNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkN1cnNvckNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25BbmltYXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2FuaW1hdGlvbl9jaGFuZ2VkJywgb25BbmltYXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25BbmltYXRpb25DaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ2dhYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnZ2FibGVfY2hhbmdlZCcsIG9uRHJhZ2dhYmxlQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ2dhYmxlQ2hhbmdlZF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkZsYXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoZmxhdENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGZsYXRDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RmxhdENoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2ZsYXRfY2hhbmdlZCcsIG9uRmxhdENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkZsYXRDaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uSWNvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChpY29uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoaWNvbkNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJY29uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnaWNvbl9jaGFuZ2VkJywgb25JY29uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uSWNvbkNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Qb3NpdGlvbkNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25TaGFwZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNoYXBlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFNoYXBlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnc2hhcGVfY2hhbmdlZCcsIG9uU2hhcGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25TaGFwZUNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25UaXRsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aXRsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRpdGxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpdGxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAndGl0bGVfY2hhbmdlZCcsIG9uVGl0bGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25UaXRsZUNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25WaXNpYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHZpc2libGVDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih2aXNpYmxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFZpc2libGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd2aXNpYmxlX2NoYW5nZWQnLCBvblZpc2libGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaXNpYmxlQ2hhbmdlZF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblppbmRleENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh6SW5kZXhDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6SW5kZXhDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0WmluZGV4Q2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnemluZGV4X2NoYW5nZWQnLCBvblppbmRleENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblppbmRleENoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQ1KSksIChjbHVzdGVyZXIgPyBkZWZhdWx0T3B0aW9ucyQ1IDogeyBtYXA6IG1hcCB9KSksIHsgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihtYXJrZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKGNsdXN0ZXJlcikge1xuICAgICAgICAgICAgY2x1c3RlcmVyLmFkZE1hcmtlcihtYXJrZXIsICEhbm9DbHVzdGVyZXJSZWRyYXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFya2VyLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgbWFya2VyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNsaWNrYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRDbGlja2FibGUoY2xpY2thYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN1cnNvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWNvbikge1xuICAgICAgICAgICAgbWFya2VyLnNldEljb24oaWNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRMYWJlbChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWFya2VyLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0U2hhcGUoc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0VGl0bGUodGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyLnNldFpJbmRleCh6SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU91dCkge1xuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VVcCkge1xuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWcpIHtcbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2thYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0Q2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrYWJsZV9jaGFuZ2VkJywgb25DbGlja2FibGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ3Vyc29yQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0Q3Vyc29yQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2N1cnNvcl9jaGFuZ2VkJywgb25DdXJzb3JDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQW5pbWF0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0QW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2FuaW1hdGlvbl9jaGFuZ2VkJywgb25BbmltYXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ2dhYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0RHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdnYWJsZV9jaGFuZ2VkJywgb25EcmFnZ2FibGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRmxhdENoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldEZsYXRDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZmxhdF9jaGFuZ2VkJywgb25GbGF0Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkljb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRJY29uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2ljb25fY2hhbmdlZCcsIG9uSWNvbkNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblNoYXBlQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0U2hhcGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnc2hhcGVfY2hhbmdlZCcsIG9uU2hhcGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uVGl0bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRUaXRsZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICd0aXRsZV9jaGFuZ2VkJywgb25UaXRsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25WaXNpYmxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0VmlzaWJsZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICd2aXNpYmxlX2NoYW5nZWQnLCBvblZpc2libGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0WmluZGV4Q2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5zdGFuY2UobWFya2VyKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGN1cnNvckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYXRDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihmbGF0Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpY29uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoaWNvbkNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbkNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGl0bGVDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aXRsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlzaWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHZpc2libGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpJbmRleENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHpJbmRleENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgb25Vbm1vdW50KG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2x1c3RlcmVyKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcmVyLnJlbW92ZU1hcmtlcihtYXJrZXIsICEhbm9DbHVzdGVyZXJSZWRyYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGNoeCA9IHJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgICAgICAgID8gcmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnRDaGlsZCwgeyBhbmNob3I6IGluc3RhbmNlIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9LCBbY2hpbGRyZW4sIGluc3RhbmNlXSk7XG4gICAgcmV0dXJuIGpzeFJ1bnRpbWUuanN4KGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoeCB9KSB8fCBudWxsO1xufVxudmFyIE1hcmtlckYgPSByZWFjdC5tZW1vKE1hcmtlckZ1bmN0aW9uYWwpO1xudmFyIE1hcmtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFya2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcmtlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXJrZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zJDUpKSwgKHRoaXMucHJvcHMuY2x1c3RlcmVyID8gZGVmYXVsdE9wdGlvbnMkNSA6IHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpLCB7IHBvc2l0aW9uOiB0aGlzLnByb3BzLnBvc2l0aW9uIH0pO1xuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0IGp1c3QgZG8gdGhpcyBpbiB0aGUgY29udHN0cnVjdG9yLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBgTWFwQ29udGV4dGAgbWlnaHQgbm90IGJlIGZpbGxlZCBpbiB5ZXQuXG4gICAgICAgIHRoaXMubWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihtYXJrZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2x1c3RlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmNsdXN0ZXJlci5hZGRNYXJrZXIodGhpcy5tYXJrZXIsICEhdGhpcy5wcm9wcy5ub0NsdXN0ZXJlclJlZHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlci5zZXRNYXAodGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZixcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRmLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLm1hcmtlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5tYXJrZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGYsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGYsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLm1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMubWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmNsdXN0ZXJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2x1c3RlcmVyLnJlbW92ZU1hcmtlcih0aGlzLm1hcmtlciwgISF0aGlzLnByb3BzLm5vQ2x1c3RlcmVyUmVkcmF3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyICYmIHRoaXMubWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHJlYWN0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnRDaGlsZCwgeyBhbmNob3I6IF90aGlzLm1hcmtlciB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiB8fCBudWxsO1xuICAgIH07XG4gICAgTWFya2VyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gTWFya2VyO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBDbHVzdGVySWNvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbHVzdGVySWNvbihjbHVzdGVyLCBzdHlsZXMpIHtcbiAgICAgICAgY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5leHRlbmQoQ2x1c3Rlckljb24sIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcbiAgICAgICAgdGhpcy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICAgICAgdGhpcy5jbHVzdGVyQ2xhc3NOYW1lID0gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmdldENsdXN0ZXJDbGFzcygpO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2x1c3RlckNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VtcyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMudXJsID0gJyc7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuYW5jaG9yVGV4dCA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5hbmNob3JJY29uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLnRleHRDb2xvciA9ICdibGFjayc7XG4gICAgICAgIHRoaXMudGV4dFNpemUgPSAxMTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbiA9ICdub25lJztcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9ICdub3JtYWwnO1xuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSAnQXJpYWwsc2Fucy1zZXJpZic7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFBvc2l0aW9uID0gJzAgMCc7XG4gICAgICAgIHRoaXMuY01vdXNlRG93bkluQ2x1c3RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lT3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRNYXAoY2x1c3Rlci5nZXRNYXAoKSk7IC8vIE5vdGU6IHRoaXMgY2F1c2VzIG9uQWRkIHRvIGJlIGNhbGxlZFxuICAgICAgICB0aGlzLm9uQm91bmRzQ2hhbmdlZCA9IHRoaXMub25Cb3VuZHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VPdmVyID0gdGhpcy5vbk1vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VPdXQgPSB0aGlzLm9uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkFkZCA9IHRoaXMub25BZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlbW92ZSA9IHRoaXMub25SZW1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlkZSA9IHRoaXMuaGlkZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51c2VTdHlsZSA9IHRoaXMudXNlU3R5bGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIgPSB0aGlzLnNldENlbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFBvc0Zyb21MYXRMbmcgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmcuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQm91bmRzQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jRHJhZ2dpbmdNYXBCeUNsdXN0ZXIgPSB0aGlzLmNNb3VzZURvd25JbkNsdXN0ZXI7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY01vdXNlRG93bkluQ2x1c3RlciA9IHRydWU7XG4gICAgICAgIHRoaXMuY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gZmFsc2U7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmNNb3VzZURvd25JbkNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmNEcmFnZ2luZ01hcEJ5Q2x1c3Rlcikge1xuICAgICAgICAgICAgdmFyIG1hcmtlckNsdXN0ZXJlcl8xID0gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBjbHVzdGVyIG1hcmtlciBpcyBjbGlja2VkLlxuICAgICAgICAgICAgICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyI2NsaWNrXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJ9IGMgVGhlIGNsdXN0ZXIgdGhhdCB3YXMgY2xpY2tlZC5cbiAgICAgICAgICAgICAqIEBldmVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG1hcmtlckNsdXN0ZXJlcl8xLCAnY2xpY2snLCB0aGlzLmNsdXN0ZXIpO1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXJrZXJDbHVzdGVyZXJfMSwgJ2NsdXN0ZXJjbGljaycsIHRoaXMuY2x1c3Rlcik7IC8vIGRlcHJlY2F0ZWQgbmFtZVxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2xpY2sgaGFuZGxlciBmb2xsb3dzLiBEaXNhYmxlIGl0IGJ5IHNldHRpbmdcbiAgICAgICAgICAgIC8vIHRoZSB6b29tT25DbGljayBwcm9wZXJ0eSB0byBmYWxzZS5cbiAgICAgICAgICAgIGlmIChtYXJrZXJDbHVzdGVyZXJfMS5nZXRab29tT25DbGljaygpKSB7XG4gICAgICAgICAgICAgICAgLy8gWm9vbSBpbnRvIHRoZSBjbHVzdGVyLlxuICAgICAgICAgICAgICAgIHZhciBtYXhab29tXzEgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXhab29tKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kc18xID0gdGhpcy5jbHVzdGVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwICE9PSBudWxsICYmICdmaXRCb3VuZHMnIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuZml0Qm91bmRzKGJvdW5kc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBmaXggZm9yIElzc3VlIDE3MCBoZXJlOlxuICAgICAgICAgICAgICAgIHRoaXMudGltZU91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG1hcmtlckNsdXN0ZXJlcl8xLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2ZpdEJvdW5kcycgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhib3VuZHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgem9vbSA9IG1hcC5nZXRab29tKCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHpvb20gYmV5b25kIHRoZSBtYXggem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heFpvb21fMSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gPiBtYXhab29tXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuc2V0Wm9vbShtYXhab29tXzEgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uIHRvIHRoZSBtYXA6XG4gICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBjbHVzdGVyIG1hcmtlci5cbiAgICAgICAgICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyI21vdXNlb3ZlclxuICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJ9IGMgVGhlIGNsdXN0ZXIgdGhhdCB0aGUgbW91c2UgbW92ZWQgb3Zlci5cbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKSwgJ21vdXNlb3ZlcicsIHRoaXMuY2x1c3Rlcik7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgb3V0IG9mIGEgY2x1c3RlciBtYXJrZXIuXG4gICAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNtb3VzZW91dFxuICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJ9IGMgVGhlIGNsdXN0ZXIgdGhhdCB0aGUgbW91c2UgbW92ZWQgb3V0IG9mLlxuICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLCAnbW91c2VvdXQnLCB0aGlzLmNsdXN0ZXIpO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmdldFBhbmVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdmVybGF5TW91c2VUYXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5kaXYpO1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRml4IGZvciBJc3N1ZSAxNTdcbiAgICAgICAgICAgIHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnYm91bmRzX2NoYW5nZWQnLCB0aGlzLm9uQm91bmRzQ2hhbmdlZCk7XG4gICAgICAgICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZU92ZXIpO1xuICAgICAgICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uTW91c2VPdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICAgICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICAgICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVPdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lT3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy5kaXYgIT09IG51bGwgJiYgdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmcodGhpcy5jZW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudG9wID0gcG9zICE9PSBudWxsID8gXCJcIi5jb25jYXQocG9zLnksIFwicHhcIikgOiAnMCc7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gcG9zICE9PSBudWxsID8gXCJcIi5jb25jYXQocG9zLngsIFwicHhcIikgOiAnMCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmNlbnRlcikge1xuICAgICAgICAgICAgdmFyIGRpdlRpdGxlID0gdGhpcy5zdW1zID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMuc3Vtcy50aXRsZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN1bXMudGl0bGUgPT09ICcnID8gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmdldFRpdGxlKCkgOiB0aGlzLnN1bXMudGl0bGU7XG4gICAgICAgICAgICAvLyBOT1RFOiB2YWx1ZXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gcHggdW5pdHNcbiAgICAgICAgICAgIHZhciBicCA9IHRoaXMuYmFja2dyb3VuZFBvc2l0aW9uLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlSCA9IHBhcnNlSW50KCgoX2EgPSBicFswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSkgfHwgJzAnLCAxMCk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlViA9IHBhcnNlSW50KCgoX2IgPSBicFsxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSkgfHwgJzAnLCAxMCk7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NGcm9tTGF0TG5nKHRoaXMuY2VudGVyKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsIFwiY3Vyc29yOiBwb2ludGVyOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIuY29uY2F0KHBvcyAhPT0gbnVsbCA/IFwiXCIuY29uY2F0KHBvcy55LCBcInB4XCIpIDogJzAnLCBcIjsgbGVmdDogXCIpLmNvbmNhdChwb3MgIT09IG51bGwgPyBcIlwiLmNvbmNhdChwb3MueCwgXCJweFwiKSA6ICcwJywgXCI7IHdpZHRoOiBcIikuY29uY2F0KHRoaXMud2lkdGgsIFwicHg7IGhlaWdodDogXCIpLmNvbmNhdCh0aGlzLmhlaWdodCwgXCJweDsgXCIpKTtcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZy5hbHQgPSBkaXZUaXRsZTtcbiAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLnVybDtcbiAgICAgICAgICAgIGltZy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBpbWcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzdHlsZScsIFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IFwiLmNvbmNhdChzcHJpdGVWLCBcInB4OyBsZWZ0OiBcIikuY29uY2F0KHNwcml0ZUgsIFwicHhcIikpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCkuZW5hYmxlUmV0aW5hSWNvbnMpIHtcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUuY2xpcCA9IFwicmVjdCgtXCIuY29uY2F0KHNwcml0ZVYsIFwicHgsIC1cIikuY29uY2F0KHNwcml0ZUggKyB0aGlzLndpZHRoLCBcInB4LCAtXCIpLmNvbmNhdChzcHJpdGVWICsgdGhpcy5oZWlnaHQsIFwiLCAtXCIpLmNvbmNhdChzcHJpdGVILCBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4dEVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGV4dEVsbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIuY29uY2F0KHRoaXMuYW5jaG9yVGV4dFswXSwgXCJweDsgbGVmdDogXCIpLmNvbmNhdCh0aGlzLmFuY2hvclRleHRbMV0sIFwicHg7IGNvbG9yOiBcIikuY29uY2F0KHRoaXMudGV4dENvbG9yLCBcIjsgZm9udC1zaXplOiBcIikuY29uY2F0KHRoaXMudGV4dFNpemUsIFwicHg7IGZvbnQtZmFtaWx5OiBcIikuY29uY2F0KHRoaXMuZm9udEZhbWlseSwgXCI7IGZvbnQtd2VpZ2h0OiBcIikuY29uY2F0KHRoaXMuZm9udFdlaWdodCwgXCI7IGZvbnRTdHlsZTogXCIpLmNvbmNhdCh0aGlzLmZvbnRTdHlsZSwgXCI7IHRleHQtZGVjb3JhdGlvbjogXCIpLmNvbmNhdCh0aGlzLnRleHREZWNvcmF0aW9uLCBcIjsgdGV4dC1hbGlnbjogY2VudGVyOyB3aWR0aDogXCIpLmNvbmNhdCh0aGlzLndpZHRoLCBcInB4OyBsaW5lLWhlaWdodDogXCIpLmNvbmNhdCh0aGlzLmhlaWdodCwgXCJweFwiKSk7XG4gICAgICAgICAgICBpZiAoKF9jID0gdGhpcy5zdW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudGV4dClcbiAgICAgICAgICAgICAgICB0ZXh0RWxtLmlubmVyVGV4dCA9IFwiXCIuY29uY2F0KChfZCA9IHRoaXMuc3VtcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRleHQpO1xuICAgICAgICAgICAgaWYgKChfZSA9IHRoaXMuc3VtcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmh0bWwpXG4gICAgICAgICAgICAgICAgdGV4dEVsbS5pbm5lckhUTUwgPSBcIlwiLmNvbmNhdCgoX2YgPSB0aGlzLnN1bXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRleHRFbG0pO1xuICAgICAgICAgICAgdGhpcy5kaXYudGl0bGUgPSBkaXZUaXRsZTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLnVzZVN0eWxlID0gZnVuY3Rpb24gKHN1bXMpIHtcbiAgICAgICAgdGhpcy5zdW1zID0gc3VtcztcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5nZXRTdHlsZXMoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW01hdGgubWluKHN0eWxlcy5sZW5ndGggLSAxLCBNYXRoLm1heCgwLCBzdW1zLmluZGV4IC0gMSkpXTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHN0eWxlLnVybDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQodGhpcy5jbHVzdGVyQ2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KHN0eWxlLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFuY2hvclRleHQgPSBzdHlsZS5hbmNob3JUZXh0IHx8IFswLCAwXTtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9ySWNvbiA9IHN0eWxlLmFuY2hvckljb24gfHwgW3RoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCAvIDJdO1xuICAgICAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSBzdHlsZS50ZXh0Q29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgICAgIHRoaXMudGV4dFNpemUgPSBzdHlsZS50ZXh0U2l6ZSB8fCAxMTtcbiAgICAgICAgICAgIHRoaXMudGV4dERlY29yYXRpb24gPSBzdHlsZS50ZXh0RGVjb3JhdGlvbiB8fCAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0IHx8ICdib2xkJztcbiAgICAgICAgICAgIHRoaXMuZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlIHx8ICdub3JtYWwnO1xuICAgICAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseSB8fCAnQXJpYWwsc2Fucy1zZXJpZic7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRQb3NpdGlvbiA9IHN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiB8fCAnMCAwJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUuZ2V0UG9zRnJvbUxhdExuZyA9IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdGxuZyk7XG4gICAgICAgIGlmIChwb3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcy54IC09IHRoaXMuYW5jaG9ySWNvblsxXTtcbiAgICAgICAgICAgIHBvcy55IC09IHRoaXMuYW5jaG9ySWNvblswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgcmV0dXJuIENsdXN0ZXJJY29uO1xufSgpKTtcblxuLyogZ2xvYmFsIGdvb2dsZSAqL1xudmFyIENsdXN0ZXIkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbHVzdGVyKG1hcmtlckNsdXN0ZXJlcikge1xuICAgICAgICB0aGlzLm1hcmtlckNsdXN0ZXJlciA9IG1hcmtlckNsdXN0ZXJlcjtcbiAgICAgICAgdGhpcy5tYXAgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNYXAoKTtcbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEdyaWRTaXplKCk7XG4gICAgICAgIHRoaXMubWluQ2x1c3RlclNpemUgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNaW5pbXVtQ2x1c3RlclNpemUoKTtcbiAgICAgICAgdGhpcy5hdmVyYWdlQ2VudGVyID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0QXZlcmFnZUNlbnRlcigpO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbiA9IG5ldyBDbHVzdGVySWNvbih0aGlzLCB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRTdHlsZXMoKSk7XG4gICAgICAgIHRoaXMuZ2V0U2l6ZSA9IHRoaXMuZ2V0U2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRDZW50ZXIgPSB0aGlzLmdldENlbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE1hcCA9IHRoaXMuZ2V0TWFwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q2x1c3RlcmVyID0gdGhpcy5nZXRDbHVzdGVyZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSB0aGlzLmdldEJvdW5kcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZSA9IHRoaXMucmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkTWFya2VyID0gdGhpcy5hZGRNYXJrZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc01hcmtlckluQ2x1c3RlckJvdW5kcyA9IHRoaXMuaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLmNhbGN1bGF0ZUJvdW5kcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUljb24gPSB0aGlzLnVwZGF0ZUljb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc01hcmtlckFscmVhZHlBZGRlZCA9IHRoaXMuaXNNYXJrZXJBbHJlYWR5QWRkZWQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXI7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcDtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldENsdXN0ZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VyQ2x1c3RlcmVyO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyh0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIpO1xuICAgICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hcmtlcnNfMSA9IG1hcmtlcnM7IF9pIDwgbWFya2Vyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNfMVtfaV07XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5leHRlbmQocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2x1c3Rlckljb24uc2V0TWFwKG51bGwpO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hcmtlcnM7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXJrZXJBbHJlYWR5QWRkZWQobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXZlcmFnZUNlbnRlcikge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSB0aGlzLm1hcmtlcnMubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKCh0aGlzLmNlbnRlci5sYXQoKSAqIChsZW5ndGhfMSAtIDEpICsgcG9zaXRpb24ubGF0KCkpIC8gbGVuZ3RoXzEsICh0aGlzLmNlbnRlci5sbmcoKSAqIChsZW5ndGhfMSAtIDEpICsgcG9zaXRpb24ubG5nKCkpIC8gbGVuZ3RoXzEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya2Vycy5wdXNoKG1hcmtlcik7XG4gICAgICAgIHZhciBtQ291bnQgPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4Wm9vbSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldE1heFpvb20oKTtcbiAgICAgICAgdmFyIHpvb20gPSAoX2EgPSB0aGlzLm1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFpvb20oKTtcbiAgICAgICAgaWYgKG1heFpvb20gIT09IG51bGwgJiYgdHlwZW9mIHpvb20gIT09ICd1bmRlZmluZWQnICYmIHpvb20gPiBtYXhab29tKSB7XG4gICAgICAgICAgICAvLyBab29tZWQgaW4gcGFzdCBtYXggem9vbSwgc28gc2hvdyB0aGUgbWFya2VyLlxuICAgICAgICAgICAgaWYgKG1hcmtlci5nZXRNYXAoKSAhPT0gdGhpcy5tYXApIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtQ291bnQgPCB0aGlzLm1pbkNsdXN0ZXJTaXplKSB7XG4gICAgICAgICAgICAvLyBNaW4gY2x1c3RlciBzaXplIG5vdCByZWFjaGVkIHNvIHNob3cgdGhlIG1hcmtlci5cbiAgICAgICAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcCh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobUNvdW50ID09PSB0aGlzLm1pbkNsdXN0ZXJTaXplKSB7XG4gICAgICAgICAgICAvLyBIaWRlIHRoZSBtYXJrZXJzIHRoYXQgd2VyZSBzaG93aW5nLlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IHRoaXMubWFya2VyczsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyRWxlbWVudCA9IF9iW19pXTtcbiAgICAgICAgICAgICAgICBtYXJrZXJFbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5pc01hcmtlckluQ2x1c3RlckJvdW5kcyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdW5kcy5jb250YWlucyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEV4dGVuZGVkQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyKSk7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS51cGRhdGVJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBtQ291bnQgPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4Wm9vbSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldE1heFpvb20oKTtcbiAgICAgICAgdmFyIHpvb20gPSAoX2EgPSB0aGlzLm1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFpvb20oKTtcbiAgICAgICAgaWYgKG1heFpvb20gIT09IG51bGwgJiYgdHlwZW9mIHpvb20gIT09ICd1bmRlZmluZWQnICYmIHpvb20gPiBtYXhab29tKSB7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobUNvdW50IDwgdGhpcy5taW5DbHVzdGVyU2l6ZSkge1xuICAgICAgICAgICAgLy8gTWluIGNsdXN0ZXIgc2l6ZSBub3QgeWV0IHJlYWNoZWQuXG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlckljb24uc2V0Q2VudGVyKHRoaXMuY2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLnVzZVN0eWxlKHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldENhbGN1bGF0b3IoKSh0aGlzLm1hcmtlcnMsIHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldFN0eWxlcygpLmxlbmd0aCkpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLnNob3coKTtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmlzTWFya2VyQWxyZWFkeUFkZGVkID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXJzLmluY2x1ZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzLmluY2x1ZGVzKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IHRoaXMubWFya2Vyc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBDbHVzdGVyO1xufSgpKTtcblxuLyogZ2xvYmFsIGdvb2dsZSAqL1xuLyoqXG4gKiBTdXBwb3J0cyB1cCB0byA5MDA3MTk5MjU0NzQwOTkxIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgbWFya2Vyc1xuICogd2hpY2ggaXMgbm90IGEgcHJvYmxlbSBhcyBtYXggYXJyYXkgbGVuZ3RoIGlzIDQyOTQ5NjcyOTYgKDIqKjMyKVxuICovXG5mdW5jdGlvbiBDQUxDVUxBVE9SKG1hcmtlcnMsIG51bVN0eWxlcykge1xuICAgIHZhciBjb3VudCA9IG1hcmtlcnMubGVuZ3RoO1xuICAgIHZhciBudW1iZXJPZkRpZ2l0cyA9IGNvdW50LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IE1hdGgubWluKG51bWJlck9mRGlnaXRzLCBudW1TdHlsZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IGNvdW50LnRvU3RyaW5nKCksXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdGl0bGU6ICcnLFxuICAgIH07XG59XG52YXIgQkFUQ0hfU0laRSA9IDIwMDA7XG52YXIgQkFUQ0hfU0laRV9JRSA9IDUwMDtcbnZhciBJTUFHRV9QQVRIID0gJ2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2V4YW1wbGVzL21hcmtlcmNsdXN0ZXJlci9tJztcbnZhciBJTUFHRV9FWFRFTlNJT04gPSAncG5nJztcbnZhciBJTUFHRV9TSVpFUyA9IFs1MywgNTYsIDY2LCA3OCwgOTBdO1xudmFyIENMVVNURVJFUl9DTEFTUyA9ICdjbHVzdGVyJztcbnZhciBDbHVzdGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3RlcmVyKG1hcCwgb3B0TWFya2Vycywgb3B0T3B0aW9ucykge1xuICAgICAgICBpZiAob3B0TWFya2VycyA9PT0gdm9pZCAwKSB7IG9wdE1hcmtlcnMgPSBbXTsgfVxuICAgICAgICBpZiAob3B0T3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdE9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmdldE1pbmltdW1DbHVzdGVyU2l6ZSA9IHRoaXMuZ2V0TWluaW11bUNsdXN0ZXJTaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TWluaW11bUNsdXN0ZXJTaXplID0gdGhpcy5zZXRNaW5pbXVtQ2x1c3RlclNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRFbmFibGVSZXRpbmFJY29ucyA9IHRoaXMuZ2V0RW5hYmxlUmV0aW5hSWNvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRFbmFibGVSZXRpbmFJY29ucyA9IHRoaXMuc2V0RW5hYmxlUmV0aW5hSWNvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyID0gdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0SW1hZ2VFeHRlbnNpb24gPSB0aGlzLmdldEltYWdlRXh0ZW5zaW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VFeHRlbnNpb24gPSB0aGlzLnNldEltYWdlRXh0ZW5zaW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0RXh0ZW5kZWRCb3VuZHMgPSB0aGlzLmdldEV4dGVuZGVkQm91bmRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0QXZlcmFnZUNlbnRlciA9IHRoaXMuZ2V0QXZlcmFnZUNlbnRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEF2ZXJhZ2VDZW50ZXIgPSB0aGlzLnNldEF2ZXJhZ2VDZW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRUb3RhbENsdXN0ZXJzID0gdGhpcy5nZXRUb3RhbENsdXN0ZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZml0TWFwVG9NYXJrZXJzID0gdGhpcy5maXRNYXBUb01hcmtlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRJZ25vcmVIaWRkZW4gPSB0aGlzLmdldElnbm9yZUhpZGRlbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldElnbm9yZUhpZGRlbiA9IHRoaXMuc2V0SWdub3JlSGlkZGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q2x1c3RlckNsYXNzID0gdGhpcy5nZXRDbHVzdGVyQ2xhc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDbHVzdGVyQ2xhc3MgPSB0aGlzLnNldENsdXN0ZXJDbGFzcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFRvdGFsTWFya2VycyA9IHRoaXMuZ2V0VG90YWxNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Wm9vbU9uQ2xpY2sgPSB0aGlzLmdldFpvb21PbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Wm9vbU9uQ2xpY2sgPSB0aGlzLnNldFpvb21PbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0QmF0Y2hTaXplSUUgPSB0aGlzLmdldEJhdGNoU2l6ZUlFLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0QmF0Y2hTaXplSUUgPSB0aGlzLnNldEJhdGNoU2l6ZUlFLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2x1c3RlcnMgPSB0aGlzLmNyZWF0ZUNsdXN0ZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25ab29tQ2hhbmdlZCA9IHRoaXMub25ab29tQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEltYWdlU2l6ZXMgPSB0aGlzLmdldEltYWdlU2l6ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRJbWFnZVNpemVzID0gdGhpcy5zZXRJbWFnZVNpemVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q2FsY3VsYXRvciA9IHRoaXMuZ2V0Q2FsY3VsYXRvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENhbGN1bGF0b3IgPSB0aGlzLnNldENhbGN1bGF0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXJrZXJzID0gdGhpcy5yZW1vdmVNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXRWaWV3cG9ydCA9IHRoaXMucmVzZXRWaWV3cG9ydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEltYWdlUGF0aCA9IHRoaXMuZ2V0SW1hZ2VQYXRoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VQYXRoID0gdGhpcy5zZXRJbWFnZVBhdGguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wdXNoTWFya2VyVG8gPSB0aGlzLnB1c2hNYXJrZXJUby5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZU1hcmtlciA9IHRoaXMucmVtb3ZlTWFya2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXJNYXJrZXJzID0gdGhpcy5jbGVhck1hcmtlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXR1cFN0eWxlcyA9IHRoaXMuc2V0dXBTdHlsZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRHcmlkU2l6ZSA9IHRoaXMuZ2V0R3JpZFNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRHcmlkU2l6ZSA9IHRoaXMuc2V0R3JpZFNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRDbHVzdGVycyA9IHRoaXMuZ2V0Q2x1c3RlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNYXhab29tID0gdGhpcy5nZXRNYXhab29tLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0TWF4Wm9vbSA9IHRoaXMuc2V0TWF4Wm9vbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRNYXJrZXJzID0gdGhpcy5hZGRNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0U3R5bGVzID0gdGhpcy5nZXRTdHlsZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZXMgPSB0aGlzLnNldFN0eWxlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE1hcmtlciA9IHRoaXMuYWRkTWFya2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW1vdmUgPSB0aGlzLm9uUmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0VGl0bGUgPSB0aGlzLmdldFRpdGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGl0bGUgPSB0aGlzLnNldFRpdGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVwYWludCA9IHRoaXMucmVwYWludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSWRsZSA9IHRoaXMub25JZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gdGhpcy5yZWRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkFkZCA9IHRoaXMub25BZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gdGhpcy5leHRlbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5leHRlbmQoQ2x1c3RlcmVyLCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gb3B0T3B0aW9ucy5ncmlkU2l6ZSB8fCA2MDtcbiAgICAgICAgdGhpcy5taW5DbHVzdGVyU2l6ZSA9IG9wdE9wdGlvbnMubWluaW11bUNsdXN0ZXJTaXplIHx8IDI7XG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IG9wdE9wdGlvbnMubWF4Wm9vbSB8fCBudWxsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IG9wdE9wdGlvbnMuc3R5bGVzIHx8IFtdO1xuICAgICAgICB0aGlzLnRpdGxlID0gb3B0T3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICAgICAgdGhpcy56b29tT25DbGljayA9IHRydWU7XG4gICAgICAgIGlmIChvcHRPcHRpb25zLnpvb21PbkNsaWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbU9uQ2xpY2sgPSBvcHRPcHRpb25zLnpvb21PbkNsaWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy5hdmVyYWdlQ2VudGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IG9wdE9wdGlvbnMuYXZlcmFnZUNlbnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlnbm9yZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy5pZ25vcmVIaWRkZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVIaWRkZW4gPSBvcHRPcHRpb25zLmlnbm9yZUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRPcHRpb25zLmVuYWJsZVJldGluYUljb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnMgPSBvcHRPcHRpb25zLmVuYWJsZVJldGluYUljb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VQYXRoID0gb3B0T3B0aW9ucy5pbWFnZVBhdGggfHwgSU1BR0VfUEFUSDtcbiAgICAgICAgdGhpcy5pbWFnZUV4dGVuc2lvbiA9IG9wdE9wdGlvbnMuaW1hZ2VFeHRlbnNpb24gfHwgSU1BR0VfRVhURU5TSU9OO1xuICAgICAgICB0aGlzLmltYWdlU2l6ZXMgPSBvcHRPcHRpb25zLmltYWdlU2l6ZXMgfHwgSU1BR0VfU0laRVM7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IG9wdE9wdGlvbnMuY2FsY3VsYXRvciB8fCBDQUxDVUxBVE9SO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IG9wdE9wdGlvbnMuYmF0Y2hTaXplIHx8IEJBVENIX1NJWkU7XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplSUUgPSBvcHRPcHRpb25zLmJhdGNoU2l6ZUlFIHx8IEJBVENIX1NJWkVfSUU7XG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzID0gb3B0T3B0aW9ucy5jbHVzdGVyQ2xhc3MgfHwgQ0xVU1RFUkVSX0NMQVNTO1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhdm9pZCBJRSB0aW1lb3V0IHdoZW4gcHJvY2Vzc2luZyBhIGh1Z2UgbnVtYmVyIG9mIG1hcmtlcnM6XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMuYmF0Y2hTaXplSUU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5hZGRNYXJrZXJzKG9wdE1hcmtlcnMsIHRydWUpO1xuICAgICAgICB0aGlzLnNldE1hcChtYXApOyAvLyBOb3RlOiB0aGlzIGNhdXNlcyBvbkFkZCB0byBiZSBjYWxsZWRcbiAgICB9XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5vblpvb21DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnJlc2V0Vmlld3BvcnQoZmFsc2UpO1xuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciB0aGlzIEdvb2dsZSBidWc6IHdoZW4gbWFwIGlzIGF0IGxldmVsIDAgYW5kIFwiLVwiIG9mXG4gICAgICAgIC8vIHpvb20gc2xpZGVyIGlzIGNsaWNrZWQsIGEgXCJ6b29tX2NoYW5nZWRcIiBldmVudCBpcyBmaXJlZCBldmVuIHRob3VnaFxuICAgICAgICAvLyB0aGUgbWFwIGRvZXNuJ3Qgem9vbSBvdXQgYW55IGZ1cnRoZXIuIEluIHRoaXMgc2l0dWF0aW9uLCBubyBcImlkbGVcIlxuICAgICAgICAvLyBldmVudCBpcyB0cmlnZ2VyZWQgc28gdGhlIGNsdXN0ZXIgbWFya2VycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgIC8vIGRvIG5vdCBnZXQgcmVkcmF3bi4gU2FtZSBnb2VzIGZvciBhIHpvb20gaW4gYXQgbWF4Wm9vbS5cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmdldE1hcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Wm9vbSgpKSA9PT0gKHRoaXMuZ2V0KCdtaW5ab29tJykgfHwgMCkgfHxcbiAgICAgICAgICAgICgoX2IgPSB0aGlzLmdldE1hcCgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Wm9vbSgpKSA9PT0gdGhpcy5nZXQoJ21heFpvb20nKSkge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnaWRsZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLm9uSWRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZU1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG1hcCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ3pvb21fY2hhbmdlZCcsIHRoaXMub25ab29tQ2hhbmdlZCksXG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnaWRsZScsIHRoaXMub25JZGxlKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFB1dCBhbGwgdGhlIG1hbmFnZWQgbWFya2VycyBiYWNrIG9uIHRoZSBtYXA6XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLm1hcmtlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKG1hcmtlci5nZXRNYXAoKSAhPT0gdGhpcy5hY3RpdmVNYXApIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKHRoaXMuYWN0aXZlTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNsdXN0ZXJzOlxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5jbHVzdGVyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyID0gX2NbX2JdO1xuICAgICAgICAgICAgY2x1c3Rlci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIC8vIFJlbW92ZSBtYXAgZXZlbnQgbGlzdGVuZXJzOlxuICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gdGhpcy5saXN0ZW5lcnM7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfZVtfZF07XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVNYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRQYW5lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbUNvbnRhaW5lclBpeGVsVG9MYXRMbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBmcm9tRGl2UGl4ZWxUb0xhdExuZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGZyb21MYXRMbmdUb0NvbnRhaW5lclBpeGVsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZnJvbUxhdExuZ1RvRGl2UGl4ZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBnZXRWaXNpYmxlUmVnaW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZ2V0V29ybGRXaWR0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IHJldHVybjsgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5iaW5kVG8gPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldHVwU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbWFnZVNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiXCIuY29uY2F0KHRoaXMuaW1hZ2VQYXRoICsgKGkgKyAxKSwgXCIuXCIpLmNvbmNhdCh0aGlzLmltYWdlRXh0ZW5zaW9uKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaW1hZ2VTaXplc1tpXSB8fCAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmltYWdlU2l6ZXNbaV0gfHwgMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmZpdE1hcFRvTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXJrZXJzXzEgPSBtYXJrZXJzOyBfaSA8IG1hcmtlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBib3VuZHMuZXh0ZW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCAmJiAnZml0Qm91bmRzJyBpbiBtYXApIHtcbiAgICAgICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZFNpemU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEdyaWRTaXplID0gZnVuY3Rpb24gKGdyaWRTaXplKSB7XG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWluaW11bUNsdXN0ZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5DbHVzdGVyU2l6ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWluaW11bUNsdXN0ZXJTaXplID0gZnVuY3Rpb24gKG1pbmltdW1DbHVzdGVyU2l6ZSkge1xuICAgICAgICB0aGlzLm1pbkNsdXN0ZXJTaXplID0gbWluaW11bUNsdXN0ZXJTaXplO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhab29tO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRNYXhab29tID0gZnVuY3Rpb24gKG1heFpvb20pIHtcbiAgICAgICAgdGhpcy5tYXhab29tID0gbWF4Wm9vbTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZXM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRab29tT25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbU9uQ2xpY2s7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldFpvb21PbkNsaWNrID0gZnVuY3Rpb24gKHpvb21PbkNsaWNrKSB7XG4gICAgICAgIHRoaXMuem9vbU9uQ2xpY2sgPSB6b29tT25DbGljaztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0QXZlcmFnZUNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXZlcmFnZUNlbnRlcjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0QXZlcmFnZUNlbnRlciA9IGZ1bmN0aW9uIChhdmVyYWdlQ2VudGVyKSB7XG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IGF2ZXJhZ2VDZW50ZXI7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldElnbm9yZUhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWdub3JlSGlkZGVuO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJZ25vcmVIaWRkZW4gPSBmdW5jdGlvbiAoaWdub3JlSGlkZGVuKSB7XG4gICAgICAgIHRoaXMuaWdub3JlSGlkZGVuID0gaWdub3JlSGlkZGVuO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRFbmFibGVSZXRpbmFJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEVuYWJsZVJldGluYUljb25zID0gZnVuY3Rpb24gKGVuYWJsZVJldGluYUljb25zKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnMgPSBlbmFibGVSZXRpbmFJY29ucztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VFeHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlRXh0ZW5zaW9uO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJbWFnZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChpbWFnZUV4dGVuc2lvbikge1xuICAgICAgICB0aGlzLmltYWdlRXh0ZW5zaW9uID0gaW1hZ2VFeHRlbnNpb247XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEltYWdlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VQYXRoO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJbWFnZVBhdGggPSBmdW5jdGlvbiAoaW1hZ2VQYXRoKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VQYXRoID0gaW1hZ2VQYXRoO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVNpemVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVNpemVzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJbWFnZVNpemVzID0gZnVuY3Rpb24gKGltYWdlU2l6ZXMpIHtcbiAgICAgICAgdGhpcy5pbWFnZVNpemVzID0gaW1hZ2VTaXplcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Q2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRvcjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0Q2FsY3VsYXRvciA9IGZ1bmN0aW9uIChjYWxjdWxhdG9yKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IGNhbGN1bGF0b3I7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEJhdGNoU2l6ZUlFID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaFNpemVJRTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0QmF0Y2hTaXplSUUgPSBmdW5jdGlvbiAoYmF0Y2hTaXplSUUpIHtcbiAgICAgICAgdGhpcy5iYXRjaFNpemVJRSA9IGJhdGNoU2l6ZUlFO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRDbHVzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJDbGFzcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0Q2x1c3RlckNsYXNzID0gZnVuY3Rpb24gKGNsdXN0ZXJDbGFzcykge1xuICAgICAgICB0aGlzLmNsdXN0ZXJDbGFzcyA9IGNsdXN0ZXJDbGFzcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VycztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0VG90YWxNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Q2x1c3RlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRUb3RhbENsdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVycy5sZW5ndGg7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIsIG9wdE5vRHJhdykge1xuICAgICAgICB0aGlzLnB1c2hNYXJrZXJUbyhtYXJrZXIpO1xuICAgICAgICBpZiAoIW9wdE5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMsIG9wdE5vRHJhdykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFya2Vycykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXJrZXJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE1hcmtlclRvKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0Tm9EcmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnB1c2hNYXJrZXJUbyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgYWRkIGEgbGlzdGVuZXIgc28gd2UgY2FuIHVwZGF0ZSB0aGUgY2x1c3RlcnMgb24gdGhlIGRyYWdlbmQ6XG4gICAgICAgIGlmIChtYXJrZXIuZ2V0RHJhZ2dhYmxlKCkpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZW1vdmVNYXJrZXJfID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5pbmRleE9mKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubWFya2Vycy5pbmRleE9mKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IHRoaXMubWFya2Vyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMsIHNvIGRvIG5vdGhpbmc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIGxpc3Qgb2YgbWFuYWdlZCBtYXJrZXJzXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZW1vdmVNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyLCBvcHROb0RyYXcpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLnJlbW92ZU1hcmtlcl8obWFya2VyKTtcbiAgICAgICAgaWYgKCFvcHROb0RyYXcgJiYgcmVtb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnJlbW92ZU1hcmtlcnMgPSBmdW5jdGlvbiAobWFya2Vycywgb3B0Tm9EcmF3KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbWFya2Vyc18yID0gbWFya2VyczsgX2kgPCBtYXJrZXJzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbWFya2Vyc18yW19pXTtcbiAgICAgICAgICAgIHJlbW92ZWQgPSByZW1vdmVkIHx8IHRoaXMucmVtb3ZlTWFya2VyXyhtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0Tm9EcmF3ICYmIHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5jbGVhck1hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXRWaWV3cG9ydCh0cnVlKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnJlcGFpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbGRDbHVzdGVycyA9IHRoaXMuY2x1c3RlcnMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlc2V0Vmlld3BvcnQoZmFsc2UpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBjbHVzdGVycy5cbiAgICAgICAgLy8gRG8gaXQgaW4gYSB0aW1lb3V0IHRvIHByZXZlbnQgYmxpbmtpbmcgZWZmZWN0LlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXQoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9sZENsdXN0ZXJzXzEgPSBvbGRDbHVzdGVyczsgX2kgPCBvbGRDbHVzdGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBvbGRDbHVzdGVyID0gb2xkQ2x1c3RlcnNfMVtfaV07XG4gICAgICAgICAgICAgICAgb2xkQ2x1c3Rlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEV4dGVuZGVkQm91bmRzID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBwb2ludHMgdG8gcGl4ZWxzIGFuZCB0aGUgZXh0ZW5kIG91dCBieSB0aGUgZ3JpZCBzaXplLlxuICAgICAgICB2YXIgdHJQaXggPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKFxuICAgICAgICAvLyBUdXJuIHRoZSBib3VuZHMgaW50byBsYXRsbmcuXG4gICAgICAgIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLmdldE5vcnRoRWFzdCgpLmxhdCgpLCBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpKTtcbiAgICAgICAgaWYgKHRyUGl4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0clBpeC54ICs9IHRoaXMuZ3JpZFNpemU7XG4gICAgICAgICAgICB0clBpeC55IC09IHRoaXMuZ3JpZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsUGl4ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChcbiAgICAgICAgLy8gVHVybiB0aGUgYm91bmRzIGludG8gbGF0bG5nLlxuICAgICAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sYXQoKSwgYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZygpKSk7XG4gICAgICAgIGlmIChibFBpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmxQaXgueCAtPSB0aGlzLmdyaWRTaXplO1xuICAgICAgICAgICAgYmxQaXgueSArPSB0aGlzLmdyaWRTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIG5ldyBib3VuZHMuXG4gICAgICAgIGlmICh0clBpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcGl4ZWwgcG9pbnRzIGJhY2sgdG8gTGF0TG5nIG53XG4gICAgICAgICAgICB2YXIgcG9pbnQxID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyh0clBpeCk7XG4gICAgICAgICAgICBpZiAocG9pbnQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4dGVuZChwb2ludDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChibFBpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcGl4ZWwgcG9pbnRzIGJhY2sgdG8gTGF0TG5nIHN3XG4gICAgICAgICAgICB2YXIgcG9pbnQyID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhibFBpeCk7XG4gICAgICAgICAgICBpZiAocG9pbnQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4dGVuZChwb2ludDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVkcmF3cyBhbGwgdGhlIGNsdXN0ZXJzLlxuICAgICAgICB0aGlzLmNyZWF0ZUNsdXN0ZXJzKDApO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKG9wdEhpZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgY2x1c3RlcnNcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2x1c3RlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2x1c3RlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGNsdXN0ZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgICAvLyBSZXNldCB0aGUgbWFya2VycyB0byBub3QgYmUgYWRkZWQgYW5kIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgbWFwLlxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5tYXJrZXJzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IF9jW19iXTtcbiAgICAgICAgICAgIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3B0SGlkZSkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICB2YXIgUiA9IDYzNzE7IC8vIFJhZGl1cyBvZiB0aGUgRWFydGggaW4ga21cbiAgICAgICAgdmFyIGRMYXQgPSAoKHAyLmxhdCgpIC0gcDEubGF0KCkpICogTWF0aC5QSSkgLyAxODA7XG4gICAgICAgIHZhciBkTG9uID0gKChwMi5sbmcoKSAtIHAxLmxuZygpKSAqIE1hdGguUEkpIC8gMTgwO1xuICAgICAgICB2YXIgYSA9IE1hdGguc2luKGRMYXQgLyAyKSAqIE1hdGguc2luKGRMYXQgLyAyKSArXG4gICAgICAgICAgICBNYXRoLmNvcygocDEubGF0KCkgKiBNYXRoLlBJKSAvIDE4MCkgKlxuICAgICAgICAgICAgICAgIE1hdGguY29zKChwMi5sYXQoKSAqIE1hdGguUEkpIC8gMTgwKSAqXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZExvbiAvIDIpICpcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihkTG9uIC8gMik7XG4gICAgICAgIHJldHVybiBSICogKDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSkpO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5pc01hcmtlckluQm91bmRzID0gZnVuY3Rpb24gKG1hcmtlciwgYm91bmRzKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHMuY29udGFpbnMocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuYWRkVG9DbG9zZXN0Q2x1c3RlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIGNsdXN0ZXI7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDQwMDAwOyAvLyBTb21lIGxhcmdlIG51bWJlclxuICAgICAgICB2YXIgY2x1c3RlclRvQWRkVG8gPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jbHVzdGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyRWxlbWVudCA9IF9hW19pXTtcbiAgICAgICAgICAgIGNsdXN0ZXIgPSBjbHVzdGVyRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBjbHVzdGVyLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY2VudGVyICYmIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlQmV0d2VlblBvaW50cyhjZW50ZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZDtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclRvQWRkVG8gPSBjbHVzdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2x1c3RlclRvQWRkVG8gJiYgY2x1c3RlclRvQWRkVG8uaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMobWFya2VyKSkge1xuICAgICAgICAgICAgY2x1c3RlclRvQWRkVG8uYWRkTWFya2VyKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbHVzdGVyID0gbmV3IENsdXN0ZXIkMSh0aGlzKTtcbiAgICAgICAgICAgIGNsdXN0ZXIuYWRkTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJzLnB1c2goY2x1c3Rlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuY3JlYXRlQ2x1c3RlcnMgPSBmdW5jdGlvbiAoaUZpcnN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbmNlbCBwcmV2aW91cyBiYXRjaCBwcm9jZXNzaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb24gdGhlIGZpcnN0IGJhdGNoOlxuICAgICAgICBpZiAoaUZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgPGNvZGU+Q2x1c3RlcmVyPC9jb2RlPiBiZWdpbnNcbiAgICAgICAgICAgICAqICBjbHVzdGVyaW5nIG1hcmtlcnMuXG4gICAgICAgICAgICAgKiBAbmFtZSBDbHVzdGVyZXIjY2x1c3RlcmluZ2JlZ2luXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJlcn0gbWMgVGhlIENsdXN0ZXJlciB3aG9zZSBtYXJrZXJzIGFyZSBiZWluZyBjbHVzdGVyZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnY2x1c3RlcmluZ2JlZ2luJywgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lclJlZlN0YXRpYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lclJlZlN0YXRpYyk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50aW1lclJlZlN0YXRpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hcCAhPT0gbnVsbCAmJiAnZ2V0Qm91bmRzJyBpbiBtYXAgPyBtYXAuZ2V0Qm91bmRzKCkgOiBudWxsO1xuICAgICAgICB2YXIgem9vbSA9IChtYXAgPT09IG51bGwgfHwgbWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXAuZ2V0Wm9vbSgpKSB8fCAwO1xuICAgICAgICAvLyBHZXQgb3VyIGN1cnJlbnQgbWFwIHZpZXcgYm91bmRzLlxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYm91bmRzIG9iamVjdCBzbyB3ZSBkb24ndCBhZmZlY3QgdGhlIG1hcC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlIENvbW1lbnRzIDkgJiAxMSBvbiBJc3N1ZSAzNjUxIHJlbGF0aW5nIHRvIHRoaXMgd29ya2Fyb3VuZCBmb3IgYSBHb29nbGUgTWFwcyBidWc6XG4gICAgICAgIHZhciBtYXBCb3VuZHMgPSB6b29tID4gM1xuICAgICAgICAgICAgPyBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgYm91bmRzID09PSBudWxsIHx8IGJvdW5kcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm91bmRzLmdldE5vcnRoRWFzdCgpKVxuICAgICAgICAgICAgOiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoODUuMDIwNzA3NzE3NDM0NzIsIC0xNzguNDgzODg0MzQzNzUpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKC04NS4wODEzNjQ0NDM4NDU0NCwgMTc4LjAwMDQ4ODY1NjI1KSk7XG4gICAgICAgIHZhciBleHRlbmRlZE1hcEJvdW5kcyA9IHRoaXMuZ2V0RXh0ZW5kZWRCb3VuZHMobWFwQm91bmRzKTtcbiAgICAgICAgdmFyIGlMYXN0ID0gTWF0aC5taW4oaUZpcnN0ICsgdGhpcy5iYXRjaFNpemUsIHRoaXMubWFya2Vycy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gaUZpcnN0OyBpIDwgaUxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMubWFya2Vyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgJiYgIW1hcmtlci5pc0FkZGVkICYmIHRoaXMuaXNNYXJrZXJJbkJvdW5kcyhtYXJrZXIsIGV4dGVuZGVkTWFwQm91bmRzKSAmJiAoIXRoaXMuaWdub3JlSGlkZGVuIHx8ICh0aGlzLmlnbm9yZUhpZGRlbiAmJiBtYXJrZXIuZ2V0VmlzaWJsZSgpKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvQ2xvc2VzdENsdXN0ZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaUxhc3QgPCB0aGlzLm1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUmVmU3RhdGljID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUNsdXN0ZXJzKGlMYXN0KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgPGNvZGU+Q2x1c3RlcmVyPC9jb2RlPiBzdG9wc1xuICAgICAgICAgICAgICogIGNsdXN0ZXJpbmcgbWFya2Vycy5cbiAgICAgICAgICAgICAqIEBuYW1lIENsdXN0ZXJlciNjbHVzdGVyaW5nZW5kXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJlcn0gbWMgVGhlIENsdXN0ZXJlciB3aG9zZSBtYXJrZXJzIGFyZSBiZWluZyBjbHVzdGVyZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnY2x1c3RlcmluZ2VuZCcsIHRoaXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2x1c3RlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsdXN0ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgY2x1c3Rlci51cGRhdGVJY29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXh0ZW5kKG9iamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdG90eXBlW3Byb3BdID0gb2JqZWN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LmFwcGx5KG9iajEsIFtvYmoyXSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2x1c3RlcmVyO1xufSgpKTtcblxudmFyIGV2ZW50TWFwJGUgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkNsdXN0ZXJpbmdCZWdpbjogJ2NsdXN0ZXJpbmdiZWdpbicsXG4gICAgb25DbHVzdGVyaW5nRW5kOiAnY2x1c3RlcmluZ2VuZCcsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG59O1xudmFyIHVwZGF0ZXJNYXAkZSA9IHtcbiAgICBhdmVyYWdlQ2VudGVyOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0QXZlcmFnZUNlbnRlcihhdmVyYWdlQ2VudGVyKTtcbiAgICB9LFxuICAgIGJhdGNoU2l6ZUlFOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGJhdGNoU2l6ZUlFKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEJhdGNoU2l6ZUlFKGJhdGNoU2l6ZUlFKTtcbiAgICB9LFxuICAgIGNhbGN1bGF0b3I6IGZ1bmN0aW9uIChpbnN0YW5jZSwgY2FsY3VsYXRvcikge1xuICAgICAgICBpbnN0YW5jZS5zZXRDYWxjdWxhdG9yKGNhbGN1bGF0b3IpO1xuICAgIH0sXG4gICAgY2x1c3RlckNsYXNzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNsdXN0ZXJDbGFzcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRDbHVzdGVyQ2xhc3MoY2x1c3RlckNsYXNzKTtcbiAgICB9LFxuICAgIGVuYWJsZVJldGluYUljb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVuYWJsZVJldGluYUljb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVuYWJsZVJldGluYUljb25zKGVuYWJsZVJldGluYUljb25zKTtcbiAgICB9LFxuICAgIGdyaWRTaXplOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGdyaWRTaXplKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEdyaWRTaXplKGdyaWRTaXplKTtcbiAgICB9LFxuICAgIGlnbm9yZUhpZGRlbjogZnVuY3Rpb24gKGluc3RhbmNlLCBpZ25vcmVIaWRkZW4pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SWdub3JlSGlkZGVuKGlnbm9yZUhpZGRlbik7XG4gICAgfSxcbiAgICBpbWFnZUV4dGVuc2lvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBpbWFnZUV4dGVuc2lvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRJbWFnZUV4dGVuc2lvbihpbWFnZUV4dGVuc2lvbik7XG4gICAgfSxcbiAgICBpbWFnZVBhdGg6IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW1hZ2VQYXRoKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEltYWdlUGF0aChpbWFnZVBhdGgpO1xuICAgIH0sXG4gICAgaW1hZ2VTaXplczogZnVuY3Rpb24gKGluc3RhbmNlLCBpbWFnZVNpemVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEltYWdlU2l6ZXMoaW1hZ2VTaXplcyk7XG4gICAgfSxcbiAgICBtYXhab29tOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1heFpvb20pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWF4Wm9vbShtYXhab29tKTtcbiAgICB9LFxuICAgIG1pbmltdW1DbHVzdGVyU2l6ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBtaW5pbXVtQ2x1c3RlclNpemUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWluaW11bUNsdXN0ZXJTaXplKG1pbmltdW1DbHVzdGVyU2l6ZSk7XG4gICAgfSxcbiAgICBzdHlsZXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3R5bGVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgIH0sXG4gICAgdGl0bGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGl0bGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VGl0bGUodGl0bGUpO1xuICAgIH0sXG4gICAgem9vbU9uQ2xpY2s6IGZ1bmN0aW9uIChpbnN0YW5jZSwgem9vbU9uQ2xpY2spIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Wm9vbU9uQ2xpY2soem9vbU9uQ2xpY2spO1xuICAgIH0sXG59O1xudmFyIGRlZmF1bHRPcHRpb25zJDQgPSB7fTtcbmZ1bmN0aW9uIE1hcmtlckNsdXN0ZXJlckZ1bmN0aW9uYWwocHJvcHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnMsIGF2ZXJhZ2VDZW50ZXIgPSBwcm9wcy5hdmVyYWdlQ2VudGVyLCBiYXRjaFNpemVJRSA9IHByb3BzLmJhdGNoU2l6ZUlFLCBjYWxjdWxhdG9yID0gcHJvcHMuY2FsY3VsYXRvciwgY2x1c3RlckNsYXNzID0gcHJvcHMuY2x1c3RlckNsYXNzLCBlbmFibGVSZXRpbmFJY29ucyA9IHByb3BzLmVuYWJsZVJldGluYUljb25zLCBncmlkU2l6ZSA9IHByb3BzLmdyaWRTaXplLCBpZ25vcmVIaWRkZW4gPSBwcm9wcy5pZ25vcmVIaWRkZW4sIGltYWdlRXh0ZW5zaW9uID0gcHJvcHMuaW1hZ2VFeHRlbnNpb24sIGltYWdlUGF0aCA9IHByb3BzLmltYWdlUGF0aCwgaW1hZ2VTaXplcyA9IHByb3BzLmltYWdlU2l6ZXMsIG1heFpvb20gPSBwcm9wcy5tYXhab29tLCBtaW5pbXVtQ2x1c3RlclNpemUgPSBwcm9wcy5taW5pbXVtQ2x1c3RlclNpemUsIHN0eWxlcyA9IHByb3BzLnN0eWxlcywgdGl0bGUgPSBwcm9wcy50aXRsZSwgem9vbU9uQ2xpY2sgPSBwcm9wcy56b29tT25DbGljaywgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssIG9uQ2x1c3RlcmluZ0JlZ2luID0gcHJvcHMub25DbHVzdGVyaW5nQmVnaW4sIG9uQ2x1c3RlcmluZ0VuZCA9IHByb3BzLm9uQ2x1c3RlcmluZ0VuZCwgb25Nb3VzZU92ZXIgPSBwcm9wcy5vbk1vdXNlT3Zlciwgb25Nb3VzZU91dCA9IHByb3BzLm9uTW91c2VPdXQsIG9uTG9hZCA9IHByb3BzLm9uTG9hZCwgb25Vbm1vdW50ID0gcHJvcHMub25Vbm1vdW50O1xuICAgIHZhciBfYSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9hWzBdLCBzZXRJbnN0YW5jZSA9IF9hWzFdO1xuICAgIHZhciBtYXAgPSByZWFjdC51c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjbGlja0xpc3RlbmVyID0gX2JbMF0sIHNldENsaWNrTGlzdGVuZXIgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIgPSBfY1swXSwgc2V0Q2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2x1c3RlcmluZ0VuZExpc3RlbmVyID0gX2RbMF0sIHNldENsdXN0ZXJpbmdFbmRMaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW91dExpc3RlbmVyID0gX2VbMF0sIHNldE1vdXNlb3V0TGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2VvdmVyTGlzdGVuZXIgPSBfZlswXSwgc2V0TW91c2VvdmVyTGlzdGVuZXIgPSBfZlsxXTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsIGV2ZW50TWFwJGUub25Nb3VzZU91dCwgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdXRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBldmVudE1hcCRlLm9uTW91c2VPdmVyLCBvbk1vdXNlT3ZlcikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdmVyXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBldmVudE1hcCRlLm9uQ2xpY2ssIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2x1c3RlcmluZ0JlZ2luKSB7XG4gICAgICAgICAgICBpZiAoY2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZXZlbnRNYXAkZS5vbkNsdXN0ZXJpbmdCZWdpbiwgb25DbHVzdGVyaW5nQmVnaW4pKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsdXN0ZXJpbmdCZWdpbl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsdXN0ZXJpbmdFbmQpIHtcbiAgICAgICAgICAgIGlmIChjbHVzdGVyaW5nRW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbHVzdGVyaW5nRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsIGV2ZW50TWFwJGUub25DbHVzdGVyaW5nRW5kLCBvbkNsdXN0ZXJpbmdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsdXN0ZXJpbmdFbmRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGF2ZXJhZ2VDZW50ZXIgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuYXZlcmFnZUNlbnRlcihpbnN0YW5jZSwgYXZlcmFnZUNlbnRlcik7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGF2ZXJhZ2VDZW50ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGJhdGNoU2l6ZUlFICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmJhdGNoU2l6ZUlFKGluc3RhbmNlLCBiYXRjaFNpemVJRSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGJhdGNoU2l6ZUlFXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxjdWxhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmNhbGN1bGF0b3IoaW5zdGFuY2UsIGNhbGN1bGF0b3IpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBjYWxjdWxhdG9yXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbHVzdGVyQ2xhc3MgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuY2x1c3RlckNsYXNzKGluc3RhbmNlLCBjbHVzdGVyQ2xhc3MpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBjbHVzdGVyQ2xhc3NdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuYWJsZVJldGluYUljb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmVuYWJsZVJldGluYUljb25zKGluc3RhbmNlLCBlbmFibGVSZXRpbmFJY29ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVuYWJsZVJldGluYUljb25zXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBncmlkU2l6ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5ncmlkU2l6ZShpbnN0YW5jZSwgZ3JpZFNpemUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBncmlkU2l6ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWdub3JlSGlkZGVuICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmlnbm9yZUhpZGRlbihpbnN0YW5jZSwgaWdub3JlSGlkZGVuKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgaWdub3JlSGlkZGVuXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZUV4dGVuc2lvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZUV4dGVuc2lvbihpbnN0YW5jZSwgaW1hZ2VFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBpbWFnZUV4dGVuc2lvbl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2VQYXRoICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmltYWdlUGF0aChpbnN0YW5jZSwgaW1hZ2VQYXRoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgaW1hZ2VQYXRoXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNpemVzICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmltYWdlU2l6ZXMoaW5zdGFuY2UsIGltYWdlU2l6ZXMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBpbWFnZVNpemVzXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhab29tICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLm1heFpvb20oaW5zdGFuY2UsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBtYXhab29tXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaW5pbXVtQ2x1c3RlclNpemUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUubWluaW11bUNsdXN0ZXJTaXplKGluc3RhbmNlLCBtaW5pbXVtQ2x1c3RlclNpemUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBtaW5pbXVtQ2x1c3RlclNpemVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5zdHlsZXMoaW5zdGFuY2UsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHN0eWxlc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUudGl0bGUoaW5zdGFuY2UsIHRpdGxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdGl0bGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHpvb21PbkNsaWNrICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLnpvb21PbkNsaWNrKGluc3RhbmNlLCB6b29tT25DbGljayk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHpvb21PbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjbHVzdGVyZXJPcHRpb25zID0gX19hc3NpZ24oe30sIChvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zJDQpKTtcbiAgICAgICAgdmFyIGNsdXN0ZXJlciA9IG5ldyBDbHVzdGVyZXIobWFwLCBbXSwgY2x1c3RlcmVyT3B0aW9ucyk7XG4gICAgICAgIGlmIChhdmVyYWdlQ2VudGVyKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuYXZlcmFnZUNlbnRlcihjbHVzdGVyZXIsIGF2ZXJhZ2VDZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaFNpemVJRSkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmJhdGNoU2l6ZUlFKGNsdXN0ZXJlciwgYmF0Y2hTaXplSUUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuY2FsY3VsYXRvcihjbHVzdGVyZXIsIGNhbGN1bGF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbHVzdGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5jbHVzdGVyQ2xhc3MoY2x1c3RlcmVyLCBjbHVzdGVyQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmVuYWJsZVJldGluYUljb25zKGNsdXN0ZXJlciwgZW5hYmxlUmV0aW5hSWNvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkU2l6ZSkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmdyaWRTaXplKGNsdXN0ZXJlciwgZ3JpZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZ25vcmVIaWRkZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pZ25vcmVIaWRkZW4oY2x1c3RlcmVyLCBpZ25vcmVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZUV4dGVuc2lvbikge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmltYWdlRXh0ZW5zaW9uKGNsdXN0ZXJlciwgaW1hZ2VFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVBhdGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVBhdGgoY2x1c3RlcmVyLCBpbWFnZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVNpemVzKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuaW1hZ2VTaXplcyhjbHVzdGVyZXIsIGltYWdlU2l6ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhab29tKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUubWF4Wm9vbShjbHVzdGVyZXIsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5pbXVtQ2x1c3RlclNpemUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5taW5pbXVtQ2x1c3RlclNpemUoY2x1c3RlcmVyLCBtaW5pbXVtQ2x1c3RlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5zdHlsZXMoY2x1c3RlcmVyLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLnRpdGxlKGNsdXN0ZXJlciwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tT25DbGljaykge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLnpvb21PbkNsaWNrKGNsdXN0ZXJlciwgem9vbU9uQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNsdXN0ZXJlciwgZXZlbnRNYXAkZS5vbk1vdXNlT3V0LCBvbk1vdXNlT3V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjbHVzdGVyZXIsIGV2ZW50TWFwJGUub25Nb3VzZU92ZXIsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uQ2xpY2ssIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbHVzdGVyaW5nQmVnaW4pIHtcbiAgICAgICAgICAgIHNldENsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNsdXN0ZXJlciwgZXZlbnRNYXAkZS5vbkNsdXN0ZXJpbmdCZWdpbiwgb25DbHVzdGVyaW5nQmVnaW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbHVzdGVyaW5nRW5kKSB7XG4gICAgICAgICAgICBzZXRDbHVzdGVyaW5nRW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uQ2x1c3RlcmluZ0VuZCwgb25DbHVzdGVyaW5nRW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5zdGFuY2UoY2x1c3RlcmVyKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKGNsdXN0ZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsdXN0ZXJpbmdFbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsdXN0ZXJpbmdFbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgb25Vbm1vdW50KGNsdXN0ZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpbnN0YW5jZSAhPT0gbnVsbCA/IGNoaWxkcmVuKGluc3RhbmNlKSB8fCBudWxsIDogbnVsbDtcbn1cbnZhciBNYXJrZXJDbHVzdGVyZXJGID0gcmVhY3QubWVtbyhNYXJrZXJDbHVzdGVyZXJGdW5jdGlvbmFsKTtcbnZhciBDbHVzdGVyZXJDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsdXN0ZXJlckNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbHVzdGVyZXJDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbWFya2VyQ2x1c3RlcmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRDbHVzdGVyZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2x1c3RlcmVyQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG1hcmtlckNsdXN0ZXJlcl8xID0gbmV3IENsdXN0ZXJlcih0aGlzLmNvbnRleHQsIFtdLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRlLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRlLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBtYXJrZXJDbHVzdGVyZXJfMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ2x1c3RlcmVyOiBtYXJrZXJDbHVzdGVyZXJfMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5zZXRDbHVzdGVyZXJDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlckNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlckNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyICE9PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICBDbHVzdGVyZXJDb21wb25lbnQuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBDbHVzdGVyZXJDb21wb25lbnQ7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxuLy8gVGhpcyBoYW5kbGVyIHByZXZlbnRzIGFuIGV2ZW50IGluIHRoZSBJbmZvQm94IGZyb20gYmVpbmcgcGFzc2VkIG9uIHRvIHRoZSBtYXAuXG5mdW5jdGlvbiBjYW5jZWxIYW5kbGVyKGV2ZW50KSB7XG4gICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbn1cbnZhciBJbmZvQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZm9Cb3gob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmdldENsb3NlQ2xpY2tIYW5kbGVyID0gdGhpcy5nZXRDbG9zZUNsaWNrSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlQ2xpY2tIYW5kbGVyID0gdGhpcy5jbG9zZUNsaWNrSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUluZm9Cb3hEaXYgPSB0aGlzLmNyZWF0ZUluZm9Cb3hEaXYuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRDbGlja0hhbmRsZXIgPSB0aGlzLmFkZENsaWNrSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENsb3NlQm94SW1nID0gdGhpcy5nZXRDbG9zZUJveEltZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEJveFdpZHRocyA9IHRoaXMuZ2V0Qm94V2lkdGhzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Qm94U3R5bGUgPSB0aGlzLnNldEJveFN0eWxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24gPSB0aGlzLnNldFBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldENvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlID0gdGhpcy5zZXRWaXNpYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q29udGVudCA9IHRoaXMuZ2V0Q29udGVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFZpc2libGUgPSB0aGlzLmdldFZpc2libGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRaSW5kZXggPSB0aGlzLnNldFpJbmRleC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFpJbmRleCA9IHRoaXMuZ2V0WkluZGV4LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW1vdmUgPSB0aGlzLm9uUmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFuQm94ID0gdGhpcy5wYW5Cb3guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSB0aGlzLmV4dGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRyYXcgPSB0aGlzLmRyYXcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlkZSA9IHRoaXMuaGlkZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW4gPSB0aGlzLm9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5leHRlbmQoSW5mb0JveCwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICAgICAgICAvLyBTdGFuZGFyZCBvcHRpb25zIChpbiBjb21tb24gd2l0aCBnb29nbGUubWFwcy5JbmZvV2luZG93KTpcbiAgICAgICAgdGhpcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgICAgICB0aGlzLmRpc2FibGVBdXRvUGFuID0gb3B0aW9ucy5kaXNhYmxlQXV0b1BhbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5waXhlbE9mZnNldCA9IG9wdGlvbnMucGl4ZWxPZmZzZXQgfHwgbmV3IGdvb2dsZS5tYXBzLlNpemUoMCwgMCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uIHx8IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMCwgMCk7XG4gICAgICAgIHRoaXMuekluZGV4ID0gb3B0aW9ucy56SW5kZXggfHwgbnVsbDtcbiAgICAgICAgLy8gQWRkaXRpb25hbCBvcHRpb25zICh1bmlxdWUgdG8gSW5mb0JveCk6XG4gICAgICAgIHRoaXMuYm94Q2xhc3MgPSBvcHRpb25zLmJveENsYXNzIHx8ICdpbmZvQm94JztcbiAgICAgICAgdGhpcy5ib3hTdHlsZSA9IG9wdGlvbnMuYm94U3R5bGUgfHwge307XG4gICAgICAgIHRoaXMuY2xvc2VCb3hNYXJnaW4gPSBvcHRpb25zLmNsb3NlQm94TWFyZ2luIHx8ICcycHgnO1xuICAgICAgICB0aGlzLmNsb3NlQm94VVJMID0gb3B0aW9ucy5jbG9zZUJveFVSTCB8fCAnaHR0cDovL3d3dy5nb29nbGUuY29tL2ludGwvZW5fdXMvbWFwZmlsZXMvY2xvc2UuZ2lmJztcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCb3hVUkwgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQm94VVJMID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvQm94Q2xlYXJhbmNlID0gb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlIHx8IG5ldyBnb29nbGUubWFwcy5TaXplKDEsIDEpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pc0hpZGRlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aXNpYmxlID0gIW9wdGlvbnMuaXNIaWRkZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICFvcHRpb25zLnZpc2libGU7XG4gICAgICAgIHRoaXMuYWxpZ25Cb3R0b20gPSBvcHRpb25zLmFsaWduQm90dG9tIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnBhbmUgPSBvcHRpb25zLnBhbmUgfHwgJ2Zsb2F0UGFuZSc7XG4gICAgICAgIHRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiA9IG9wdGlvbnMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXQgPSBudWxsO1xuICAgIH1cbiAgICBJbmZvQm94LnByb3RvdHlwZS5jcmVhdGVJbmZvQm94RGl2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXIgaWdub3JlcyB0aGUgY3VycmVudCBldmVudCBpbiB0aGUgSW5mb0JveCBhbmQgY29uZGl0aW9uYWxseSBwcmV2ZW50c1xuICAgICAgICAvLyB0aGUgZXZlbnQgZnJvbSBiZWluZyBwYXNzZWQgb24gdG8gdGhlIG1hcC4gSXQgaXMgdXNlZCBmb3IgdGhlIGNvbnRleHRtZW51IGV2ZW50LlxuICAgICAgICB2YXIgaWdub3JlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm94U3R5bGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKSArIHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhbmVzID0gdGhpcy5nZXRQYW5lcygpO1xuICAgICAgICAgICAgaWYgKHBhbmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFuZXNbdGhpcy5wYW5lXS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7IC8vIEFkZCB0aGUgSW5mb0JveCBkaXYgdG8gdGhlIERPTVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDbGlja0hhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdi5zdHlsZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRXaWR0aFNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCAhPT0gMCAmJiB0aGlzLmRpdi5vZmZzZXRXaWR0aCA+IHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSB0aGlzLm1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBpcyBuZWVkZWQgdG8gb3ZlcmNvbWUgcHJvYmxlbXMgd2l0aCBNU0lFXG4gICAgICAgICAgICAgICAgICAgIHZhciBidyA9IHRoaXMuZ2V0Qm94V2lkdGhzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gdGhpcy5kaXYub2Zmc2V0V2lkdGggLSBidy5sZWZ0IC0gYncucmlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhbkJveCh0aGlzLmRpc2FibGVBdXRvUGFuKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBtb3VzZW1vdmUgbm90IGluY2x1ZGVkICh0byByZXNvbHZlIElzc3VlIDE1MilcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gW1xuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlb3ZlcicsXG4gICAgICAgICAgICAgICAgICAgICdtb3VzZW91dCcsXG4gICAgICAgICAgICAgICAgICAgICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RibGNsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRzXzEgPSBldmVudHM7IF9pIDwgZXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gZXZlbnRzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaXYsIGV2ZW50XzEsIGNhbmNlbEhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgR29vZ2xlIGJ1ZyB0aGF0IGNhdXNlcyB0aGUgY3Vyc29yIHRvIGNoYW5nZSB0byBhIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIGEgbWFya2VyIHVuZGVybmVhdGggSW5mb0JveC5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaXYsICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LCAnY29udGV4dG1lbnUnLCBpZ25vcmVIYW5kbGVyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBESVYgY29udGFpbmluZyB0aGUgSW5mb0JveCdzIGNvbnRlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAqIEBuYW1lIEluZm9Cb3gjZG9tcmVhZHlcbiAgICAgICAgICAgICAqIEBldmVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdkb21yZWFkeScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5nZXRDbG9zZUJveEltZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltZyA9ICcnO1xuICAgICAgICBpZiAodGhpcy5jbG9zZUJveFVSTCAhPT0gJycpIHtcbiAgICAgICAgICAgIGltZyA9ICc8aW1nIGFsdD1cIlwiJztcbiAgICAgICAgICAgIGltZyArPSAnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiJztcbiAgICAgICAgICAgIGltZyArPSBcIiBzcmM9J1wiICsgdGhpcy5jbG9zZUJveFVSTCArIFwiJ1wiO1xuICAgICAgICAgICAgaW1nICs9ICcgYWxpZ249cmlnaHQnOyAvLyBEbyB0aGlzIGJlY2F1c2UgT3BlcmEgY2hva2VzIG9uIHN0eWxlPSdmbG9hdDogcmlnaHQ7J1xuICAgICAgICAgICAgaW1nICs9IFwiIHN0eWxlPSdcIjtcbiAgICAgICAgICAgIGltZyArPSAnIHBvc2l0aW9uOiByZWxhdGl2ZTsnOyAvLyBSZXF1aXJlZCBieSBNU0lFXG4gICAgICAgICAgICBpbWcgKz0gJyBjdXJzb3I6IHBvaW50ZXI7JztcbiAgICAgICAgICAgIGltZyArPSAnIG1hcmdpbjogJyArIHRoaXMuY2xvc2VCb3hNYXJnaW4gKyAnOyc7XG4gICAgICAgICAgICBpbWcgKz0gXCInPlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5hZGRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VMaXN0ZW5lciA9IHRoaXMuZGl2ICYmIHRoaXMuZGl2LmZpcnN0Q2hpbGQgJiYgdGhpcy5jbG9zZUJveFVSTCAhPT0gJydcbiAgICAgICAgICAgID8gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaXYuZmlyc3RDaGlsZCwgJ2NsaWNrJywgdGhpcy5nZXRDbG9zZUNsaWNrSGFuZGxlcigpKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuY2xvc2VDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gMS4wLjMgZml4OiBBbHdheXMgcHJldmVudCBwcm9wYWdhdGlvbiBvZiBhIGNsb3NlIGJveCBjbGljayB0byB0aGUgbWFwOlxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBJbmZvQm94J3MgY2xvc2UgYm94IGlzIGNsaWNrZWQuXG4gICAgICAgICAqIEBuYW1lIEluZm9Cb3gjY2xvc2VjbGlja1xuICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2Nsb3NlY2xpY2snKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlQ2xpY2tIYW5kbGVyO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUucGFuQm94ID0gZnVuY3Rpb24gKGRpc2FibGVQYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGl2ICYmICFkaXNhYmxlUGFuKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgcGFuIGlmIGF0dGFjaGVkIHRvIG1hcCwgbm90IHBhbm9yYW1hXG4gICAgICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gbWFwLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5jb250YWlucyh0aGlzLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrZXIgbm90IGluIHZpc2libGUgYXJlYSBvZiBtYXAsIHNvIHNldCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgbWFwIHRvIHRoZSBtYXJrZXIgcG9zaXRpb24gZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXRDZW50ZXIodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXBEaXYgPSBtYXAuZ2V0RGl2KCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgbWFwV2lkdGggPSBtYXBEaXYub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgbWFwSGVpZ2h0ID0gbWFwRGl2Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgaXdPZmZzZXRYID0gdGhpcy5waXhlbE9mZnNldC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaXdPZmZzZXRZID0gdGhpcy5waXhlbE9mZnNldC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGl3V2lkdGggPSB0aGlzLmRpdi5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaXdIZWlnaHQgPSB0aGlzLmRpdi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhZFggPSB0aGlzLmluZm9Cb3hDbGVhcmFuY2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHBhZFkgPSB0aGlzLmluZm9Cb3hDbGVhcmFuY2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgcGl4UG9zaXRpb24gPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0NvbnRhaW5lclBpeGVsKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChwaXhQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGl4UG9zaXRpb24ueCA8IC1pd09mZnNldFggKyBwYWRYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gcGl4UG9zaXRpb24ueCArIGl3T2Zmc2V0WCAtIHBhZFg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGl4UG9zaXRpb24ueCArIGl3V2lkdGggKyBpd09mZnNldFggKyBwYWRYID4gbWFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhPZmZzZXQgPSBwaXhQb3NpdGlvbi54ICsgaXdXaWR0aCArIGl3T2Zmc2V0WCArIHBhZFggLSBtYXBXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGlnbkJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeFBvc2l0aW9uLnkgPCAtaXdPZmZzZXRZICsgcGFkWSArIGl3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgLSBwYWRZIC0gaXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaXhQb3NpdGlvbi55ICsgaXdPZmZzZXRZICsgcGFkWSA+IG1hcEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdPZmZzZXRZICsgcGFkWSAtIG1hcEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhQb3NpdGlvbi55IDwgLWl3T2Zmc2V0WSArIHBhZFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSAtIHBhZFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaXhQb3NpdGlvbi55ICsgaXdIZWlnaHQgKyBpd09mZnNldFkgKyBwYWRZID4gbWFwSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd0hlaWdodCArIGl3T2Zmc2V0WSArIHBhZFkgLSBtYXBIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoeE9mZnNldCA9PT0gMCAmJiB5T2Zmc2V0ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBtYXAgdG8gdGhlIHNoaWZ0ZWQgY2VudGVyLlxuICAgICAgICAgICAgICAgICAgICBtYXAucGFuQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRCb3hTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICAvLyBBcHBseSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgc3R5bGUgc2hlZXQgZGVmaW5lZCBpbiB0aGUgYm94Q2xhc3MgcGFyYW1ldGVyOlxuICAgICAgICAgICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5ib3hDbGFzcztcbiAgICAgICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGlubGluZSBzdHlsZSB2YWx1ZXM6XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5jc3NUZXh0ID0gJyc7XG4gICAgICAgICAgICAvLyBBcHBseSBzdHlsZSB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgYm94U3R5bGUgcGFyYW1ldGVyOlxuICAgICAgICAgICAgdmFyIGJveFN0eWxlID0gdGhpcy5ib3hTdHlsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYm94U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGJveFN0eWxlLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGVbaV0gPSBib3hTdHlsZVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXggZm9yIGlPUyBkaXNhcHBlYXJpbmcgSW5mb0JveCBwcm9ibGVtXG4gICAgICAgICAgICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85MjI5NTM1L2dvb2dsZS1tYXBzLW1hcmtlcnMtZGlzYXBwZWFyLWF0LWNlcnRhaW4tem9vbS1sZXZlbC1vbmx5LW9uLWlwaG9uZS1pcGFkXG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgICAgICAvLyBGaXggdXAgb3BhY2l0eSBzdHlsZSBmb3IgYmVuZWZpdCBvZiBNU0lFXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGl2LnN0eWxlLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuZGl2LnN0eWxlLm9wYWNpdHkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvY3NzL29wYWNpdHkuaHRtbFxuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyc2VGbG9hdCh0aGlzLmRpdi5zdHlsZS5vcGFjaXR5IHx8ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLm1zRmlsdGVyID1cbiAgICAgICAgICAgICAgICAgICAgJ1wicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9JyArIG9wYWNpdHkgKiAxMDAgKyAnKVwiJztcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5maWx0ZXIgPSAnYWxwaGEob3BhY2l0eT0nICsgb3BhY2l0eSAqIDEwMCArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IHJlcXVpcmVkIHN0eWxlc1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgaWYgKHRoaXMuekluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXggKyAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXYuc3R5bGUub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Qm94V2lkdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYncgPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICAgICAgICByZXR1cm4gYnc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZGl2Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IG93bmVyRG9jdW1lbnQgJiYgb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICAgICAgICAgICAgID8gb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZGl2LCAnJylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wdXRlZCBzdHlsZXMgYXJlIGFsd2F5cyBpbiBwaXhlbCB1bml0cyAoZ29vZCEpXG4gICAgICAgICAgICAgICAgYncudG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncubGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBidy5yaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlIC8vIE1TSUVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0eWxlID0gdGhpcy5kaXYuY3VycmVudFN0eWxlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHN0eWxlcyBtYXkgbm90IGJlIGluIHBpeGVsIHVuaXRzLCBidXQgYXNzdW1lIHRoZXkgYXJlIChiYWQhKVxuICAgICAgICAgICAgICAgIGJ3LnRvcCA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBidy5sZWZ0ID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlckxlZnRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncucmlnaHQgPSBwYXJzZUludChjdXJyZW50U3R5bGUuYm9yZGVyUmlnaHRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ3O1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVJbmZvQm94RGl2KCk7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBwaXhQb3NpdGlvbiA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAocGl4UG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gcGl4UG9zaXRpb24ueCArIHRoaXMucGl4ZWxPZmZzZXQud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsaWduQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLmJvdHRvbSA9IC0ocGl4UG9zaXRpb24ueSArIHRoaXMucGl4ZWxPZmZzZXQuaGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSBwaXhQb3NpdGlvbi55ICsgdGhpcy5waXhlbE9mZnNldC5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ib3hDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgZmlyc3RcbiAgICAgICAgICAgIHRoaXMuYm94Q2xhc3MgPSBvcHRpb25zLmJveENsYXNzO1xuICAgICAgICAgICAgdGhpcy5zZXRCb3hTdHlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ib3hTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgc2Vjb25kXG4gICAgICAgICAgICB0aGlzLmJveFN0eWxlID0gb3B0aW9ucy5ib3hTdHlsZTtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm94U3R5bGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGVudChvcHRpb25zLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kaXNhYmxlQXV0b1BhbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUF1dG9QYW4gPSBvcHRpb25zLmRpc2FibGVBdXRvUGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMubWF4V2lkdGggPSBvcHRpb25zLm1heFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5waXhlbE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxPZmZzZXQgPSBvcHRpb25zLnBpeGVsT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGlnbkJvdHRvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25Cb3R0b20gPSBvcHRpb25zLmFsaWduQm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnpJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KG9wdGlvbnMuekluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xvc2VCb3hNYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQm94TWFyZ2luID0gb3B0aW9ucy5jbG9zZUJveE1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xvc2VCb3hVUkwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQm94VVJMID0gb3B0aW9ucy5jbG9zZUJveFVSTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5mb0JveENsZWFyYW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0JveENsZWFyYW5jZSA9IG9wdGlvbnMuaW5mb0JveENsZWFyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gb3B0aW9ucy5pc0hpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSAhb3B0aW9ucy52aXNpYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lbmFibGVFdmVudFByb3BhZ2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVFdmVudFByb3BhZ2F0aW9uID0gb3B0aW9ucy5lbmFibGVFdmVudFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNsb3NlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPZGQgY29kZSByZXF1aXJlZCB0byBtYWtlIHRoaW5ncyB3b3JrIHdpdGggTVNJRS5cbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFdpZHRoU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCkgKyBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVydmVyc2UgY29kZSByZXF1aXJlZCB0byBtYWtlIHRoaW5ncyB3b3JrIHdpdGggTVNJRS5cbiAgICAgICAgICAgIC8vIChFbnN1cmVzIHRoZSBjbG9zZSBib3ggZG9lcywgaW4gZmFjdCwgZmxvYXQgdG8gdGhlIHJpZ2h0LilcbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFdpZHRoU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSB0aGlzLmRpdi5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCkgKyBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZENsaWNrSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICAgICAgICogQG5hbWUgSW5mb0JveCNjb250ZW50X2NoYW5nZWRcbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdjb250ZW50X2NoYW5nZWQnKTtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbGF0TG5nO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBJbmZvQm94IGNoYW5nZXMuXG4gICAgICAgICAqIEBuYW1lIEluZm9Cb3gjcG9zaXRpb25fY2hhbmdlZFxuICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ3Bvc2l0aW9uX2NoYW5nZWQnKTtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSAhaXNWaXNpYmxlO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLmlzSGlkZGVuID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnpJbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IGluZGV4ICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgekluZGV4IG9mIHRoZSBJbmZvQm94IGNoYW5nZXMuXG4gICAgICAgICAqIEBuYW1lIEluZm9Cb3gjemluZGV4X2NoYW5nZWRcbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICd6aW5kZXhfY2hhbmdlZCcpO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuekluZGV4O1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWFwID09PSAndW5kZWZpbmVkJyB8fCBtYXAgPT09IG51bGwgPyBmYWxzZSA6ICF0aGlzLmlzSGlkZGVuO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtYXAsIGFuY2hvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGFuY2hvciwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBhbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihhbmNob3IsICdtYXBfY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIF90aGlzLnNldE1hcChhbmNob3IubWFwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgdGhpcy5wYW5Cb3goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY2xvc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5ldmVudExpc3RlbmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihldmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5tb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLm1hcExpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5jb250ZXh0TGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNldE1hcChudWxsKTtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUV4dGVuZChvYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdG90eXBlW3Byb3BlcnR5XSA9IG9iamVjdC5wcm90b3R5cGVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LmFwcGx5KG9iajEsIFtvYmoyXSk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mb0JveDtcbn0oKSk7XG5cbnZhciBldmVudE1hcCRkID0ge1xuICAgIG9uQ2xvc2VDbGljazogJ2Nsb3NlY2xpY2snLFxuICAgIG9uQ29udGVudENoYW5nZWQ6ICdjb250ZW50X2NoYW5nZWQnLFxuICAgIG9uRG9tUmVhZHk6ICdkb21yZWFkeScsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblppbmRleENoYW5nZWQ6ICd6aW5kZXhfY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAkZCA9IHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24obmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbi5sYXQsIHBvc2l0aW9uLmxuZykpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxuICAgIHpJbmRleDogZnVuY3Rpb24gKGluc3RhbmNlLCB6SW5kZXgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkMyA9IHt9O1xuZnVuY3Rpb24gSW5mb0JveEZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgYW5jaG9yID0gX2EuYW5jaG9yLCBvcHRpb25zID0gX2Eub3B0aW9ucywgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgekluZGV4ID0gX2EuekluZGV4LCBvbkNsb3NlQ2xpY2sgPSBfYS5vbkNsb3NlQ2xpY2ssIG9uRG9tUmVhZHkgPSBfYS5vbkRvbVJlYWR5LCBvbkNvbnRlbnRDaGFuZ2VkID0gX2Eub25Db250ZW50Q2hhbmdlZCwgb25Qb3NpdGlvbkNoYW5nZWQgPSBfYS5vblBvc2l0aW9uQ2hhbmdlZCwgb25aaW5kZXhDaGFuZ2VkID0gX2Eub25aaW5kZXhDaGFuZ2VkLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gcmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2xvc2VDbGlja0xpc3RlbmVyID0gX2NbMF0sIHNldENsb3NlQ2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkb21SZWFkeUNsaWNrTGlzdGVuZXIgPSBfZFswXSwgc2V0RG9tUmVhZHlDbGlja0xpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGNvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9lWzBdLCBzZXRDb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgcG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9mWzBdLCBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHpJbmRleENoYW5nZWRDbGlja0xpc3RlbmVyID0gX2dbMF0sIHNldFppbmRleENoYW5nZWRDbGlja0xpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIGNvbnRhaW5lckVsZW1lbnRSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm9wZW4obWFwLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm9wZW4obWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXAsIGluc3RhbmNlLCBhbmNob3JdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uTGF0TG5nID0gcG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmdcbiAgICAgICAgICAgICAgICA/IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocG9zaXRpb24ubGF0LCBwb3NpdGlvbi5sbmcpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb25MYXRMbmcpO1xuICAgICAgICB9XG4gICAgfSwgW3Bvc2l0aW9uXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB6SW5kZXggPT09ICdudW1iZXInICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sIFt6SW5kZXhdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbG9zZUNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xvc2VDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsb3NlQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsb3NlQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Eb21SZWFkeSkge1xuICAgICAgICAgICAgaWYgKGRvbVJlYWR5Q2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbVJlYWR5Q2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRvbVJlYWR5XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY29udGVudF9jaGFuZ2VkJywgb25Db250ZW50Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ29udGVudENoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Qb3NpdGlvbkNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25aaW5kZXhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoekluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25aaW5kZXhDaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgdmFyIF9hID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQzLCBwb3NpdGlvbl8xID0gX2EucG9zaXRpb24sIGluZm9Cb3hPcHRpb25zID0gX19yZXN0JDEoX2EsIFtcInBvc2l0aW9uXCJdKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkxhdExuZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbl8xICYmICEocG9zaXRpb25fMSBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTGF0TG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbl8xLmxhdCwgcG9zaXRpb25fMS5sbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZm9Cb3ggPSBuZXcgSW5mb0JveChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mb0JveE9wdGlvbnMpLCAocG9zaXRpb25MYXRMbmcgPyB7IHBvc2l0aW9uOiBwb3NpdGlvbkxhdExuZyB9IDoge30pKSk7XG4gICAgICAgICAgICBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHNldEluc3RhbmNlKGluZm9Cb3gpO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2VDbGljaykge1xuICAgICAgICAgICAgICAgIHNldENsb3NlQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvQm94LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRG9tUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb0JveCwgJ2RvbXJlYWR5Jywgb25Eb21SZWFkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRDb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb0JveCwgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb0JveCwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHNldFppbmRleENoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9Cb3gsICd6aW5kZXhfY2hhbmdlZCcsIG9uWmluZGV4Q2hhbmdlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mb0JveC5zZXRDb250ZW50KGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaW5mb0JveC5vcGVuKG1hcCwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZm9Cb3guZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluZm9Cb3gub3BlbihtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50JDEoZmFsc2UsICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3Igb3IgYSBwb3NpdGlvbiBwcm9wIGZvciA8SW5mb0JveD4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkKGluZm9Cb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsb3NlQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvbVJlYWR5Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkb21SZWFkeUNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHpJbmRleENoYW5nZWRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHpJbmRleENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvblVubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gY29udGFpbmVyRWxlbWVudFJlZi5jdXJyZW50ID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKHJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpIDogbnVsbDtcbn1cbnZhciBJbmZvQm94RiA9IHJlYWN0Lm1lbW8oSW5mb0JveEZ1bmN0aW9uYWwpO1xudmFyIEluZm9Cb3hDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZm9Cb3hDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mb0JveENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5mb0JveDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub3BlbiA9IGZ1bmN0aW9uIChpbmZvQm94LCBhbmNob3IpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvQm94Lm9wZW4oX3RoaXMuY29udGV4dCwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmZvQm94LmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvQm94Lm9wZW4oX3RoaXMuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50JDEoZmFsc2UsICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3Igb3IgYSBwb3NpdGlvbiBwcm9wIGZvciA8SW5mb0JveD4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEluZm9Cb3hDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5pbmZvQm94ICE9PSBudWxsICYmIF90aGlzLmNvbnRhaW5lckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5pbmZvQm94LnNldENvbnRlbnQoX3RoaXMuY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbihfdGhpcy5zdGF0ZS5pbmZvQm94LCBfdGhpcy5wcm9wcy5hbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmluZm9Cb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbmZvQm94Q29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9LCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCBpbmZvQm94T3B0aW9ucyA9IF9fcmVzdCQxKF9hLCBbXCJwb3NpdGlvblwiXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbkxhdExuZztcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmICEocG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBwb3NpdGlvbkxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocG9zaXRpb24ubGF0LCBwb3NpdGlvbi5sbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZvQm94ID0gbmV3IEluZm9Cb3goX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm9Cb3hPcHRpb25zKSwgKHBvc2l0aW9uTGF0TG5nID8geyBwb3NpdGlvbjogcG9zaXRpb25MYXRMbmcgfSA6IHt9KSkpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGQsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5mb0JveCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbmZvQm94OiBpbmZvQm94IH0sIHRoaXMuc2V0SW5mb0JveENhbGxiYWNrKTtcbiAgICB9O1xuICAgIEluZm9Cb3hDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIGluZm9Cb3ggPSB0aGlzLnN0YXRlLmluZm9Cb3g7XG4gICAgICAgIGlmIChpbmZvQm94ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGQsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGQsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbmZvQm94LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3hDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb25Vbm1vdW50ID0gdGhpcy5wcm9wcy5vblVubW91bnQ7XG4gICAgICAgIHZhciBpbmZvQm94ID0gdGhpcy5zdGF0ZS5pbmZvQm94O1xuICAgICAgICBpZiAoaW5mb0JveCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudChpbmZvQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGluZm9Cb3guY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbGVtZW50ID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKHJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHRoaXMuY29udGFpbmVyRWxlbWVudCkgOiBudWxsO1xuICAgIH07XG4gICAgSW5mb0JveENvbXBvbmVudC5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEluZm9Cb3hDb21wb25lbnQ7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG52YXIgZmFzdERlZXBFcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG52YXIgZXF1YWwgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdERlZXBFcXVhbCk7XG5cbmNvbnN0IEFSUkFZX1RZUEVTID0gW1xuICAgIEludDhBcnJheSwgVWludDhBcnJheSwgVWludDhDbGFtcGVkQXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LFxuICAgIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheVxuXTtcblxuLyoqIEB0eXBlZGVmIHtJbnQ4QXJyYXlDb25zdHJ1Y3RvciB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvciB8IFVpbnQ4Q2xhbXBlZEFycmF5Q29uc3RydWN0b3IgfCBJbnQxNkFycmF5Q29uc3RydWN0b3IgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yIHwgSW50MzJBcnJheUNvbnN0cnVjdG9yIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvciB8IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgRmxvYXQ2NEFycmF5Q29uc3RydWN0b3J9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAqL1xuXG5jb25zdCBWRVJTSU9OID0gMTsgLy8gc2VyaWFsaXplZCBmb3JtYXQgdmVyc2lvblxuY29uc3QgSEVBREVSX1NJWkUgPSA4O1xuXG5jbGFzcyBLREJ1c2gge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmRleCBmcm9tIHJhdyBgQXJyYXlCdWZmZXJgIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQXJyYXlCdWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW21hZ2ljLCB2ZXJzaW9uQW5kVHlwZV0gPSBuZXcgVWludDhBcnJheShkYXRhLCAwLCAyKTtcbiAgICAgICAgaWYgKG1hZ2ljICE9PSAweGRiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGluIGEgS0RCdXNoIGZvcm1hdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbkFuZFR5cGUgPj4gNDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFZFUlNJT04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHYke3ZlcnNpb259IGRhdGEgd2hlbiBleHBlY3RlZCB2JHtWRVJTSU9OfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBBcnJheVR5cGUgPSBBUlJBWV9UWVBFU1t2ZXJzaW9uQW5kVHlwZSAmIDB4MGZdO1xuICAgICAgICBpZiAoIUFycmF5VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgYXJyYXkgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbm9kZVNpemVdID0gbmV3IFVpbnQxNkFycmF5KGRhdGEsIDIsIDEpO1xuICAgICAgICBjb25zdCBbbnVtSXRlbXNdID0gbmV3IFVpbnQzMkFycmF5KGRhdGEsIDQsIDEpO1xuXG4gICAgICAgIHJldHVybiBuZXcgS0RCdXNoKG51bUl0ZW1zLCBub2RlU2l6ZSwgQXJyYXlUeXBlLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluZGV4IHRoYXQgd2lsbCBob2xkIGEgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZVNpemU9NjRdIFNpemUgb2YgdGhlIEtELXRyZWUgbm9kZSAoNjQgYnkgZGVmYXVsdCkuXG4gICAgICogQHBhcmFtIHtUeXBlZEFycmF5Q29uc3RydWN0b3J9IFtBcnJheVR5cGU9RmxvYXQ2NEFycmF5XSBUaGUgYXJyYXkgdHlwZSB1c2VkIGZvciBjb29yZGluYXRlcyBzdG9yYWdlIChgRmxvYXQ2NEFycmF5YCBieSBkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBbZGF0YV0gKEZvciBpbnRlcm5hbCB1c2Ugb25seSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihudW1JdGVtcywgbm9kZVNpemUgPSA2NCwgQXJyYXlUeXBlID0gRmxvYXQ2NEFycmF5LCBkYXRhKSB7XG4gICAgICAgIGlmIChpc05hTihudW1JdGVtcykgfHwgbnVtSXRlbXMgPCAwKSB0aHJvdyBuZXcgRXJyb3IoYFVucGV4cGVjdGVkIG51bUl0ZW1zIHZhbHVlOiAke251bUl0ZW1zfS5gKTtcblxuICAgICAgICB0aGlzLm51bUl0ZW1zID0gK251bUl0ZW1zO1xuICAgICAgICB0aGlzLm5vZGVTaXplID0gTWF0aC5taW4oTWF0aC5tYXgoK25vZGVTaXplLCAyKSwgNjU1MzUpO1xuICAgICAgICB0aGlzLkFycmF5VHlwZSA9IEFycmF5VHlwZTtcbiAgICAgICAgdGhpcy5JbmRleEFycmF5VHlwZSA9IG51bUl0ZW1zIDwgNjU1MzYgPyBVaW50MTZBcnJheSA6IFVpbnQzMkFycmF5O1xuXG4gICAgICAgIGNvbnN0IGFycmF5VHlwZUluZGV4ID0gQVJSQVlfVFlQRVMuaW5kZXhPZih0aGlzLkFycmF5VHlwZSk7XG4gICAgICAgIGNvbnN0IGNvb3Jkc0J5dGVTaXplID0gbnVtSXRlbXMgKiAyICogdGhpcy5BcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIGNvbnN0IGlkc0J5dGVTaXplID0gbnVtSXRlbXMgKiB0aGlzLkluZGV4QXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBjb25zdCBwYWRDb29yZHMgPSAoOCAtIGlkc0J5dGVTaXplICUgOCkgJSA4O1xuXG4gICAgICAgIGlmIChhcnJheVR5cGVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlZCBhcnJheSBjbGFzczogJHtBcnJheVR5cGV9LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHsgLy8gcmVjb25zdHJ1Y3QgYW4gaW5kZXggZnJvbSBhIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuaWRzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSwgbnVtSXRlbXMpO1xuICAgICAgICAgICAgdGhpcy5jb29yZHMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzLCBudW1JdGVtcyAqIDIpO1xuICAgICAgICAgICAgdGhpcy5fcG9zID0gbnVtSXRlbXMgKiAyO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgeyAvLyBpbml0aWFsaXplIGEgbmV3IGluZGV4XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXlCdWZmZXIoSEVBREVSX1NJWkUgKyBjb29yZHNCeXRlU2l6ZSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMuaWRzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSwgbnVtSXRlbXMpO1xuICAgICAgICAgICAgdGhpcy5jb29yZHMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzLCBudW1JdGVtcyAqIDIpO1xuICAgICAgICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIHNldCBoZWFkZXJcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgMCwgMikuc2V0KFsweGRiLCAoVkVSU0lPTiA8PCA0KSArIGFycmF5VHlwZUluZGV4XSk7XG4gICAgICAgICAgICBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLCAyLCAxKVswXSA9IG5vZGVTaXplO1xuICAgICAgICAgICAgbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YSwgNCwgMSlbMF0gPSBudW1JdGVtcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHBvaW50IHRvIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn0gQW4gaW5jcmVtZW50YWwgaW5kZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBhZGRlZCBpdGVtIChzdGFydGluZyBmcm9tIGAwYCkuXG4gICAgICovXG4gICAgYWRkKHgsIHkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wb3MgPj4gMTtcbiAgICAgICAgdGhpcy5pZHNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgIHRoaXMuY29vcmRzW3RoaXMuX3BvcysrXSA9IHg7XG4gICAgICAgIHRoaXMuY29vcmRzW3RoaXMuX3BvcysrXSA9IHk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGluZGV4aW5nIG9mIHRoZSBhZGRlZCBwb2ludHMuXG4gICAgICovXG4gICAgZmluaXNoKCkge1xuICAgICAgICBjb25zdCBudW1BZGRlZCA9IHRoaXMuX3BvcyA+PiAxO1xuICAgICAgICBpZiAobnVtQWRkZWQgIT09IHRoaXMubnVtSXRlbXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkZWQgJHtudW1BZGRlZH0gaXRlbXMgd2hlbiBleHBlY3RlZCAke3RoaXMubnVtSXRlbXN9LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtkLXNvcnQgYm90aCBhcnJheXMgZm9yIGVmZmljaWVudCBzZWFyY2hcbiAgICAgICAgc29ydCh0aGlzLmlkcywgdGhpcy5jb29yZHMsIHRoaXMubm9kZVNpemUsIDAsIHRoaXMubnVtSXRlbXMgLSAxLCAwKTtcblxuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgaW5kZXggZm9yIGl0ZW1zIHdpdGhpbiBhIGdpdmVuIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgaW5kaWNlcyBjb3JyZXBvbmRpbmcgdG8gdGhlIGZvdW5kIGl0ZW1zLlxuICAgICAqL1xuICAgIHJhbmdlKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG5vdCB5ZXQgaW5kZXhlZCAtIGNhbGwgaW5kZXguZmluaXNoKCkuJyk7XG5cbiAgICAgICAgY29uc3Qge2lkcywgY29vcmRzLCBub2RlU2l6ZX0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzdGFjayA9IFswLCBpZHMubGVuZ3RoIC0gMSwgMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgaXRlbXMgaW4gcmFuZ2UgaW4gdGhlIGtkLXNvcnRlZCBhcnJheXNcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IHN0YWNrLnBvcCgpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHN0YWNrLnBvcCgpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc3RhY2sucG9wKCkgfHwgMDtcblxuICAgICAgICAgICAgLy8gaWYgd2UgcmVhY2hlZCBcInRyZWUgbm9kZVwiLCBzZWFyY2ggbGluZWFybHlcbiAgICAgICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbMiAqIGldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID49IG1pblggJiYgeCA8PSBtYXhYICYmIHkgPj0gbWluWSAmJiB5IDw9IG1heFkpIHJlc3VsdC5wdXNoKGlkc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmluZCB0aGUgbWlkZGxlIGluZGV4XG4gICAgICAgICAgICBjb25zdCBtID0gKGxlZnQgKyByaWdodCkgPj4gMTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgbWlkZGxlIGl0ZW0gaWYgaXQncyBpbiByYW5nZVxuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1syICogbV07XG4gICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBtICsgMV07XG4gICAgICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSByZXN1bHQucHVzaChpZHNbbV0pO1xuXG4gICAgICAgICAgICAvLyBxdWV1ZSBzZWFyY2ggaW4gaGFsdmVzIHRoYXQgaW50ZXJzZWN0IHRoZSBxdWVyeVxuICAgICAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBtaW5YIDw9IHggOiBtaW5ZIDw9IHkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGxlZnQpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobSAtIDEpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goMSAtIGF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBtYXhYID49IHggOiBtYXhZID49IHkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG0gKyAxKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKDEgLSBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRoZSBpbmRleCBmb3IgaXRlbXMgd2l0aGluIGEgZ2l2ZW4gcmFkaXVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIFF1ZXJ5IHJhZGl1cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IEFuIGFycmF5IG9mIGluZGljZXMgY29ycmVwb25kaW5nIHRvIHRoZSBmb3VuZCBpdGVtcy5cbiAgICAgKi9cbiAgICB3aXRoaW4ocXgsIHF5LCByKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHRocm93IG5ldyBFcnJvcignRGF0YSBub3QgeWV0IGluZGV4ZWQgLSBjYWxsIGluZGV4LmZpbmlzaCgpLicpO1xuXG4gICAgICAgIGNvbnN0IHtpZHMsIGNvb3Jkcywgbm9kZVNpemV9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbMCwgaWRzLmxlbmd0aCAtIDEsIDBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgcjIgPSByICogcjtcblxuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIGl0ZW1zIHdpdGhpbiByYWRpdXMgaW4gdGhlIGtkLXNvcnRlZCBhcnJheXNcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IHN0YWNrLnBvcCgpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHN0YWNrLnBvcCgpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gc3RhY2sucG9wKCkgfHwgMDtcblxuICAgICAgICAgICAgLy8gaWYgd2UgcmVhY2hlZCBcInRyZWUgbm9kZVwiLCBzZWFyY2ggbGluZWFybHlcbiAgICAgICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcURpc3QoY29vcmRzWzIgKiBpXSwgY29vcmRzWzIgKiBpICsgMV0sIHF4LCBxeSkgPD0gcjIpIHJlc3VsdC5wdXNoKGlkc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmluZCB0aGUgbWlkZGxlIGluZGV4XG4gICAgICAgICAgICBjb25zdCBtID0gKGxlZnQgKyByaWdodCkgPj4gMTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgbWlkZGxlIGl0ZW0gaWYgaXQncyBpbiByYW5nZVxuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1syICogbV07XG4gICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBtICsgMV07XG4gICAgICAgICAgICBpZiAoc3FEaXN0KHgsIHksIHF4LCBxeSkgPD0gcjIpIHJlc3VsdC5wdXNoKGlkc1ttXSk7XG5cbiAgICAgICAgICAgIC8vIHF1ZXVlIHNlYXJjaCBpbiBoYWx2ZXMgdGhhdCBpbnRlcnNlY3QgdGhlIHF1ZXJ5XG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gMCA/IHF4IC0gciA8PSB4IDogcXkgLSByIDw9IHkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGxlZnQpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobSAtIDEpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goMSAtIGF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBxeCArIHIgPj0geCA6IHF5ICsgciA+PSB5KSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChtICsgMSk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChyaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCgxIC0gYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5IHwgVWludDMyQXJyYXl9IGlkc1xuICogQHBhcmFtIHtJbnN0YW5jZVR5cGU8VHlwZWRBcnJheUNvbnN0cnVjdG9yPn0gY29vcmRzXG4gKiBAcGFyYW0ge251bWJlcn0gbm9kZVNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzXG4gKi9cbmZ1bmN0aW9uIHNvcnQoaWRzLCBjb29yZHMsIG5vZGVTaXplLCBsZWZ0LCByaWdodCwgYXhpcykge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHJldHVybjtcblxuICAgIGNvbnN0IG0gPSAobGVmdCArIHJpZ2h0KSA+PiAxOyAvLyBtaWRkbGUgaW5kZXhcblxuICAgIC8vIHNvcnQgaWRzIGFuZCBjb29yZHMgYXJvdW5kIHRoZSBtaWRkbGUgaW5kZXggc28gdGhhdCB0aGUgaGFsdmVzIGxpZVxuICAgIC8vIGVpdGhlciBsZWZ0L3JpZ2h0IG9yIHRvcC9ib3R0b20gY29ycmVzcG9uZGluZ2x5ICh0YWtpbmcgdHVybnMpXG4gICAgc2VsZWN0KGlkcywgY29vcmRzLCBtLCBsZWZ0LCByaWdodCwgYXhpcyk7XG5cbiAgICAvLyByZWN1cnNpdmVseSBrZC1zb3J0IGZpcnN0IGhhbGYgYW5kIHNlY29uZCBoYWxmIG9uIHRoZSBvcHBvc2l0ZSBheGlzXG4gICAgc29ydChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIGxlZnQsIG0gLSAxLCAxIC0gYXhpcyk7XG4gICAgc29ydChpZHMsIGNvb3Jkcywgbm9kZVNpemUsIG0gKyAxLCByaWdodCwgMSAtIGF4aXMpO1xufVxuXG4vKipcbiAqIEN1c3RvbSBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobTogc29ydCBpZHMgYW5kIGNvb3JkcyBzbyB0aGF0XG4gKiBbbGVmdC4uay0xXSBpdGVtcyBhcmUgc21hbGxlciB0aGFuIGstdGggaXRlbSAob24gZWl0aGVyIHggb3IgeSBheGlzKVxuICogQHBhcmFtIHtVaW50MTZBcnJheSB8IFVpbnQzMkFycmF5fSBpZHNcbiAqIEBwYXJhbSB7SW5zdGFuY2VUeXBlPFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcj59IGNvb3Jkc1xuICogQHBhcmFtIHtudW1iZXJ9IGtcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdChpZHMsIGNvb3JkcywgaywgbGVmdCwgcmlnaHQsIGF4aXMpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICBjb25zdCBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgY29uc3QgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgY29uc3QgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICBjb25zdCBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHNlbGVjdChpZHMsIGNvb3JkcywgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGF4aXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdCA9IGNvb3Jkc1syICogayArIGF4aXNdO1xuICAgICAgICBsZXQgaSA9IGxlZnQ7XG4gICAgICAgIGxldCBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29vcmRzWzIgKiByaWdodCArIGF4aXNdID4gdCkgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb29yZHNbMiAqIGkgKyBheGlzXSA8IHQpIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb29yZHNbMiAqIGogKyBheGlzXSA+IHQpIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb29yZHNbMiAqIGxlZnQgKyBheGlzXSA9PT0gdCkgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDE2QXJyYXkgfCBVaW50MzJBcnJheX0gaWRzXG4gKiBAcGFyYW0ge0luc3RhbmNlVHlwZTxUeXBlZEFycmF5Q29uc3RydWN0b3I+fSBjb29yZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKiBAcGFyYW0ge251bWJlcn0galxuICovXG5mdW5jdGlvbiBzd2FwSXRlbShpZHMsIGNvb3JkcywgaSwgaikge1xuICAgIHN3YXAoaWRzLCBpLCBqKTtcbiAgICBzd2FwKGNvb3JkcywgMiAqIGksIDIgKiBqKTtcbiAgICBzd2FwKGNvb3JkcywgMiAqIGkgKyAxLCAyICogaiArIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SW5zdGFuY2VUeXBlPFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcj59IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGF4XG4gKiBAcGFyYW0ge251bWJlcn0gYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBieFxuICogQHBhcmFtIHtudW1iZXJ9IGJ5XG4gKi9cbmZ1bmN0aW9uIHNxRGlzdChheCwgYXksIGJ4LCBieSkge1xuICAgIGNvbnN0IGR4ID0gYXggLSBieDtcbiAgICBjb25zdCBkeSA9IGF5IC0gYnk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyQyID0ge1xuICAgIG1pblpvb206IDAsICAgLy8gbWluIHpvb20gdG8gZ2VuZXJhdGUgY2x1c3RlcnMgb25cbiAgICBtYXhab29tOiAxNiwgIC8vIG1heCB6b29tIGxldmVsIHRvIGNsdXN0ZXIgdGhlIHBvaW50cyBvblxuICAgIG1pblBvaW50czogMiwgLy8gbWluaW11bSBwb2ludHMgdG8gZm9ybSBhIGNsdXN0ZXJcbiAgICByYWRpdXM6IDQwLCAgIC8vIGNsdXN0ZXIgcmFkaXVzIGluIHBpeGVsc1xuICAgIGV4dGVudDogNTEyLCAgLy8gdGlsZSBleHRlbnQgKHJhZGl1cyBpcyBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGl0KVxuICAgIG5vZGVTaXplOiA2NCwgLy8gc2l6ZSBvZiB0aGUgS0QtdHJlZSBsZWFmIG5vZGUsIGFmZmVjdHMgcGVyZm9ybWFuY2VcbiAgICBsb2c6IGZhbHNlLCAgIC8vIHdoZXRoZXIgdG8gbG9nIHRpbWluZyBpbmZvXG5cbiAgICAvLyB3aGV0aGVyIHRvIGdlbmVyYXRlIG51bWVyaWMgaWRzIGZvciBpbnB1dCBmZWF0dXJlcyAoaW4gdmVjdG9yIHRpbGVzKVxuICAgIGdlbmVyYXRlSWQ6IGZhbHNlLFxuXG4gICAgLy8gYSByZWR1Y2UgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIGN1c3RvbSBjbHVzdGVyIHByb3BlcnRpZXNcbiAgICByZWR1Y2U6IG51bGwsIC8vIChhY2N1bXVsYXRlZCwgcHJvcHMpID0+IHsgYWNjdW11bGF0ZWQuc3VtICs9IHByb3BzLnN1bTsgfVxuXG4gICAgLy8gcHJvcGVydGllcyB0byB1c2UgZm9yIGluZGl2aWR1YWwgcG9pbnRzIHdoZW4gcnVubmluZyB0aGUgcmVkdWNlclxuICAgIG1hcDogcHJvcHMgPT4gcHJvcHMgLy8gcHJvcHMgPT4gKHtzdW06IHByb3BzLm15X3ZhbHVlfSlcbn07XG5cbmNvbnN0IGZyb3VuZCA9IE1hdGguZnJvdW5kIHx8ICh0bXAgPT4gKCh4KSA9PiB7IHRtcFswXSA9ICt4OyByZXR1cm4gdG1wWzBdOyB9KSkobmV3IEZsb2F0MzJBcnJheSgxKSk7XG5cbmNvbnN0IE9GRlNFVF9aT09NID0gMjtcbmNvbnN0IE9GRlNFVF9JRCA9IDM7XG5jb25zdCBPRkZTRVRfUEFSRU5UID0gNDtcbmNvbnN0IE9GRlNFVF9OVU0gPSA1O1xuY29uc3QgT0ZGU0VUX1BST1AgPSA2O1xuXG5jbGFzcyBTdXBlcmNsdXN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGRlZmF1bHRPcHRpb25zJDIpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmVlcyA9IG5ldyBBcnJheSh0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpO1xuICAgICAgICB0aGlzLnN0cmlkZSA9IHRoaXMub3B0aW9ucy5yZWR1Y2UgPyA3IDogNjtcbiAgICAgICAgdGhpcy5jbHVzdGVyUHJvcHMgPSBbXTtcbiAgICB9XG5cbiAgICBsb2FkKHBvaW50cykge1xuICAgICAgICBjb25zdCB7bG9nLCBtaW5ab29tLCBtYXhab29tfSA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAobG9nKSBjb25zb2xlLnRpbWUoJ3RvdGFsIHRpbWUnKTtcblxuICAgICAgICBjb25zdCB0aW1lcklkID0gYHByZXBhcmUgJHsgIHBvaW50cy5sZW5ndGggIH0gcG9pbnRzYDtcbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lKHRpbWVySWQpO1xuXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGEgY2x1c3RlciBvYmplY3QgZm9yIGVhY2ggcG9pbnQgYW5kIGluZGV4IGlucHV0IHBvaW50cyBpbnRvIGEgS0QtdHJlZVxuICAgICAgICBjb25zdCBkYXRhID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBpZiAoIXAuZ2VvbWV0cnkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBbbG5nLCBsYXRdID0gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGNvbnN0IHggPSBmcm91bmQobG5nWChsbmcpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBmcm91bmQobGF0WShsYXQpKTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGludGVybmFsIHBvaW50L2NsdXN0ZXIgZGF0YSBpbiBmbGF0IG51bWVyaWMgYXJyYXlzIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgZGF0YS5wdXNoKFxuICAgICAgICAgICAgICAgIHgsIHksIC8vIHByb2plY3RlZCBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIEluZmluaXR5LCAvLyB0aGUgbGFzdCB6b29tIHRoZSBwb2ludCB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICAgICAgICAgICAgaSwgLy8gaW5kZXggb2YgdGhlIHNvdXJjZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBhcnJheVxuICAgICAgICAgICAgICAgIC0xLCAvLyBwYXJlbnQgY2x1c3RlciBpZFxuICAgICAgICAgICAgICAgIDEgLy8gbnVtYmVyIG9mIHBvaW50cyBpbiBhIGNsdXN0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZHVjZSkgZGF0YS5wdXNoKDApOyAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyZWUgPSB0aGlzLnRyZWVzW21heFpvb20gKyAxXSA9IHRoaXMuX2NyZWF0ZVRyZWUoZGF0YSk7XG5cbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKHRpbWVySWQpO1xuXG4gICAgICAgIC8vIGNsdXN0ZXIgcG9pbnRzIG9uIG1heCB6b29tLCB0aGVuIGNsdXN0ZXIgdGhlIHJlc3VsdHMgb24gcHJldmlvdXMgem9vbSwgZXRjLjtcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBhIGNsdXN0ZXIgaGllcmFyY2h5IGFjcm9zcyB6b29tIGxldmVsc1xuICAgICAgICBmb3IgKGxldCB6ID0gbWF4Wm9vbTsgeiA+PSBtaW5ab29tOyB6LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9ICtEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc2V0IG9mIGNsdXN0ZXJzIGZvciB0aGUgem9vbSBhbmQgaW5kZXggdGhlbSB3aXRoIGEgS0QtdHJlZVxuICAgICAgICAgICAgdHJlZSA9IHRoaXMudHJlZXNbel0gPSB0aGlzLl9jcmVhdGVUcmVlKHRoaXMuX2NsdXN0ZXIodHJlZSwgeikpO1xuXG4gICAgICAgICAgICBpZiAobG9nKSBjb25zb2xlLmxvZygneiVkOiAlZCBjbHVzdGVycyBpbiAlZG1zJywgeiwgdHJlZS5udW1JdGVtcywgK0RhdGUubm93KCkgLSBub3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKCd0b3RhbCB0aW1lJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0Q2x1c3RlcnMoYmJveCwgem9vbSkge1xuICAgICAgICBsZXQgbWluTG5nID0gKChiYm94WzBdICsgMTgwKSAlIDM2MCArIDM2MCkgJSAzNjAgLSAxODA7XG4gICAgICAgIGNvbnN0IG1pbkxhdCA9IE1hdGgubWF4KC05MCwgTWF0aC5taW4oOTAsIGJib3hbMV0pKTtcbiAgICAgICAgbGV0IG1heExuZyA9IGJib3hbMl0gPT09IDE4MCA/IDE4MCA6ICgoYmJveFsyXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgICAgICBjb25zdCBtYXhMYXQgPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBiYm94WzNdKSk7XG5cbiAgICAgICAgaWYgKGJib3hbMl0gLSBiYm94WzBdID49IDM2MCkge1xuICAgICAgICAgICAgbWluTG5nID0gLTE4MDtcbiAgICAgICAgICAgIG1heExuZyA9IDE4MDtcbiAgICAgICAgfSBlbHNlIGlmIChtaW5MbmcgPiBtYXhMbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc3Rlcm5IZW0gPSB0aGlzLmdldENsdXN0ZXJzKFttaW5MbmcsIG1pbkxhdCwgMTgwLCBtYXhMYXRdLCB6b29tKTtcbiAgICAgICAgICAgIGNvbnN0IHdlc3Rlcm5IZW0gPSB0aGlzLmdldENsdXN0ZXJzKFstMTgwLCBtaW5MYXQsIG1heExuZywgbWF4TGF0XSwgem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gZWFzdGVybkhlbS5jb25jYXQod2VzdGVybkhlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oem9vbSldO1xuICAgICAgICBjb25zdCBpZHMgPSB0cmVlLnJhbmdlKGxuZ1gobWluTG5nKSwgbGF0WShtYXhMYXQpLCBsbmdYKG1heExuZyksIGxhdFkobWluTGF0KSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0cmVlLmRhdGE7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy5zdHJpZGUgKiBpZDtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goZGF0YVtrICsgT0ZGU0VUX05VTV0gPiAxID8gZ2V0Q2x1c3RlckpTT04oZGF0YSwgaywgdGhpcy5jbHVzdGVyUHJvcHMpIDogdGhpcy5wb2ludHNbZGF0YVtrICsgT0ZGU0VUX0lEXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbHVzdGVycztcbiAgICB9XG5cbiAgICBnZXRDaGlsZHJlbihjbHVzdGVySWQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luSWQgPSB0aGlzLl9nZXRPcmlnaW5JZChjbHVzdGVySWQpO1xuICAgICAgICBjb25zdCBvcmlnaW5ab29tID0gdGhpcy5fZ2V0T3JpZ2luWm9vbShjbHVzdGVySWQpO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9ICdObyBjbHVzdGVyIHdpdGggdGhlIHNwZWNpZmllZCBpZC4nO1xuXG4gICAgICAgIGNvbnN0IHRyZWUgPSB0aGlzLnRyZWVzW29yaWdpblpvb21dO1xuICAgICAgICBpZiAoIXRyZWUpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRyZWUuZGF0YTtcbiAgICAgICAgaWYgKG9yaWdpbklkICogdGhpcy5zdHJpZGUgPj0gZGF0YS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cbiAgICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyAodGhpcy5vcHRpb25zLmV4dGVudCAqIE1hdGgucG93KDIsIG9yaWdpblpvb20gLSAxKSk7XG4gICAgICAgIGNvbnN0IHggPSBkYXRhW29yaWdpbklkICogdGhpcy5zdHJpZGVdO1xuICAgICAgICBjb25zdCB5ID0gZGF0YVtvcmlnaW5JZCAqIHRoaXMuc3RyaWRlICsgMV07XG4gICAgICAgIGNvbnN0IGlkcyA9IHRyZWUud2l0aGluKHgsIHksIHIpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgICAgY29uc3QgayA9IGlkICogdGhpcy5zdHJpZGU7XG4gICAgICAgICAgICBpZiAoZGF0YVtrICsgT0ZGU0VUX1BBUkVOVF0gPT09IGNsdXN0ZXJJZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZGF0YVtrICsgT0ZGU0VUX05VTV0gPiAxID8gZ2V0Q2x1c3RlckpTT04oZGF0YSwgaywgdGhpcy5jbHVzdGVyUHJvcHMpIDogdGhpcy5wb2ludHNbZGF0YVtrICsgT0ZGU0VUX0lEXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcblxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZ2V0TGVhdmVzKGNsdXN0ZXJJZCwgbGltaXQsIG9mZnNldCkge1xuICAgICAgICBsaW1pdCA9IGxpbWl0IHx8IDEwO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgICBjb25zdCBsZWF2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXBwZW5kTGVhdmVzKGxlYXZlcywgY2x1c3RlcklkLCBsaW1pdCwgb2Zmc2V0LCAwKTtcblxuICAgICAgICByZXR1cm4gbGVhdmVzO1xuICAgIH1cblxuICAgIGdldFRpbGUoeiwgeCwgeSkge1xuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oeildO1xuICAgICAgICBjb25zdCB6MiA9IE1hdGgucG93KDIsIHopO1xuICAgICAgICBjb25zdCB7ZXh0ZW50LCByYWRpdXN9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBwID0gcmFkaXVzIC8gZXh0ZW50O1xuICAgICAgICBjb25zdCB0b3AgPSAoeSAtIHApIC8gejI7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9ICh5ICsgMSArIHApIC8gejI7XG5cbiAgICAgICAgY29uc3QgdGlsZSA9IHtcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhcbiAgICAgICAgICAgIHRyZWUucmFuZ2UoKHggLSBwKSAvIHoyLCB0b3AsICh4ICsgMSArIHApIC8gejIsIGJvdHRvbSksXG4gICAgICAgICAgICB0cmVlLmRhdGEsIHgsIHksIHoyLCB0aWxlKTtcblxuICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKFxuICAgICAgICAgICAgICAgIHRyZWUucmFuZ2UoMSAtIHAgLyB6MiwgdG9wLCAxLCBib3R0b20pLFxuICAgICAgICAgICAgICAgIHRyZWUuZGF0YSwgejIsIHksIHoyLCB0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gejIgLSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUaWxlRmVhdHVyZXMoXG4gICAgICAgICAgICAgICAgdHJlZS5yYW5nZSgwLCB0b3AsIHAgLyB6MiwgYm90dG9tKSxcbiAgICAgICAgICAgICAgICB0cmVlLmRhdGEsIC0xLCB5LCB6MiwgdGlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZS5mZWF0dXJlcy5sZW5ndGggPyB0aWxlIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRDbHVzdGVyRXhwYW5zaW9uWm9vbShjbHVzdGVySWQpIHtcbiAgICAgICAgbGV0IGV4cGFuc2lvblpvb20gPSB0aGlzLl9nZXRPcmlnaW5ab29tKGNsdXN0ZXJJZCkgLSAxO1xuICAgICAgICB3aGlsZSAoZXhwYW5zaW9uWm9vbSA8PSB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKGNsdXN0ZXJJZCk7XG4gICAgICAgICAgICBleHBhbnNpb25ab29tKys7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSBicmVhaztcbiAgICAgICAgICAgIGNsdXN0ZXJJZCA9IGNoaWxkcmVuWzBdLnByb3BlcnRpZXMuY2x1c3Rlcl9pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwYW5zaW9uWm9vbTtcbiAgICB9XG5cbiAgICBfYXBwZW5kTGVhdmVzKHJlc3VsdCwgY2x1c3RlcklkLCBsaW1pdCwgb2Zmc2V0LCBza2lwcGVkKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbihjbHVzdGVySWQpO1xuXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY2hpbGQucHJvcGVydGllcztcblxuICAgICAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmNsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZCArIHByb3BzLnBvaW50X2NvdW50IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSB3aG9sZSBjbHVzdGVyXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgKz0gcHJvcHMucG9pbnRfY291bnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW50ZXIgdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHRoaXMuX2FwcGVuZExlYXZlcyhyZXN1bHQsIHByb3BzLmNsdXN0ZXJfaWQsIGxpbWl0LCBvZmZzZXQsIHNraXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBleGl0IHRoZSBjbHVzdGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChza2lwcGVkIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBhIHNpbmdsZSBwb2ludFxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc2luZ2xlIHBvaW50XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IGxpbWl0KSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBza2lwcGVkO1xuICAgIH1cblxuICAgIF9jcmVhdGVUcmVlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBLREJ1c2goZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSB8IDAsIHRoaXMub3B0aW9ucy5ub2RlU2l6ZSwgRmxvYXQzMkFycmF5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSB0aGlzLnN0cmlkZSkgdHJlZS5hZGQoZGF0YVtpXSwgZGF0YVtpICsgMV0pO1xuICAgICAgICB0cmVlLmZpbmlzaCgpO1xuICAgICAgICB0cmVlLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBfYWRkVGlsZUZlYXR1cmVzKGlkcywgZGF0YSwgeCwgeSwgejIsIHRpbGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGlkcykge1xuICAgICAgICAgICAgY29uc3QgayA9IGkgKiB0aGlzLnN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2x1c3RlciA9IGRhdGFbayArIE9GRlNFVF9OVU1dID4gMTtcblxuICAgICAgICAgICAgbGV0IHRhZ3MsIHB4LCBweTtcbiAgICAgICAgICAgIGlmIChpc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gZ2V0Q2x1c3RlclByb3BlcnRpZXMoZGF0YSwgaywgdGhpcy5jbHVzdGVyUHJvcHMpO1xuICAgICAgICAgICAgICAgIHB4ID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICBweSA9IGRhdGFbayArIDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5wb2ludHNbZGF0YVtrICsgT0ZGU0VUX0lEXV07XG4gICAgICAgICAgICAgICAgdGFncyA9IHAucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBjb25zdCBbbG5nLCBsYXRdID0gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgICAgICBweCA9IGxuZ1gobG5nKTtcbiAgICAgICAgICAgICAgICBweSA9IGxhdFkobGF0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBbW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5leHRlbnQgKiAocHggKiB6MiAtIHgpKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuZXh0ZW50ICogKHB5ICogejIgLSB5KSlcbiAgICAgICAgICAgICAgICBdXSxcbiAgICAgICAgICAgICAgICB0YWdzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBhc3NpZ24gaWRcbiAgICAgICAgICAgIGxldCBpZDtcbiAgICAgICAgICAgIGlmIChpc0NsdXN0ZXIgfHwgdGhpcy5vcHRpb25zLmdlbmVyYXRlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbGx5IGdlbmVyYXRlIGlkIGZvciBwb2ludHNcbiAgICAgICAgICAgICAgICBpZCA9IGRhdGFbayArIE9GRlNFVF9JRF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgaWQgaWYgYWxyZWFkeSBhc3NpZ25lZFxuICAgICAgICAgICAgICAgIGlkID0gdGhpcy5wb2ludHNbZGF0YVtrICsgT0ZGU0VUX0lEXV0uaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSBmLmlkID0gaWQ7XG5cbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9saW1pdFpvb20oeikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLm1pblpvb20sIE1hdGgubWluKE1hdGguZmxvb3IoK3opLCB0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpKTtcbiAgICB9XG5cbiAgICBfY2x1c3Rlcih0cmVlLCB6b29tKSB7XG4gICAgICAgIGNvbnN0IHtyYWRpdXMsIGV4dGVudCwgcmVkdWNlLCBtaW5Qb2ludHN9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCByID0gcmFkaXVzIC8gKGV4dGVudCAqIE1hdGgucG93KDIsIHpvb20pKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRyZWUuZGF0YTtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggcG9pbnRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGUgcG9pbnQgYXQgdGhpcyB6b29tIGxldmVsLCBza2lwIGl0XG4gICAgICAgICAgICBpZiAoZGF0YVtpICsgT0ZGU0VUX1pPT01dIDw9IHpvb20pIGNvbnRpbnVlO1xuICAgICAgICAgICAgZGF0YVtpICsgT0ZGU0VUX1pPT01dID0gem9vbTtcblxuICAgICAgICAgICAgLy8gZmluZCBhbGwgbmVhcmJ5IHBvaW50c1xuICAgICAgICAgICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvcklkcyA9IHRyZWUud2l0aGluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCByKTtcblxuICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzT3JpZ2luID0gZGF0YVtpICsgT0ZGU0VUX05VTV07XG4gICAgICAgICAgICBsZXQgbnVtUG9pbnRzID0gbnVtUG9pbnRzT3JpZ2luO1xuXG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvdGVudGlhbCBjbHVzdGVyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5laWdoYm9ySWQgb2YgbmVpZ2hib3JJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gbmVpZ2hib3JJZCAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IG5laWdoYm9ycyB0aGF0IGFyZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2sgKyBPRkZTRVRfWk9PTV0gPiB6b29tKSBudW1Qb2ludHMgKz0gZGF0YVtrICsgT0ZGU0VUX05VTV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdlcmUgbmVpZ2hib3JzIHRvIG1lcmdlLCBhbmQgdGhlcmUgYXJlIGVub3VnaCBwb2ludHMgdG8gZm9ybSBhIGNsdXN0ZXJcbiAgICAgICAgICAgIGlmIChudW1Qb2ludHMgPiBudW1Qb2ludHNPcmlnaW4gJiYgbnVtUG9pbnRzID49IG1pblBvaW50cykge1xuICAgICAgICAgICAgICAgIGxldCB3eCA9IHggKiBudW1Qb2ludHNPcmlnaW47XG4gICAgICAgICAgICAgICAgbGV0IHd5ID0geSAqIG51bVBvaW50c09yaWdpbjtcblxuICAgICAgICAgICAgICAgIGxldCBjbHVzdGVyUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBsZXQgY2x1c3RlclByb3BJbmRleCA9IC0xO1xuXG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIGJvdGggem9vbSBhbmQgcG9pbnQgaW5kZXggb24gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZCAtLSBvZmZzZXQgYnkgdG90YWwgbGVuZ3RoIG9mIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSAoKGkgLyBzdHJpZGUgfCAwKSA8PCA1KSArICh6b29tICsgMSkgKyB0aGlzLnBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5laWdoYm9ySWQgb2YgbmVpZ2hib3JJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IG5laWdoYm9ySWQgKiBzdHJpZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbayArIE9GRlNFVF9aT09NXSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrICsgT0ZGU0VUX1pPT01dID0gem9vbTsgLy8gc2F2ZSB0aGUgem9vbSAoc28gaXQgZG9lc24ndCBnZXQgcHJvY2Vzc2VkIHR3aWNlKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bVBvaW50czIgPSBkYXRhW2sgKyBPRkZTRVRfTlVNXTtcbiAgICAgICAgICAgICAgICAgICAgd3ggKz0gZGF0YVtrXSAqIG51bVBvaW50czI7IC8vIGFjY3VtdWxhdGUgY29vcmRpbmF0ZXMgZm9yIGNhbGN1bGF0aW5nIHdlaWdodGVkIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICB3eSArPSBkYXRhW2sgKyAxXSAqIG51bVBvaW50czI7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrICsgT0ZGU0VUX1BBUkVOVF0gPSBpZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVkdWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsdXN0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3RlclByb3BlcnRpZXMgPSB0aGlzLl9tYXAoZGF0YSwgaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3RlclByb3BJbmRleCA9IHRoaXMuY2x1c3RlclByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJQcm9wcy5wdXNoKGNsdXN0ZXJQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZShjbHVzdGVyUHJvcGVydGllcywgdGhpcy5fbWFwKGRhdGEsIGspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFbaSArIE9GRlNFVF9QQVJFTlRdID0gaWQ7XG4gICAgICAgICAgICAgICAgbmV4dERhdGEucHVzaCh3eCAvIG51bVBvaW50cywgd3kgLyBudW1Qb2ludHMsIEluZmluaXR5LCBpZCwgLTEsIG51bVBvaW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZSkgbmV4dERhdGEucHVzaChjbHVzdGVyUHJvcEluZGV4KTtcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGVmdCBwb2ludHMgYXMgdW5jbHVzdGVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZTsgaisrKSBuZXh0RGF0YS5wdXNoKGRhdGFbaSArIGpdKTtcblxuICAgICAgICAgICAgICAgIGlmIChudW1Qb2ludHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVpZ2hib3JJZCBvZiBuZWlnaGJvcklkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IG5laWdoYm9ySWQgKiBzdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtrICsgT0ZGU0VUX1pPT01dIDw9IHpvb20pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtrICsgT0ZGU0VUX1pPT01dID0gem9vbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RyaWRlOyBqKyspIG5leHREYXRhLnB1c2goZGF0YVtrICsgal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHREYXRhO1xuICAgIH1cblxuICAgIC8vIGdldCBpbmRleCBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0aGUgY2x1c3RlciBvcmlnaW5hdGVkXG4gICAgX2dldE9yaWdpbklkKGNsdXN0ZXJJZCkge1xuICAgICAgICByZXR1cm4gKGNsdXN0ZXJJZCAtIHRoaXMucG9pbnRzLmxlbmd0aCkgPj4gNTtcbiAgICB9XG5cbiAgICAvLyBnZXQgem9vbSBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0aGUgY2x1c3RlciBvcmlnaW5hdGVkXG4gICAgX2dldE9yaWdpblpvb20oY2x1c3RlcklkKSB7XG4gICAgICAgIHJldHVybiAoY2x1c3RlcklkIC0gdGhpcy5wb2ludHMubGVuZ3RoKSAlIDMyO1xuICAgIH1cblxuICAgIF9tYXAoZGF0YSwgaSwgY2xvbmUpIHtcbiAgICAgICAgaWYgKGRhdGFbaSArIE9GRlNFVF9OVU1dID4gMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmNsdXN0ZXJQcm9wc1tkYXRhW2kgKyBPRkZTRVRfUFJPUF1dO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lID8gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpIDogcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLnBvaW50c1tkYXRhW2kgKyBPRkZTRVRfSURdXS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm9wdGlvbnMubWFwKG9yaWdpbmFsKTtcbiAgICAgICAgcmV0dXJuIGNsb25lICYmIHJlc3VsdCA9PT0gb3JpZ2luYWwgPyBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpIDogcmVzdWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlckpTT04oZGF0YSwgaSwgY2x1c3RlclByb3BzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBpZDogZGF0YVtpICsgT0ZGU0VUX0lEXSxcbiAgICAgICAgcHJvcGVydGllczogZ2V0Q2x1c3RlclByb3BlcnRpZXMoZGF0YSwgaSwgY2x1c3RlclByb3BzKSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogW3hMbmcoZGF0YVtpXSksIHlMYXQoZGF0YVtpICsgMV0pXVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlclByb3BlcnRpZXMoZGF0YSwgaSwgY2x1c3RlclByb3BzKSB7XG4gICAgY29uc3QgY291bnQgPSBkYXRhW2kgKyBPRkZTRVRfTlVNXTtcbiAgICBjb25zdCBhYmJyZXYgPVxuICAgICAgICBjb3VudCA+PSAxMDAwMCA/IGAke01hdGgucm91bmQoY291bnQgLyAxMDAwKSAgfWtgIDpcbiAgICAgICAgY291bnQgPj0gMTAwMCA/IGAke01hdGgucm91bmQoY291bnQgLyAxMDApIC8gMTAgIH1rYCA6IGNvdW50O1xuICAgIGNvbnN0IHByb3BJbmRleCA9IGRhdGFbaSArIE9GRlNFVF9QUk9QXTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJvcEluZGV4ID09PSAtMSA/IHt9IDogT2JqZWN0LmFzc2lnbih7fSwgY2x1c3RlclByb3BzW3Byb3BJbmRleF0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHtcbiAgICAgICAgY2x1c3RlcjogdHJ1ZSxcbiAgICAgICAgY2x1c3Rlcl9pZDogZGF0YVtpICsgT0ZGU0VUX0lEXSxcbiAgICAgICAgcG9pbnRfY291bnQ6IGNvdW50LFxuICAgICAgICBwb2ludF9jb3VudF9hYmJyZXZpYXRlZDogYWJicmV2XG4gICAgfSk7XG59XG5cbi8vIGxvbmdpdHVkZS9sYXRpdHVkZSB0byBzcGhlcmljYWwgbWVyY2F0b3IgaW4gWzAuLjFdIHJhbmdlXG5mdW5jdGlvbiBsbmdYKGxuZykge1xuICAgIHJldHVybiBsbmcgLyAzNjAgKyAwLjU7XG59XG5mdW5jdGlvbiBsYXRZKGxhdCkge1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGxhdCAqIE1hdGguUEkgLyAxODApO1xuICAgIGNvbnN0IHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcbiAgICByZXR1cm4geSA8IDAgPyAwIDogeSA+IDEgPyAxIDogeTtcbn1cblxuLy8gc3BoZXJpY2FsIG1lcmNhdG9yIHRvIGxvbmdpdHVkZS9sYXRpdHVkZVxuZnVuY3Rpb24geExuZyh4KSB7XG4gICAgcmV0dXJuICh4IC0gMC41KSAqIDM2MDtcbn1cbmZ1bmN0aW9uIHlMYXQoeSkge1xuICAgIGNvbnN0IHkyID0gKDE4MCAtIHkgKiAzNjApICogTWF0aC5QSSAvIDE4MDtcbiAgICByZXR1cm4gMzYwICogTWF0aC5hdGFuKE1hdGguZXhwKHkyKSkgLyBNYXRoLlBJIC0gOTA7XG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWFya2VyVXRpbHMge1xuICAgIHN0YXRpYyBpc0FkdmFuY2VkTWFya2VyQXZhaWxhYmxlKG1hcCkge1xuICAgICAgICByZXR1cm4gKGdvb2dsZS5tYXBzLm1hcmtlciAmJlxuICAgICAgICAgICAgbWFwLmdldE1hcENhcGFiaWxpdGllcygpLmlzQWR2YW5jZWRNYXJrZXJzQXZhaWxhYmxlID09PSB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQWR2YW5jZWRNYXJrZXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiAoZ29vZ2xlLm1hcHMubWFya2VyICYmXG4gICAgICAgICAgICBtYXJrZXIgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KTtcbiAgICB9XG4gICAgc3RhdGljIHNldE1hcChtYXJrZXIsIG1hcCkge1xuICAgICAgICBpZiAodGhpcy5pc0FkdmFuY2VkTWFya2VyKG1hcmtlcikpIHtcbiAgICAgICAgICAgIG1hcmtlci5tYXAgPSBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldFBvc2l0aW9uKG1hcmtlcikge1xuICAgICAgICAvLyBTdXBlckNsdXN0ZXJBbGdvcml0aG0uY2FsY3VsYXRlIGV4cGVjdHMgYSBMYXRMbmcgaW5zdGFuY2Ugc28gd2UgZmFrZSBpdCBmb3IgQWR2IE1hcmtlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpKSB7XG4gICAgICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5wb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBjYW4ndCBjYXN0IHRvIExhdExuZ0xpdGVyYWwgZm9yIHJlYXNvbnMgPShcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uLmxhdCAmJiBtYXJrZXIucG9zaXRpb24ubG5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG1hcmtlci5wb3NpdGlvbi5sYXQsIG1hcmtlci5wb3NpdGlvbi5sbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFZpc2libGUobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWR2YW5jZWRNYXJrZXIobWFya2VyKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbHdheXMgcmV0dXJuIHRydWUgZm9yIEFkdmFuY2VkIE1hcmtlcnMgYmVjYXVzZSB0aGUgY2x1c3RlcmVyXG4gICAgICAgICAgICAgKiB1c2VzIGdldFZpc2libGUgYXMgYSB3YXkgdG8gY291bnQgbGVnYWN5IG1hcmtlcnMgbm90IGFzIGFuIGFjdHVhbFxuICAgICAgICAgICAgICogaW5kaWNhdG9yIG9mIHZpc2liaWxpdHkgZm9yIHNvbWUgcmVhc29uLiBFdmVuIHdoZW4gbWFya2VycyBhcmUgaGlkZGVuXG4gICAgICAgICAgICAgKiBNYXJrZXIuZ2V0VmlzaWJsZSByZXR1cm5zIGB0cnVlYCBhbmQgdGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgbWFya2VyIGNvdW50XG4gICAgICAgICAgICAgKiBvbiB0aGUgY2x1c3Rlci4gU2VlIHRoZSBiZWhhdmlvciBvZiBDbHVzdGVyLmNvdW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXIuZ2V0VmlzaWJsZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQ2x1c3RlciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXJrZXJzLCBwb3NpdGlvbiB9KSB7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5sZW5ndGggPT09IDAgJiYgIXRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyh0aGlzLl9wb3NpdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmtlciBvZiB0aGlzLm1hcmtlcnMpIHtcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQoTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9XG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24gfHwgdGhpcy5ib3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY291bnQgb2YgKip2aXNpYmxlKiogbWFya2Vycy5cbiAgICAgKi9cbiAgICBnZXQgY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMuZmlsdGVyKChtKSA9PiBNYXJrZXJVdGlscy5nZXRWaXNpYmxlKG0pKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1hcmtlciB0byB0aGUgY2x1c3Rlci5cbiAgICAgKi9cbiAgICBwdXNoKG1hcmtlcikge1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIHJlZmVyZW5jZXMgYW5kIHJlbW92ZSBtYXJrZXIgZnJvbSBtYXAuXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIE1hcmtlclV0aWxzLnNldE1hcCh0aGlzLm1hcmtlciwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgbWFya2VycyB2aXNpYmxlIGluIGEgcGFkZGVkIG1hcCB2aWV3cG9ydFxuICpcbiAqIEBwYXJhbSBtYXBcbiAqIEBwYXJhbSBtYXBDYW52YXNQcm9qZWN0aW9uXG4gKiBAcGFyYW0gbWFya2VycyBUaGUgbGlzdCBvZiBtYXJrZXIgdG8gZmlsdGVyXG4gKiBAcGFyYW0gdmlld3BvcnRQYWRkaW5nUGl4ZWxzIFRoZSBwYWRkaW5nIGluIHBpeGVsXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBtYXJrZXJzIGluIHRoZSBwYWRkZWQgdmlld3BvcnRcbiAqL1xuY29uc3QgZmlsdGVyTWFya2Vyc1RvUGFkZGVkVmlld3BvcnQgPSAobWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCBtYXJrZXJzLCB2aWV3cG9ydFBhZGRpbmdQaXhlbHMpID0+IHtcbiAgICBjb25zdCBleHRlbmRlZE1hcEJvdW5kcyA9IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQobWFwLmdldEJvdW5kcygpLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB2aWV3cG9ydFBhZGRpbmdQaXhlbHMpO1xuICAgIHJldHVybiBtYXJrZXJzLmZpbHRlcigobWFya2VyKSA9PiBleHRlbmRlZE1hcEJvdW5kcy5jb250YWlucyhNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpKSk7XG59O1xuLyoqXG4gKiBFeHRlbmRzIGEgYm91bmRzIGJ5IGEgbnVtYmVyIG9mIHBpeGVscyBpbiBlYWNoIGRpcmVjdGlvblxuICovXG5jb25zdCBleHRlbmRCb3VuZHNUb1BhZGRlZFZpZXdwb3J0ID0gKGJvdW5kcywgcHJvamVjdGlvbiwgbnVtUGl4ZWxzKSA9PiB7XG4gICAgY29uc3QgeyBub3J0aEVhc3QsIHNvdXRoV2VzdCB9ID0gbGF0TG5nQm91bmRzVG9QaXhlbEJvdW5kcyhib3VuZHMsIHByb2plY3Rpb24pO1xuICAgIGNvbnN0IGV4dGVuZGVkUGl4ZWxCb3VuZHMgPSBleHRlbmRQaXhlbEJvdW5kcyh7IG5vcnRoRWFzdCwgc291dGhXZXN0IH0sIG51bVBpeGVscyk7XG4gICAgcmV0dXJuIHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHMoZXh0ZW5kZWRQaXhlbEJvdW5kcywgcHJvamVjdGlvbik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9zaXRpb25zLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gKHAxLCBwMikgPT4ge1xuICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIEVhcnRoIGluIGttXG4gICAgY29uc3QgZExhdCA9ICgocDIubGF0IC0gcDEubGF0KSAqIE1hdGguUEkpIC8gMTgwO1xuICAgIGNvbnN0IGRMb24gPSAoKHAyLmxuZyAtIHAxLmxuZykgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICBjb25zdCBzaW5ETGF0ID0gTWF0aC5zaW4oZExhdCAvIDIpO1xuICAgIGNvbnN0IHNpbkRMb24gPSBNYXRoLnNpbihkTG9uIC8gMik7XG4gICAgY29uc3QgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICtcbiAgICAgICAgTWF0aC5jb3MoKHAxLmxhdCAqIE1hdGguUEkpIC8gMTgwKSAqXG4gICAgICAgICAgICBNYXRoLmNvcygocDIubGF0ICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgICAgICAgIHNpbkRMb24gKlxuICAgICAgICAgICAgc2luRExvbjtcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgICByZXR1cm4gUiAqIGM7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIExhdExuZyBib3VuZCB0byBwaXhlbHMuXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsYXRMbmdCb3VuZHNUb1BpeGVsQm91bmRzID0gKGJvdW5kcywgcHJvamVjdGlvbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vcnRoRWFzdDogcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpLFxuICAgICAgICBzb3V0aFdlc3Q6IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldFNvdXRoV2VzdCgpKSxcbiAgICB9O1xufTtcbi8qKlxuICogRXh0ZW5kcyBhIHBpeGVsIGJvdW5kcyBieSBudW1QaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHRlbmRQaXhlbEJvdW5kcyA9ICh7IG5vcnRoRWFzdCwgc291dGhXZXN0IH0sIG51bVBpeGVscykgPT4ge1xuICAgIG5vcnRoRWFzdC54ICs9IG51bVBpeGVscztcbiAgICBub3J0aEVhc3QueSAtPSBudW1QaXhlbHM7XG4gICAgc291dGhXZXN0LnggLT0gbnVtUGl4ZWxzO1xuICAgIHNvdXRoV2VzdC55ICs9IG51bVBpeGVscztcbiAgICByZXR1cm4geyBub3J0aEVhc3QsIHNvdXRoV2VzdCB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwaXhlbEJvdW5kc1RvTGF0TG5nQm91bmRzID0gKHsgbm9ydGhFYXN0LCBzb3V0aFdlc3QgfSwgcHJvamVjdGlvbikgPT4ge1xuICAgIGNvbnN0IHN3ID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhzb3V0aFdlc3QpO1xuICAgIGNvbnN0IG5lID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhub3J0aEVhc3QpO1xuICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHN3LCBuZSk7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQWJzdHJhY3RBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4Wm9vbSA9IDE2IH0pIHtcbiAgICAgICAgdGhpcy5tYXhab29tID0gbWF4Wm9vbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ5cGFzcyBjbHVzdGVyaW5nIGJhc2VkIHVwb24gc29tZSBtYXAgc3RhdGUgc3VjaCBhc1xuICAgICAqIHpvb20sIG51bWJlciBvZiBtYXJrZXJzLCBldGMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIGNsdXN0ZXIoe21hcmtlcnMsIG1hcH06IEFsZ29yaXRobUlucHV0KTogQ2x1c3RlcltdIHtcbiAgICAgKiAgICBpZiAoc2hvdWxkQnlwYXNzQ2x1c3RlcmluZyhtYXApKSB7XG4gICAgICogICAgICByZXR1cm4gdGhpcy5ub29wKHttYXJrZXJzfSlcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG5vb3AoeyBtYXJrZXJzLCB9KSB7XG4gICAgICAgIHJldHVybiBub29wJDEobWFya2Vycyk7XG4gICAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCB2aWV3cG9ydCBhbGdvcml0aG0gcHJvdmVzIGEgY2xhc3MgdG8gZmlsdGVyIG1hcmtlcnMgYnkgYSBwYWRkZWRcbiAqIHZpZXdwb3J0LiBUaGlzIGlzIGEgY29tbW9uIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gICAgY29uc3RydWN0b3IoX2EpIHtcbiAgICAgICAgdmFyIHsgdmlld3BvcnRQYWRkaW5nID0gNjAgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJ2aWV3cG9ydFBhZGRpbmdcIl0pO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydFBhZGRpbmcgPSA2MDtcbiAgICAgICAgdGhpcy52aWV3cG9ydFBhZGRpbmcgPSB2aWV3cG9ydFBhZGRpbmc7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICBpZiAobWFwLmdldFpvb20oKSA+PSB0aGlzLm1heFpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMubm9vcCh7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHVzdGVyczogdGhpcy5jbHVzdGVyKHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub29wJDEgPSAobWFya2VycykgPT4ge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gbmV3IENsdXN0ZXIoe1xuICAgICAgICBwb3NpdGlvbjogTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSxcbiAgICAgICAgbWFya2VyczogW21hcmtlcl0sXG4gICAgfSkpO1xuICAgIHJldHVybiBjbHVzdGVycztcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGRlZmF1bHQgR3JpZCBhbGdvcml0aG0gaGlzdG9yaWNhbGx5IHVzZWQgaW4gR29vZ2xlIE1hcHMgbWFya2VyXG4gKiBjbHVzdGVyaW5nLlxuICpcbiAqIFRoZSBHcmlkIGFsZ29yaXRobSBkb2VzIG5vdCBpbXBsZW1lbnQgY2FjaGluZyBhbmQgbWFya2VycyBtYXkgZmxhc2ggYXMgdGhlXG4gKiB2aWV3cG9ydCBjaGFuZ2VzLiBJbnN0ZWFkIHVzZSB7QGxpbmsgU3VwZXJDbHVzdGVyQWxnb3JpdGhtfS5cbiAqL1xuY2xhc3MgR3JpZEFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IG1heERpc3RhbmNlID0gNDAwMDAsIGdyaWRTaXplID0gNDAgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJtYXhEaXN0YW5jZVwiLCBcImdyaWRTaXplXCJdKTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgem9vbTogLTEgfTtcbiAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gZ3JpZFNpemU7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgem9vbTogbWFwLmdldFpvb20oKSB9O1xuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS56b29tID49IHRoaXMubWF4Wm9vbSAmJiBzdGF0ZS56b29tID49IHRoaXMubWF4Wm9vbSkgO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSAhZXF1YWwodGhpcy5zdGF0ZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKG1hcC5nZXRab29tKCkgPj0gdGhpcy5tYXhab29tKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzOiB0aGlzLm5vb3Aoe1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHVzdGVyczogdGhpcy5jbHVzdGVyKHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbHVzdGVyKHsgbWFya2VycywgbWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB9KSB7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkVG9DbG9zZXN0Q2x1c3RlcihtYXJrZXIsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcbiAgICB9XG4gICAgYWRkVG9DbG9zZXN0Q2x1c3RlcihtYXJrZXIsIG1hcCwgcHJvamVjdGlvbikge1xuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlOyAvLyBTb21lIGxhcmdlIG51bWJlclxuICAgICAgICBsZXQgY2x1c3RlciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5jbHVzdGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGNhbmRpZGF0ZS5ib3VuZHMuZ2V0Q2VudGVyKCkudG9KU09OKCksIE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcikudG9KU09OKCkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsdXN0ZXIgJiZcbiAgICAgICAgICAgIGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQoY2x1c3Rlci5ib3VuZHMsIHByb2plY3Rpb24sIHRoaXMuZ3JpZFNpemUpLmNvbnRhaW5zKE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcikpKSB7XG4gICAgICAgICAgICBjbHVzdGVyLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih7IG1hcmtlcnM6IFttYXJrZXJdIH0pO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE5vb3AgYWxnb3JpdGhtIGRvZXMgbm90IGdlbmVyYXRlIGFueSBjbHVzdGVycyBvciBmaWx0ZXIgbWFya2VycyBieSB0aGUgYW4gZXh0ZW5kZWQgdmlld3BvcnQuXG4gKi9cbmNsYXNzIE5vb3BBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gICAgY29uc3RydWN0b3IoX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtdKTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMuY2x1c3Rlcih7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiB9KSxcbiAgICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbHVzdGVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vb3AoaW5wdXQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnkgZmFzdCBKYXZhU2NyaXB0IGFsZ29yaXRobSBmb3IgZ2Vvc3BhdGlhbCBwb2ludCBjbHVzdGVyaW5nIHVzaW5nIEtEIHRyZWVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3VwZXJjbHVzdGVyIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFN1cGVyQ2x1c3RlckFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0QWxnb3JpdGhtIHtcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xuICAgICAgICB2YXIgeyBtYXhab29tLCByYWRpdXMgPSA2MCB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcIm1heFpvb21cIiwgXCJyYWRpdXNcIl0pO1xuICAgICAgICBzdXBlcih7IG1heFpvb20gfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IHpvb206IC0xIH07XG4gICAgICAgIHRoaXMuc3VwZXJDbHVzdGVyID0gbmV3IFN1cGVyY2x1c3RlcihPYmplY3QuYXNzaWduKHsgbWF4Wm9vbTogdGhpcy5tYXhab29tLCByYWRpdXMgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBjYWxjdWxhdGUoaW5wdXQpIHtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IHpvb206IGlucHV0Lm1hcC5nZXRab29tKCkgfTtcbiAgICAgICAgaWYgKCFlcXVhbChpbnB1dC5tYXJrZXJzLCB0aGlzLm1hcmtlcnMpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE8gdXNlIHByb3h5IHRvIGF2b2lkIGNvcHk/XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSBbLi4uaW5wdXQubWFya2Vyc107XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLm1hcmtlcnMubWFwKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbcG9zaXRpb24ubG5nKCksIHBvc2l0aW9uLmxhdCgpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG1hcmtlciB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbHVzdGVyLmxvYWQocG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnpvb20gPD0gdGhpcy5tYXhab29tIHx8IHN0YXRlLnpvb20gPD0gdGhpcy5tYXhab29tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFlcXVhbCh0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycyA9IHRoaXMuY2x1c3RlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2x1c3RlcnM6IHRoaXMuY2x1c3RlcnMsIGNoYW5nZWQgfTtcbiAgICB9XG4gICAgY2x1c3Rlcih7IG1hcCB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2x1c3RlclxuICAgICAgICAgICAgLmdldENsdXN0ZXJzKFstMTgwLCAtOTAsIDE4MCwgOTBdLCBNYXRoLnJvdW5kKG1hcC5nZXRab29tKCkpKVxuICAgICAgICAgICAgLm1hcCgoZmVhdHVyZSkgPT4gdGhpcy50cmFuc2Zvcm1DbHVzdGVyKGZlYXR1cmUpKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtQ2x1c3Rlcih7IGdlb21ldHJ5OiB7IGNvb3JkaW5hdGVzOiBbbG5nLCBsYXRdLCB9LCBwcm9wZXJ0aWVzLCB9KSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsdXN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICAgICAgICAgICAgbWFya2VyczogdGhpcy5zdXBlckNsdXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgLmdldExlYXZlcyhwcm9wZXJ0aWVzLmNsdXN0ZXJfaWQsIEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChsZWFmKSA9PiBsZWFmLnByb3BlcnRpZXMubWFya2VyKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBsYXQsIGxuZyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2VyID0gcHJvcGVydGllcy5tYXJrZXI7XG4gICAgICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICAgICAgICBtYXJrZXJzOiBbbWFya2VyXSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXMgc3RhdGlzdGljcyBvbiBhbGwgY2x1c3RlcnMgaW4gdGhlIGN1cnJlbnQgcmVuZGVyIGN5Y2xlIGZvciB1c2UgaW4ge0BsaW5rIFJlbmRlcmVyLnJlbmRlcn0uXG4gKi9cbmNsYXNzIENsdXN0ZXJTdGF0cyB7XG4gICAgY29uc3RydWN0b3IobWFya2VycywgY2x1c3RlcnMpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0geyBzdW06IG1hcmtlcnMubGVuZ3RoIH07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJNYXJrZXJDb3VudHMgPSBjbHVzdGVycy5tYXAoKGEpID0+IGEuY291bnQpO1xuICAgICAgICBjb25zdCBjbHVzdGVyTWFya2VyU3VtID0gY2x1c3Rlck1hcmtlckNvdW50cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IHtcbiAgICAgICAgICAgIGNvdW50OiBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgICAgICAgbWVhbjogY2x1c3Rlck1hcmtlclN1bSAvIGNsdXN0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzdW06IGNsdXN0ZXJNYXJrZXJTdW0sXG4gICAgICAgICAgICAgICAgbWluOiBNYXRoLm1pbiguLi5jbHVzdGVyTWFya2VyQ291bnRzKSxcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4KC4uLmNsdXN0ZXJNYXJrZXJDb3VudHMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBEZWZhdWx0UmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbiBmb3IgdGhlIGxpYnJhcnkgdXNlZCBieSB7QGxpbmsgTWFya2VyQ2x1c3RlcmVyfS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSBzZXQgdG8gdXNlIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gY2hhbmdlIGNvbG9yIGlmIHRoaXMgY2x1c3RlciBoYXMgbW9yZSBtYXJrZXJzIHRoYW4gdGhlIG1lYW4gY2x1c3RlclxuICAgICAqIGNvbnN0IGNvbG9yID1cbiAgICAgKiAgIGNvdW50ID4gTWF0aC5tYXgoMTAsIHN0YXRzLmNsdXN0ZXJzLm1hcmtlcnMubWVhbilcbiAgICAgKiAgICAgPyBcIiNmZjAwMDBcIlxuICAgICAqICAgICA6IFwiIzAwMDBmZlwiO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIHN2ZyB1cmwgd2l0aCBmaWxsIGNvbG9yXG4gICAgICogY29uc3Qgc3ZnID0gd2luZG93LmJ0b2EoYFxuICAgICAqIDxzdmcgZmlsbD1cIiR7Y29sb3J9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQwIDI0MFwiPlxuICAgICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi42XCIgcj1cIjcwXCIgLz5cbiAgICAgKiAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuM1wiIHI9XCI5MFwiIC8+XG4gICAgICogICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjJcIiByPVwiMTEwXCIgLz5cbiAgICAgKiAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuMVwiIHI9XCIxMzBcIiAvPlxuICAgICAqIDwvc3ZnPmApO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIG1hcmtlciB1c2luZyBzdmcgaWNvblxuICAgICAqIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgKiAgIHBvc2l0aW9uLFxuICAgICAqICAgaWNvbjoge1xuICAgICAqICAgICB1cmw6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7c3ZnfWAsXG4gICAgICogICAgIHNjYWxlZFNpemU6IG5ldyBnb29nbGUubWFwcy5TaXplKDQ1LCA0NSksXG4gICAgICogICB9LFxuICAgICAqICAgbGFiZWw6IHtcbiAgICAgKiAgICAgdGV4dDogU3RyaW5nKGNvdW50KSxcbiAgICAgKiAgICAgY29sb3I6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCIsXG4gICAgICogICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgKiAgIH0sXG4gICAgICogICAvLyBhZGp1c3QgekluZGV4IHRvIGJlIGFib3ZlIG90aGVyIG1hcmtlcnNcbiAgICAgKiAgIHpJbmRleDogMTAwMCArIGNvdW50LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlbmRlcih7IGNvdW50LCBwb3NpdGlvbiB9LCBzdGF0cywgbWFwKSB7XG4gICAgICAgIC8vIGNoYW5nZSBjb2xvciBpZiB0aGlzIGNsdXN0ZXIgaGFzIG1vcmUgbWFya2VycyB0aGFuIHRoZSBtZWFuIGNsdXN0ZXJcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb3VudCA+IE1hdGgubWF4KDEwLCBzdGF0cy5jbHVzdGVycy5tYXJrZXJzLm1lYW4pID8gXCIjZmYwMDAwXCIgOiBcIiMwMDAwZmZcIjtcbiAgICAgICAgLy8gY3JlYXRlIHN2ZyBsaXRlcmFsIHdpdGggZmlsbCBjb2xvclxuICAgICAgICBjb25zdCBzdmcgPSBgPHN2ZyBmaWxsPVwiJHtjb2xvcn1cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNDAgMjQwXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCI+XG48Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjZcIiByPVwiNzBcIiAvPlxuPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4zXCIgcj1cIjkwXCIgLz5cbjxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuMlwiIHI9XCIxMTBcIiAvPlxuPHRleHQgeD1cIjUwJVwiIHk9XCI1MCVcIiBzdHlsZT1cImZpbGw6I2ZmZlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCIgZm9udC1zaXplPVwiNTBcIiBkb21pbmFudC1iYXNlbGluZT1cIm1pZGRsZVwiIGZvbnQtZmFtaWx5PVwicm9ib3RvLGFyaWFsLHNhbnMtc2VyaWZcIj4ke2NvdW50fTwvdGV4dD5cbjwvc3ZnPmA7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gYENsdXN0ZXIgb2YgJHtjb3VudH0gbWFya2Vyc2AsIFxuICAgICAgICAvLyBhZGp1c3QgekluZGV4IHRvIGJlIGFib3ZlIG90aGVyIG1hcmtlcnNcbiAgICAgICAgekluZGV4ID0gTnVtYmVyKGdvb2dsZS5tYXBzLk1hcmtlci5NQVhfWklOREVYKSArIGNvdW50O1xuICAgICAgICBpZiAoTWFya2VyVXRpbHMuaXNBZHZhbmNlZE1hcmtlckF2YWlsYWJsZShtYXApKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgY2x1c3RlciBTVkcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdmc7XG4gICAgICAgICAgICBjb25zdCBzdmdFbCA9IGRpdi5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIHN2Z0VsLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwIDI1KVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogc3ZnRWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KGNsdXN0ZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2Eoc3ZnKX1gLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogbmV3IGdvb2dsZS5tYXBzLlBvaW50KDI1LCAyNSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihjbHVzdGVyT3B0aW9ucyk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFeHRlbmRzIGFuIG9iamVjdCdzIHByb3RvdHlwZSBieSBhbm90aGVyJ3MuXG4gKlxuICogQHBhcmFtIHR5cGUxIFRoZSBUeXBlIHRvIGJlIGV4dGVuZGVkLlxuICogQHBhcmFtIHR5cGUyIFRoZSBUeXBlIHRvIGV4dGVuZCB3aXRoLlxuICogQGlnbm9yZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZXh0ZW5kKHR5cGUxLCB0eXBlMikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHR5cGUyLnByb3RvdHlwZSkge1xuICAgICAgICB0eXBlMS5wcm90b3R5cGVbcHJvcGVydHldID0gdHlwZTIucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgICB9XG59XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgT3ZlcmxheVZpZXdTYWZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gTWFya2VyQ2x1c3RlcmVyIGltcGxlbWVudHMgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcgaW50ZXJmYWNlLiBXZSB1c2UgdGhlXG4gICAgICAgIC8vIGV4dGVuZCBmdW5jdGlvbiB0byBleHRlbmQgTWFya2VyQ2x1c3RlcmVyIHdpdGggZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXdcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBtaWdodCBub3QgYWx3YXlzIGJlIGF2YWlsYWJsZSB3aGVuIHRoZSBjb2RlIGlzIGRlZmluZWQgc28gd2VcbiAgICAgICAgLy8gbG9vayBmb3IgaXQgYXQgdGhlIGxhc3QgcG9zc2libGUgbW9tZW50LiBJZiBpdCBkb2Vzbid0IGV4aXN0IG5vdyB0aGVuXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGdvaW5nIGFoZWFkIDopXG4gICAgICAgIGV4dGVuZChPdmVybGF5Vmlld1NhZmUsIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBNYXJrZXJDbHVzdGVyZXJFdmVudHM7XG4oZnVuY3Rpb24gKE1hcmtlckNsdXN0ZXJlckV2ZW50cykge1xuICAgIE1hcmtlckNsdXN0ZXJlckV2ZW50c1tcIkNMVVNURVJJTkdfQkVHSU5cIl0gPSBcImNsdXN0ZXJpbmdiZWdpblwiO1xuICAgIE1hcmtlckNsdXN0ZXJlckV2ZW50c1tcIkNMVVNURVJJTkdfRU5EXCJdID0gXCJjbHVzdGVyaW5nZW5kXCI7XG4gICAgTWFya2VyQ2x1c3RlcmVyRXZlbnRzW1wiQ0xVU1RFUl9DTElDS1wiXSA9IFwiY2xpY2tcIjtcbn0pKE1hcmtlckNsdXN0ZXJlckV2ZW50cyB8fCAoTWFya2VyQ2x1c3RlcmVyRXZlbnRzID0ge30pKTtcbmNvbnN0IGRlZmF1bHRPbkNsdXN0ZXJDbGlja0hhbmRsZXIgPSAoXywgY2x1c3RlciwgbWFwKSA9PiB7XG4gICAgbWFwLmZpdEJvdW5kcyhjbHVzdGVyLmJvdW5kcyk7XG59O1xuLyoqXG4gKiBNYXJrZXJDbHVzdGVyZXIgY3JlYXRlcyBhbmQgbWFuYWdlcyBwZXItem9vbS1sZXZlbCBjbHVzdGVycyBmb3IgbGFyZ2UgYW1vdW50c1xuICogb2YgbWFya2Vycy4gU2VlIHtAbGluayBNYXJrZXJDbHVzdGVyZXJPcHRpb25zfSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqL1xuY2xhc3MgTWFya2VyQ2x1c3RlcmVyIGV4dGVuZHMgT3ZlcmxheVZpZXdTYWZlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1hcCwgbWFya2VycyA9IFtdLCBhbGdvcml0aG1PcHRpb25zID0ge30sIGFsZ29yaXRobSA9IG5ldyBTdXBlckNsdXN0ZXJBbGdvcml0aG0oYWxnb3JpdGhtT3B0aW9ucyksIHJlbmRlcmVyID0gbmV3IERlZmF1bHRSZW5kZXJlcigpLCBvbkNsdXN0ZXJDbGljayA9IGRlZmF1bHRPbkNsdXN0ZXJDbGlja0hhbmRsZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gWy4uLm1hcmtlcnNdO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMub25DbHVzdGVyQ2xpY2sgPSBvbkNsdXN0ZXJDbGljaztcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRNYXJrZXIobWFya2VyLCBub0RyYXcpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5pbmNsdWRlcyhtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTWFya2VycyhtYXJrZXJzLCBub0RyYXcpIHtcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyKG1hcmtlciwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNYXJrZXIobWFya2VyLCBub0RyYXcpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1hcmtlcnMuaW5kZXhPZihtYXJrZXIpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMsIHNvIGRvIG5vdGhpbmc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgTWFya2VyVXRpbHMuc2V0TWFwKG1hcmtlciwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpOyAvLyBSZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBsaXN0IG9mIG1hbmFnZWQgbWFya2Vyc1xuICAgICAgICBpZiAoIW5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlTWFya2VycyhtYXJrZXJzLCBub0RyYXcpIHtcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0aGlzLnJlbW92ZU1hcmtlcihtYXJrZXIsIHRydWUpIHx8IHJlbW92ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVtb3ZlZCAmJiAhbm9EcmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICBjbGVhck1hcmtlcnMobm9EcmF3KSB7XG4gICAgICAgIHRoaXMubWFya2Vycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoIW5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgYW5kIGRyYXdzIGFsbCB0aGUgbWFya2VyIGNsdXN0ZXJzLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLk1hcCAmJiBtYXAuZ2V0UHJvamVjdGlvbigpKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsIE1hcmtlckNsdXN0ZXJlckV2ZW50cy5DTFVTVEVSSU5HX0JFR0lOLCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2x1c3RlcnMsIGNoYW5nZWQgfSA9IHRoaXMuYWxnb3JpdGhtLmNhbGN1bGF0ZSh7XG4gICAgICAgICAgICAgICAgbWFya2VyczogdGhpcy5tYXJrZXJzLFxuICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uOiB0aGlzLmdldFByb2plY3Rpb24oKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWxsb3cgYWxnb3JpdGhtcyB0byByZXR1cm4gZmxhZyBvbiB3aGV0aGVyIHRoZSBjbHVzdGVycy9tYXJrZXJzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkIHx8IGNoYW5nZWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgbWFya2VycyBvZiB0aGUgY2x1c3RlcnMgY29tcG9zZWQgb2YgYSBzaW5nbGUgbWFya2VyLlxuICAgICAgICAgICAgICAgIC8vIFRob3NlIGNsdXN0ZXJzIGRpcmVjdGx5IHVzZSB0aGUgbWFya2VyLlxuICAgICAgICAgICAgICAgIC8vIENsdXN0ZXJzIHdpdGggbW9yZSB0aGFuIG9uZSBtYXJrZXJzIHVzZSBhIGdyb3VwIG1hcmtlciBnZW5lcmF0ZWQgYnkgYSByZW5kZXJlci5cbiAgICAgICAgICAgICAgICBjb25zdCBzaW5nbGVNYXJrZXIgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIGNsdXN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyLm1hcmtlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZU1hcmtlci5hZGQoY2x1c3Rlci5tYXJrZXJzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBncm91cE1hcmtlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBjbHVzdGVycyB0aGF0IGFyZSBjdXJyZW50bHkgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIHRoaXMuY2x1c3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIubWFya2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyLm1hcmtlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2luZ2xlTWFya2VyLmhhcyhjbHVzdGVyLm1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWFya2VyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgYmVjYXVzZSBpdCBpcyBmcm9tIGEgY2x1c3RlciB3aXRoIDEgbWFya2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gc2hvdWxkIG5vIG1vcmUgYmUgcmVuZGVyZWQgYXMgaXQgaXMgbm90IGluIHNpbmdsZU1hcmtlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXJrZXJVdGlscy5zZXRNYXAoY2x1c3Rlci5tYXJrZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlbW92YWwgb2Ygb2xkIGdyb3VwIG1hcmtlcnMgdG8gYXZvaWQgZmxpY2tlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwTWFya2Vycy5wdXNoKGNsdXN0ZXIubWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJzID0gY2x1c3RlcnM7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDbHVzdGVycygpO1xuICAgICAgICAgICAgICAgIC8vIERlbGF5ZWQgcmVtb3ZhbCBvZiB0aGUgbWFya2VycyBvZiB0aGUgZm9ybWVyIGdyb3Vwcy5cbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZ3JvdXBNYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4gTWFya2VyVXRpbHMuc2V0TWFwKG1hcmtlciwgbnVsbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgTWFya2VyQ2x1c3RlcmVyRXZlbnRzLkNMVVNURVJJTkdfRU5ELCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkFkZCgpIHtcbiAgICAgICAgdGhpcy5pZGxlTGlzdGVuZXIgPSB0aGlzLmdldE1hcCgpLmFkZExpc3RlbmVyKFwiaWRsZVwiLCB0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgb25SZW1vdmUoKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuaWRsZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4gTWFya2VyVXRpbHMuc2V0TWFwKG1hcmtlciwgbnVsbCkpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzLmZvckVhY2goKGNsdXN0ZXIpID0+IGNsdXN0ZXIuZGVsZXRlKCkpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgfVxuICAgIHJlbmRlckNsdXN0ZXJzKCkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBzdGF0cyB0byBwYXNzIHRvIHJlbmRlcmVycy5cbiAgICAgICAgY29uc3Qgc3RhdHMgPSBuZXcgQ2x1c3RlclN0YXRzKHRoaXMubWFya2VycywgdGhpcy5jbHVzdGVycyk7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMuZm9yRWFjaCgoY2x1c3RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNsdXN0ZXIubWFya2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyLm1hcmtlciA9IGNsdXN0ZXIubWFya2Vyc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBtYXJrZXIgdG8gcmVwcmVzZW50IHRoZSBncm91cC5cbiAgICAgICAgICAgICAgICBjbHVzdGVyLm1hcmtlciA9IHRoaXMucmVuZGVyZXIucmVuZGVyKGNsdXN0ZXIsIHN0YXRzLCBtYXApO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgaW5kaXZpZHVhbCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgICAgICBjbHVzdGVyLm1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiBNYXJrZXJVdGlscy5zZXRNYXAobWFya2VyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbHVzdGVyQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5tYXJrZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCBcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsIE1hcmtlckNsdXN0ZXJlckV2ZW50cy5DTFVTVEVSX0NMSUNLLCBjbHVzdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbHVzdGVyQ2xpY2soZXZlbnQsIGNsdXN0ZXIsIG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE1hcmtlclV0aWxzLnNldE1hcChjbHVzdGVyLm1hcmtlciwgbWFwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG52YXIgaW5kZXhfZXNtID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBBYnN0cmFjdEFsZ29yaXRobTogQWJzdHJhY3RBbGdvcml0aG0sXG4gICAgQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobTogQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobSxcbiAgICBDbHVzdGVyOiBDbHVzdGVyLFxuICAgIENsdXN0ZXJTdGF0czogQ2x1c3RlclN0YXRzLFxuICAgIERlZmF1bHRSZW5kZXJlcjogRGVmYXVsdFJlbmRlcmVyLFxuICAgIEdyaWRBbGdvcml0aG06IEdyaWRBbGdvcml0aG0sXG4gICAgTWFya2VyQ2x1c3RlcmVyOiBNYXJrZXJDbHVzdGVyZXIsXG4gICAgZ2V0IE1hcmtlckNsdXN0ZXJlckV2ZW50cyAoKSB7IHJldHVybiBNYXJrZXJDbHVzdGVyZXJFdmVudHM7IH0sXG4gICAgTm9vcEFsZ29yaXRobTogTm9vcEFsZ29yaXRobSxcbiAgICBTdXBlckNsdXN0ZXJBbGdvcml0aG06IFN1cGVyQ2x1c3RlckFsZ29yaXRobSxcbiAgICBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyOiBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyLFxuICAgIGRpc3RhbmNlQmV0d2VlblBvaW50czogZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLFxuICAgIGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQ6IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQsXG4gICAgZXh0ZW5kUGl4ZWxCb3VuZHM6IGV4dGVuZFBpeGVsQm91bmRzLFxuICAgIGZpbHRlck1hcmtlcnNUb1BhZGRlZFZpZXdwb3J0OiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydCxcbiAgICBub29wOiBub29wJDEsXG4gICAgcGl4ZWxCb3VuZHNUb0xhdExuZ0JvdW5kczogcGl4ZWxCb3VuZHNUb0xhdExuZ0JvdW5kc1xufSk7XG5cbmZ1bmN0aW9uIHVzZUdvb2dsZU1hcmtlckNsdXN0ZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIG1hcCA9IHVzZUdvb2dsZU1hcCgpO1xuICAgIHZhciBfYSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtYXJrZXJDbHVzdGVyZXIgPSBfYVswXSwgc2V0TWFya2VyQ2x1c3RlcmVyID0gX2FbMV07XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBtYXJrZXJDbHVzdGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJDbHVzdGVyID0gbmV3IE1hcmtlckNsdXN0ZXJlcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICAgICAgc2V0TWFya2VyQ2x1c3RlcmVyKG1hcmtlckNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHJldHVybiBtYXJrZXJDbHVzdGVyZXI7XG59XG4vKiogV3JhcHBlciBhcm91bmQgW0Bnb29nbGVtYXBzL21hcmtlcmNsdXN0ZXJlcl0oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZW1hcHMvanMtbWFya2VyY2x1c3RlcmVyKVxuICpcbiAqIEFjY2VwdHMge0BsaW5rICBNYXJrZXJDbHVzdGVyZXJPcHRpb25zU3Vic2V0fSB3aGljaCBpcyBhIHN1YnNldCBvZiAge0BsaW5rIE1hcmtlckNsdXN0ZXJlck9wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIEdvb2dsZU1hcmtlckNsdXN0ZXJlcihfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICB2YXIgbWFya2VyQ2x1c3RlcmVyID0gdXNlR29vZ2xlTWFya2VyQ2x1c3RlcmVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBtYXJrZXJDbHVzdGVyZXIgIT09IG51bGwgPyBjaGlsZHJlbihtYXJrZXJDbHVzdGVyZXIpIDogbnVsbDtcbn1cbnZhciBHb29nbGVNYXJrZXJDbHVzdGVyZXIkMSA9IHJlYWN0Lm1lbW8oR29vZ2xlTWFya2VyQ2x1c3RlcmVyKTtcblxudmFyIGV2ZW50TWFwJGMgPSB7XG4gICAgb25DbG9zZUNsaWNrOiAnY2xvc2VjbGljaycsXG4gICAgb25Db250ZW50Q2hhbmdlZDogJ2NvbnRlbnRfY2hhbmdlZCcsXG4gICAgb25Eb21SZWFkeTogJ2RvbXJlYWR5JyxcbiAgICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICAgIG9uWmluZGV4Q2hhbmdlZDogJ3ppbmRleF9jaGFuZ2VkJyxcbn07XG52YXIgdXBkYXRlck1hcCRjID0ge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uIChpbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH0sXG4gICAgekluZGV4OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIEluZm9XaW5kb3dGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGFuY2hvciA9IF9hLmFuY2hvciwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHpJbmRleCA9IF9hLnpJbmRleCwgb25DbG9zZUNsaWNrID0gX2Eub25DbG9zZUNsaWNrLCBvbkRvbVJlYWR5ID0gX2Eub25Eb21SZWFkeSwgb25Db250ZW50Q2hhbmdlZCA9IF9hLm9uQ29udGVudENoYW5nZWQsIG9uUG9zaXRpb25DaGFuZ2VkID0gX2Eub25Qb3NpdGlvbkNoYW5nZWQsIG9uWmluZGV4Q2hhbmdlZCA9IF9hLm9uWmluZGV4Q2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGNsb3NlY2xpY2tMaXN0ZW5lciA9IF9jWzBdLCBzZXRDbG9zZUNsaWNrTGlzdGVuZXIgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZG9tcmVhZHljbGlja0xpc3RlbmVyID0gX2RbMF0sIHNldERvbVJlYWR5Q2xpY2tMaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIgPSBfZVswXSwgc2V0Q29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHBvc2l0aW9uY2hhbmdlZGNsaWNrTGlzdGVuZXIgPSBfZlswXSwgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9mWzFdO1xuICAgIHZhciBfZyA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCB6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lciA9IF9nWzBdLCBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9nWzFdO1xuICAgIHZhciBjb250YWluZXJFbGVtZW50UmVmID0gcmVhY3QudXNlUmVmKG51bGwpO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm9wZW4obWFwLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm9wZW4obWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXAsIGluc3RhbmNlLCBhbmNob3JdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfSwgW3Bvc2l0aW9uXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB6SW5kZXggPT09ICdudW1iZXInICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sIFt6SW5kZXhdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbG9zZUNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xvc2VjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsb3NlQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsb3NlQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Eb21SZWFkeSkge1xuICAgICAgICAgICAgaWYgKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRvbVJlYWR5XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY29udGVudF9jaGFuZ2VkJywgb25Db250ZW50Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ29udGVudENoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9zaXRpb25jaGFuZ2VkY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Qb3NpdGlvbkNoYW5nZWRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25aaW5kZXhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoemluZGV4Y2hhbmdlZGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25aaW5kZXhDaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSk7XG4gICAgICAgIHNldEluc3RhbmNlKGluZm9XaW5kb3cpO1xuICAgICAgICBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaWYgKG9uQ2xvc2VDbGljaykge1xuICAgICAgICAgICAgc2V0Q2xvc2VDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3csICdjbG9zZWNsaWNrJywgb25DbG9zZUNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRG9tUmVhZHkpIHtcbiAgICAgICAgICAgIHNldERvbVJlYWR5Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvV2luZG93LCAnZG9tcmVhZHknLCBvbkRvbVJlYWR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvV2luZG93LCAnY29udGVudF9jaGFuZ2VkJywgb25Db250ZW50Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvV2luZG93LCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5zZXRDb250ZW50KGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpJbmRleCkge1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRaSW5kZXgoekluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICBpbmZvV2luZG93Lm9wZW4obWFwLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZm9XaW5kb3cuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQkMShmYWxzZSwgXCJZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3IgKHR5cGljYWxseSByZW5kZXIgaXQgaW5zaWRlIGEgPE1hcmtlcj4pIG9yIGEgcG9zaXRpb24gcHJvcHMgZm9yIDxJbmZvV2luZG93Pi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKGluZm9XaW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VjbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xvc2VjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb25jaGFuZ2VkY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uY2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHppbmRleGNoYW5nZWRjbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoemluZGV4Y2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudChpbmZvV2luZG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCA/IChSZWFjdERPTS5jcmVhdGVQb3J0YWwocmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCkpIDogKG51bGwpO1xufVxudmFyIEluZm9XaW5kb3dGID0gcmVhY3QubWVtbyhJbmZvV2luZG93RnVuY3Rpb25hbCk7XG52YXIgSW5mb1dpbmRvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5mb1dpbmRvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZvV2luZG93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5jb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmZvV2luZG93OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vcGVuID0gZnVuY3Rpb24gKGluZm9XaW5kb3csIGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihfdGhpcy5jb250ZXh0LCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5mb1dpbmRvdy5nZXRQb3NpdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKF90aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50JDEoZmFsc2UsIFwiWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yICh0eXBpY2FsbHkgcmVuZGVyIGl0IGluc2lkZSBhIDxNYXJrZXI+KSBvciBhIHBvc2l0aW9uIHByb3BzIGZvciA8SW5mb1dpbmRvdz4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRJbmZvV2luZG93Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuaW5mb1dpbmRvdyAhPT0gbnVsbCAmJiBfdGhpcy5jb250YWluZXJFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuaW5mb1dpbmRvdy5zZXRDb250ZW50KF90aGlzLmNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oX3RoaXMuc3RhdGUuaW5mb1dpbmRvdywgX3RoaXMucHJvcHMuYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5pbmZvV2luZG93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mb1dpbmRvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coX19hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRjLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbmZvV2luZG93LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZm9XaW5kb3c6IGluZm9XaW5kb3csXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldEluZm9XaW5kb3dDYWxsYmFjayk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuaW5mb1dpbmRvdyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvV2luZG93LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5mb1dpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5pbmZvV2luZG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5mb1dpbmRvdy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvV2luZG93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPyAoUmVhY3RET00uY3JlYXRlUG9ydGFsKHJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHRoaXMuY29udGFpbmVyRWxlbWVudCkpIDogKG51bGwpO1xuICAgIH07XG4gICAgSW5mb1dpbmRvdy5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEluZm9XaW5kb3c7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJGIgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbnZhciB1cGRhdGVyTWFwJGIgPSB7XG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBhdGg6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGF0aCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQYXRoKHBhdGgpO1xuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkMSA9IHt9O1xuZnVuY3Rpb24gUG9seWxpbmVGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBwYXRoID0gX2EucGF0aCwgb25EYmxDbGljayA9IF9hLm9uRGJsQ2xpY2ssIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCwgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25Nb3VzZU1vdmUgPSBfYS5vbk1vdXNlTW92ZSwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBvbkNsaWNrID0gX2Eub25DbGljaywgb25EcmFnID0gX2Eub25EcmFnLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gcmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZGJsY2xpY2tMaXN0ZW5lciA9IF9jWzBdLCBzZXREYmxjbGlja0xpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdlbmRMaXN0ZW5lciA9IF9kWzBdLCBzZXREcmFnZW5kTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVswXSwgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2Vkb3duTGlzdGVuZXIgPSBfZlswXSwgc2V0TW91c2Vkb3duTGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2VvdXRMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW91dExpc3RlbmVyID0gX2hbMV07XG4gICAgdmFyIF9qID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMF0sIHNldE1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNldXBMaXN0ZW5lciA9IF9rWzBdLCBzZXRNb3VzZXVwTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgcmlnaHRjbGlja0xpc3RlbmVyID0gX2xbMF0sIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzFdO1xuICAgIHZhciBfbSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjbGlja0xpc3RlbmVyID0gX21bMF0sIHNldENsaWNrTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ0xpc3RlbmVyID0gX29bMF0sIHNldERyYWdMaXN0ZW5lciA9IF9vWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZHJhZ2dhYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZWRpdGFibGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgcGF0aF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdFbmRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQxKSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwb2x5bGluZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwb2x5bGluZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwb2x5bGluZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIHNldE1vdXNlbW92ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU91dCkge1xuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnKSB7XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5zdGFuY2UocG9seWxpbmUpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQocG9seWxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ3N0YXJ0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNldXBMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgb25Vbm1vdW50KHBvbHlsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvbHlsaW5lLnNldE1hcChudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgUG9seWxpbmVGID0gcmVhY3QubWVtbyhQb2x5bGluZUZ1bmN0aW9uYWwpO1xudmFyIFBvbHlsaW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb2x5bGluZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb2x5bGluZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwb2x5bGluZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0UG9seWxpbmVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5wb2x5bGluZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUucG9seWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvbHlsaW5lLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYixcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRiLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBwb2x5bGluZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0UG9seWxpbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lOiBwb2x5bGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0UG9seWxpbmVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBQb2x5bGluZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRiLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRiLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5wb2x5bGluZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb2x5bGluZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbHlsaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnBvbHlsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucG9seWxpbmUuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb2x5bGluZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBvbHlsaW5lLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gUG9seWxpbmU7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJGEgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbnZhciB1cGRhdGVyTWFwJGEgPSB7XG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBhdGg6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGF0aCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQYXRoKHBhdGgpO1xuICAgIH0sXG4gICAgcGF0aHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGF0aHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aHMocGF0aHMpO1xuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBQb2x5Z29uRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgZHJhZ2dhYmxlID0gX2EuZHJhZ2dhYmxlLCBlZGl0YWJsZSA9IF9hLmVkaXRhYmxlLCB2aXNpYmxlID0gX2EudmlzaWJsZSwgcGF0aCA9IF9hLnBhdGgsIHBhdGhzID0gX2EucGF0aHMsIG9uRGJsQ2xpY2sgPSBfYS5vbkRibENsaWNrLCBvbkRyYWdFbmQgPSBfYS5vbkRyYWdFbmQsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uTW91c2VEb3duID0gX2Eub25Nb3VzZURvd24sIG9uTW91c2VNb3ZlID0gX2Eub25Nb3VzZU1vdmUsIG9uTW91c2VPdXQgPSBfYS5vbk1vdXNlT3V0LCBvbk1vdXNlT3ZlciA9IF9hLm9uTW91c2VPdmVyLCBvbk1vdXNlVXAgPSBfYS5vbk1vdXNlVXAsIG9uUmlnaHRDbGljayA9IF9hLm9uUmlnaHRDbGljaywgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRHJhZyA9IF9hLm9uRHJhZywgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMF0sIHNldE1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzFdO1xuICAgIHZhciBfayA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRSaWdodGNsaWNrTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9tWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9vWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfb1sxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYWdnYWJsZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVkaXRhYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdmlzaWJsZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHBhdGhdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhzICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aHMocGF0aHMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBwYXRoc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdFbmRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWdvbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBtYXA6IG1hcCB9KSk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhzKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFBhdGhzKHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBvbHlnb24uc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcG9seWdvbi5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VVcCkge1xuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmlnaHRDbGljaykge1xuICAgICAgICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWcpIHtcbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZHJhZycsIG9uRHJhZykpO1xuICAgICAgICB9XG4gICAgICAgIHNldEluc3RhbmNlKHBvbHlnb24pO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQocG9seWdvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQocG9seWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2x5Z29uLnNldE1hcChudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgUG9seWdvbkYgPSByZWFjdC5tZW1vKFBvbHlnb25GdW5jdGlvbmFsKTtcbnZhciBQb2x5Z29uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb2x5Z29uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9seWdvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0UG9seWdvbkNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnBvbHlnb24gIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnBvbHlnb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvbHlnb24ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYSxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRhLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBwb2x5Z29uLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRQb2x5Z29uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uOiBwb2x5Z29uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRQb2x5Z29uQ2FsbGJhY2spO1xuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5Z29uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGEsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGEsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnBvbHlnb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbHlnb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUucG9seWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvbHlnb24gJiYgdGhpcy5zdGF0ZS5wb2x5Z29uLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBvbHlnb24uY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBQb2x5Z29uO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQ5ID0ge1xuICAgIG9uQm91bmRzQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25SaWdodENsaWNrOiAncmlnaHRjbGljaycsXG59O1xudmFyIHVwZGF0ZXJNYXAkOSA9IHtcbiAgICBib3VuZHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgYm91bmRzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH0sXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHZpc2libGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gUmVjdGFuZ2xlRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgYm91bmRzID0gX2EuYm91bmRzLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlTW92ZSA9IF9hLm9uTW91c2VNb3ZlLCBvbk1vdXNlT3V0ID0gX2Eub25Nb3VzZU91dCwgb25Nb3VzZU92ZXIgPSBfYS5vbk1vdXNlT3Zlciwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBvblJpZ2h0Q2xpY2sgPSBfYS5vblJpZ2h0Q2xpY2ssIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uQm91bmRzQ2hhbmdlZCA9IF9hLm9uQm91bmRzQ2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMF0sIHNldE1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzFdO1xuICAgIHZhciBfayA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHJpZ2h0Q2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRSaWdodENsaWNrTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9tWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9vWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfb1sxXTtcbiAgICB2YXIgX3AgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgYm91bmRzQ2hhbmdlZExpc3RlbmVyID0gX3BbMF0sIHNldEJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IF9wWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZHJhZ2dhYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZWRpdGFibGVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib3VuZHMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgYm91bmRzXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ0VuZF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ1N0YXJ0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZURvd25dKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlbW92ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlTW92ZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdXRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VVcF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodENsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmlnaHRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uUmlnaHRDbGlja10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWddKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Cb3VuZHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEJvdW5kc0NoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2JvdW5kc19jaGFuZ2VkJywgb25Cb3VuZHNDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Cb3VuZHNDaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3RhbmdsZSA9IG5ldyBnb29nbGUubWFwcy5SZWN0YW5nbGUoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZWN0YW5nbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVjdGFuZ2xlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvdW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHNldFJpZ2h0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Cb3VuZHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRCb3VuZHNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnYm91bmRzX2NoYW5nZWQnLCBvbkJvdW5kc0NoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnN0YW5jZShyZWN0YW5nbGUpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQocmVjdGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Q2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQocmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIFJlY3RhbmdsZUYgPSByZWFjdC5tZW1vKFJlY3RhbmdsZUZ1bmN0aW9uYWwpO1xudmFyIFJlY3RhbmdsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdGFuZ2xlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByZWN0YW5nbGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFJlY3RhbmdsZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnJlY3RhbmdsZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdGFuZ2xlID0gbmV3IGdvb2dsZS5tYXBzLlJlY3RhbmdsZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDksXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOSxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogcmVjdGFuZ2xlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRSZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogcmVjdGFuZ2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRSZWN0YW5nbGVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVjdGFuZ2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDksXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDksXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnJlY3RhbmdsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWN0YW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjdGFuZ2xlLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdGFuZ2xlLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gUmVjdGFuZ2xlO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQ4ID0ge1xuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvblJhZGl1c0NoYW5nZWQ6ICdyYWRpdXNfY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbnZhciB1cGRhdGVyTWFwJDggPSB7XG4gICAgY2VudGVyOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNlbnRlcikge1xuICAgICAgICBpbnN0YW5jZS5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9LFxuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfSxcbiAgICBlZGl0YWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICByYWRpdXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmFkaXVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbmZ1bmN0aW9uIENpcmNsZUZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGNlbnRlciA9IF9hLmNlbnRlciwgcmFkaXVzID0gX2EucmFkaXVzLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlTW92ZSA9IF9hLm9uTW91c2VNb3ZlLCBvbk1vdXNlT3V0ID0gX2Eub25Nb3VzZU91dCwgb25Nb3VzZU92ZXIgPSBfYS5vbk1vdXNlT3Zlciwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBvblJpZ2h0Q2xpY2sgPSBfYS5vblJpZ2h0Q2xpY2ssIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uQ2VudGVyQ2hhbmdlZCA9IF9hLm9uQ2VudGVyQ2hhbmdlZCwgb25SYWRpdXNDaGFuZ2VkID0gX2Eub25SYWRpdXNDaGFuZ2VkLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gcmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZGJsY2xpY2tMaXN0ZW5lciA9IF9jWzBdLCBzZXREYmxjbGlja0xpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRyYWdlbmRMaXN0ZW5lciA9IF9kWzBdLCBzZXREcmFnZW5kTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVswXSwgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2Vkb3duTGlzdGVuZXIgPSBfZlswXSwgc2V0TW91c2Vkb3duTGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2VvdXRMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW91dExpc3RlbmVyID0gX2hbMV07XG4gICAgdmFyIF9qID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMF0sIHNldE1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gcmVhY3QudXNlU3RhdGUobnVsbCksIG1vdXNldXBMaXN0ZW5lciA9IF9rWzBdLCBzZXRNb3VzZXVwTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgcmlnaHRjbGlja0xpc3RlbmVyID0gX2xbMF0sIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzFdO1xuICAgIHZhciBfbSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjbGlja0xpc3RlbmVyID0gX21bMF0sIHNldENsaWNrTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgZHJhZ0xpc3RlbmVyID0gX29bMF0sIHNldERyYWdMaXN0ZW5lciA9IF9vWzFdO1xuICAgIHZhciBfcCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBjZW50ZXJDaGFuZ2VkTGlzdGVuZXIgPSBfcFswXSwgc2V0Q2VudGVyQ2hhbmdlZExpc3RlbmVyID0gX3BbMV07XG4gICAgdmFyIF9xID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHJhZGl1c0NoYW5nZWRMaXN0ZW5lciA9IF9xWzBdLCBzZXRSYWRpdXNDaGFuZ2VkTGlzdGVuZXIgPSBfcVsxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYWdnYWJsZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVkaXRhYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdmlzaWJsZV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHJhZGl1c10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGNlbnRlcl0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdFbmRdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2VudGVyQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjZW50ZXJfY2hhbmdlZCcsIG9uQ2VudGVyQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SYWRpdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAocmFkaXVzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmFkaXVzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJhZGl1c0NoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JhZGl1c19jaGFuZ2VkJywgb25SYWRpdXNDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SYWRpdXNDaGFuZ2VkXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBnb29nbGUubWFwcy5DaXJjbGUoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zKSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNlbnRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjaXJjbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY2lyY2xlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DZW50ZXJDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnY2VudGVyX2NoYW5nZWQnLCBvbkNlbnRlckNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25SYWRpdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRSYWRpdXNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAncmFkaXVzX2NoYW5nZWQnLCBvblJhZGl1c0NoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnN0YW5jZShjaXJjbGUpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoY2lyY2xlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFkaXVzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmFkaXVzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQoY2lyY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpcmNsZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIENpcmNsZUYgPSByZWFjdC5tZW1vKENpcmNsZUZ1bmN0aW9uYWwpO1xudmFyIENpcmNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2lyY2xlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaXJjbGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldENpcmNsZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuY2lyY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogY2lyY2xlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRDaXJjbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNpcmNsZTogY2lyY2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRDaXJjbGVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2lyY2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDgsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmNpcmNsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5jaXJjbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zdGF0ZS5jaXJjbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENpcmNsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENpcmNsZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIENpcmNsZTtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkNyA9IHtcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxuICAgIG9uQWRkRmVhdHVyZTogJ2FkZGZlYXR1cmUnLFxuICAgIG9uUmVtb3ZlRmVhdHVyZTogJ3JlbW92ZWZlYXR1cmUnLFxuICAgIG9uUmVtb3ZlUHJvcGVydHk6ICdyZW1vdmVwcm9wZXJ0eScsXG4gICAgb25TZXRHZW9tZXRyeTogJ3NldGdlb21ldHJ5JyxcbiAgICBvblNldFByb3BlcnR5OiAnc2V0cHJvcGVydHknLFxufTtcbnZhciB1cGRhdGVyTWFwJDcgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UuYWRkKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgYWRkZ2VvanNvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLmFkZEdlb0pzb24oZ2VvanNvbiwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24gKGluc3RhbmNlLCBmZWF0dXJlKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbnRhaW5zKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgZm9yZWFjaDogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGxvYWRnZW9qc29uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaW5zdGFuY2UubG9hZEdlb0pzb24odXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvdmVycmlkZXN0eWxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUsIHN0eWxlKSB7XG4gICAgICAgIGluc3RhbmNlLm92ZXJyaWRlU3R5bGUoZmVhdHVyZSwgc3R5bGUpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UucmVtb3ZlKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgcmV2ZXJ0c3R5bGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZmVhdHVyZSkge1xuICAgICAgICBpbnN0YW5jZS5yZXZlcnRTdHlsZShmZWF0dXJlKTtcbiAgICB9LFxuICAgIGNvbnRyb2xwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBjb250cm9sUG9zaXRpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udHJvbFBvc2l0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgfSxcbiAgICBjb250cm9sczogZnVuY3Rpb24gKGluc3RhbmNlLCBjb250cm9scykge1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250cm9scyhjb250cm9scyk7XG4gICAgfSxcbiAgICBkcmF3aW5nbW9kZTogZnVuY3Rpb24gKGluc3RhbmNlLCBtb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERyYXdpbmdNb2RlKG1vZGUpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIHN0eWxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHN0eWxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9LFxuICAgIHRvZ2VvanNvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS50b0dlb0pzb24oY2FsbGJhY2spO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gRGF0YUZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25Nb3VzZU1vdmUgPSBfYS5vbk1vdXNlTW92ZSwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBvbkFkZEZlYXR1cmUgPSBfYS5vbkFkZEZlYXR1cmUsIG9uUmVtb3ZlRmVhdHVyZSA9IF9hLm9uUmVtb3ZlRmVhdHVyZSwgb25SZW1vdmVQcm9wZXJ0eSA9IF9hLm9uUmVtb3ZlUHJvcGVydHksIG9uU2V0R2VvbWV0cnkgPSBfYS5vblNldEdlb21ldHJ5LCBvblNldFByb3BlcnR5ID0gX2Eub25TZXRQcm9wZXJ0eSwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZWRvd25MaXN0ZW5lciA9IF9kWzBdLCBzZXRNb3VzZWRvd25MaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW1vdmVMaXN0ZW5lciA9IF9lWzBdLCBzZXRNb3VzZW1vdmVMaXN0ZW5lciA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBtb3VzZW91dExpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlb3V0TGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2VvdmVyTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2VvdmVyTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSByZWFjdC51c2VTdGF0ZShudWxsKSwgbW91c2V1cExpc3RlbmVyID0gX2hbMF0sIHNldE1vdXNldXBMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCByaWdodGNsaWNrTGlzdGVuZXIgPSBfalswXSwgc2V0UmlnaHRjbGlja0xpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGNsaWNrTGlzdGVuZXIgPSBfa1swXSwgc2V0Q2xpY2tMaXN0ZW5lciA9IF9rWzFdO1xuICAgIHZhciBfbCA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBhZGRGZWF0dXJlTGlzdGVuZXIgPSBfbFswXSwgc2V0QWRkRmVhdHVyZUxpc3RlbmVyID0gX2xbMV07XG4gICAgdmFyIF9tID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHJlbW92ZUZlYXR1cmVMaXN0ZW5lciA9IF9tWzBdLCBzZXRSZW1vdmVGZWF0dXJlTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSByZWFjdC51c2VTdGF0ZShudWxsKSwgcmVtb3ZlUHJvcGVydHlMaXN0ZW5lciA9IF9vWzBdLCBzZXRSZW1vdmVQcm9wZXJ0eUxpc3RlbmVyID0gX29bMV07XG4gICAgdmFyIF9wID0gcmVhY3QudXNlU3RhdGUobnVsbCksIHNldEdlb21ldHJ5TGlzdGVuZXIgPSBfcFswXSwgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lciA9IF9wWzFdO1xuICAgIHZhciBfcSA9IHJlYWN0LnVzZVN0YXRlKG51bGwpLCBzZXRQcm9wZXJ0eUxpc3RlbmVyID0gX3FbMF0sIHNldFNldFByb3BlcnR5TGlzdGVuZXIgPSBfcVsxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQWRkRmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGFkZEZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBZGRGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdhZGRmZWF0dXJlJywgb25BZGRGZWF0dXJlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25BZGRGZWF0dXJlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUmVtb3ZlRmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZUZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlbW92ZUZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZW1vdmVGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZW1vdmVmZWF0dXJlJywgb25SZW1vdmVGZWF0dXJlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW1vdmVGZWF0dXJlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVQcm9wZXJ0eUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlUHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZW1vdmVQcm9wZXJ0eUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmVtb3ZlcHJvcGVydHknLCBvblJlbW92ZVByb3BlcnR5KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW1vdmVQcm9wZXJ0eV0pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblNldEdlb21ldHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2V0R2VvbWV0cnlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3NldGdlb21ldHJ5Jywgb25TZXRHZW9tZXRyeSkpO1xuICAgICAgICB9XG4gICAgfSwgW29uU2V0R2VvbWV0cnldKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25TZXRQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHNldFByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihzZXRQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFNldFByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdzZXRwcm9wZXJ0eScsIG9uU2V0UHJvcGVydHkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblNldFByb3BlcnR5XSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgZ29vZ2xlLm1hcHMuRGF0YShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBtYXA6IG1hcCB9KSk7XG4gICAgICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25BZGRGZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2V0QWRkRmVhdHVyZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdhZGRmZWF0dXJlJywgb25BZGRGZWF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZW1vdmVGZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVtb3ZlRmVhdHVyZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdyZW1vdmVmZWF0dXJlJywgb25SZW1vdmVGZWF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHNldFJlbW92ZVByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JlbW92ZXByb3BlcnR5Jywgb25SZW1vdmVQcm9wZXJ0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU2V0R2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZXRHZW9tZXRyeUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdzZXRnZW9tZXRyeScsIG9uU2V0R2VvbWV0cnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblNldFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgc2V0U2V0UHJvcGVydHlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnc2V0cHJvcGVydHknLCBvblNldFByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJbnN0YW5jZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkRmVhdHVyZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGZWF0dXJlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlRmVhdHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZVByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlUHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXRHZW9tZXRyeUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0UHJvcGVydHlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihzZXRQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvblVubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIERhdGFGID0gcmVhY3QubWVtbyhEYXRhRnVuY3Rpb25hbCk7XG52YXIgRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRhKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldERhdGFDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kYXRhICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFfMSA9IG5ldyBnb29nbGUubWFwcy5EYXRhKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ3LFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ3LFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBkYXRhXzEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFfMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5zZXREYXRhQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRhdGEuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRGF0YS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIERhdGE7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJDYgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRlZmF1bHRWaWV3cG9ydENoYW5nZWQ6ICdkZWZhdWx0dmlld3BvcnRfY2hhbmdlZCcsXG4gICAgb25TdGF0dXNDaGFuZ2VkOiAnc3RhdHVzX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJDYgPSB7XG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICB1cmw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdXJsKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFVybCh1cmwpO1xuICAgIH0sXG4gICAgekluZGV4OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9LFxufTtcbnZhciBLbWxMYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS21sTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS21sTGF5ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAga21sTGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEttbExheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmttbExheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBLbWxMYXllci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrbWxMYXllciA9IG5ldyBnb29nbGUubWFwcy5LbWxMYXllcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5vcHRpb25zKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ2LFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDYsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGttbExheWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRMbWxMYXllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga21sTGF5ZXI6IGttbExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRLbWxMYXllckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmttbExheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDYsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDYsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmttbExheWVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUua21sTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5rbWxMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgS21sTGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBLbWxMYXllcjtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRPdmVycmlkZShjb250YWluZXJFbGVtZW50LCBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldChjb250YWluZXJFbGVtZW50Lm9mZnNldFdpZHRoLCBjb250YWluZXJFbGVtZW50Lm9mZnNldEhlaWdodClcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBjcmVhdGVMYXRMbmcoaW5zdCwgVHlwZSkgeyByZXR1cm4gbmV3IFR5cGUoaW5zdC5sYXQsIGluc3QubG5nKTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGNyZWF0ZUxhdExuZ0JvdW5kcyhpbnN0LCBUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoaW5zdC5uZS5sYXQsIGluc3QubmUubG5nKSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhpbnN0LnN3LmxhdCwgaW5zdC5zdy5sbmcpKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBlbnN1cmVPZlR5cGUoaW5zdCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZmFjdG9yeVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIHJldHVybiBpbnN0IGluc3RhbmNlb2YgdHlwZSA/IGluc3QgOiBmYWN0b3J5KGluc3QsIHR5cGUpO1xufVxuZnVuY3Rpb24gZW5zdXJlT2ZUeXBlQm91bmRzKGluc3QsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZhY3Rvcnlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gaW5zdCBpbnN0YW5jZW9mIHR5cGUgPyBpbnN0IDogZmFjdG9yeShpbnN0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGdldExheW91dFN0eWxlc0J5Qm91bmRzKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgYm91bmRzKSB7XG4gICAgdmFyIG5lID0gbWFwQ2FudmFzUHJvamVjdGlvbiAmJiBtYXBDYW52YXNQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXROb3J0aEVhc3QoKSk7XG4gICAgdmFyIHN3ID0gbWFwQ2FudmFzUHJvamVjdGlvbiAmJiBtYXBDYW52YXNQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSk7XG4gICAgaWYgKG5lICYmIHN3KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChzdy54ICsgb2Zmc2V0LngsIFwicHhcIiksXG4gICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KG5lLnkgKyBvZmZzZXQueSwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChuZS54IC0gc3cueCAtIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChzdy55IC0gbmUueSAtIG9mZnNldC55LCBcInB4XCIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAnLTk5OTlweCcsXG4gICAgICAgIHRvcDogJy05OTk5cHgnLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMYXlvdXRTdHlsZXNCeVBvc2l0aW9uKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgcG9zaXRpb24pIHtcbiAgICB2YXIgcG9pbnQgPSBtYXBDYW52YXNQcm9qZWN0aW9uICYmIG1hcENhbnZhc1Byb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwocG9zaXRpb24pO1xuICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LngsIHkgPSBwb2ludC55O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogXCJcIi5jb25jYXQoeCArIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdCh5ICsgb2Zmc2V0LnksIFwicHhcIiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICctOTk5OXB4JyxcbiAgICAgICAgdG9wOiAnLTk5OTlweCcsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExheW91dFN0eWxlcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIGJvdW5kcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gYm91bmRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBnZXRMYXlvdXRTdHlsZXNCeUJvdW5kcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIGVuc3VyZU9mVHlwZUJvdW5kcyhib3VuZHMsIGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcywgY3JlYXRlTGF0TG5nQm91bmRzKSlcbiAgICAgICAgOiBnZXRMYXlvdXRTdHlsZXNCeVBvc2l0aW9uKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgZW5zdXJlT2ZUeXBlKHBvc2l0aW9uLCBnb29nbGUubWFwcy5MYXRMbmcsIGNyZWF0ZUxhdExuZykpO1xufVxuZnVuY3Rpb24gYXJlUG9zaXRpb25zRXF1YWwoY3VycmVudFBvc2l0aW9uLCBwcmV2aW91c1Bvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbi5sZWZ0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmxlZnRcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLnRvcCA9PT0gcHJldmlvdXNQb3NpdGlvbi50b3BcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLndpZHRoID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodFxuICAgICAgICAmJiBjdXJyZW50UG9zaXRpb24uaGVpZ2h0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheShjb250YWluZXIsIHBhbmUsIHBvc2l0aW9uLCBib3VuZHMsIGdldFBpeGVsUG9zaXRpb25PZmZzZXQpIHtcbiAgICB2YXIgT3ZlcmxheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE92ZXJsYXksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE92ZXJsYXkoY29udGFpbmVyLCBwYW5lLCBwb3NpdGlvbiwgYm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgX3RoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgX3RoaXMuYm91bmRzID0gYm91bmRzO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHBhbmUgPSAoX2EgPSB0aGlzLmdldFBhbmVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0aGlzLnBhbmVdO1xuICAgICAgICAgICAgcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX19hc3NpZ24oe30sICh0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgID8gZ2V0T2Zmc2V0T3ZlcnJpZGUodGhpcy5jb250YWluZXIsIGdldFBpeGVsUG9zaXRpb25PZmZzZXQpXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIGxheW91dFN0eWxlcyA9IGdldExheW91dFN0eWxlcyhwcm9qZWN0aW9uLCBvZmZzZXQsIHRoaXMuYm91bmRzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhsYXlvdXRTdHlsZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE92ZXJsYXk7XG4gICAgfShnb29nbGUubWFwcy5PdmVybGF5VmlldykpO1xuICAgIHJldHVybiBuZXcgT3ZlcmxheShjb250YWluZXIsIHBhbmUsIHBvc2l0aW9uLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9MYXRMbmdTdHJpbmcobGF0TG5nTGlrZSkge1xuICAgIGlmICghbGF0TG5nTGlrZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBsYXRMbmcgPSBsYXRMbmdMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgICAgID8gbGF0TG5nTGlrZVxuICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0TG5nTGlrZS5sYXQsIGxhdExuZ0xpa2UubG5nKTtcbiAgICByZXR1cm4gbGF0TG5nICsgJyc7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYXRMbmdCb3VuZHNTdHJpbmcobGF0TG5nQm91bmRzTGlrZSkge1xuICAgIGlmICghbGF0TG5nQm91bmRzTGlrZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBsYXRMbmdCb3VuZHMgPSBsYXRMbmdCb3VuZHNMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzXG4gICAgICAgID8gbGF0TG5nQm91bmRzTGlrZVxuICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmdCb3VuZHNMaWtlLnNvdXRoLCBsYXRMbmdCb3VuZHNMaWtlLmVhc3QpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdExuZ0JvdW5kc0xpa2Uubm9ydGgsIGxhdExuZ0JvdW5kc0xpa2Uud2VzdCkpO1xuICAgIHJldHVybiBsYXRMbmdCb3VuZHMgKyAnJztcbn1cbnZhciBGTE9BVF9QQU5FID0gXCJmbG9hdFBhbmVcIjtcbnZhciBNQVBfUEFORSA9IFwibWFwUGFuZVwiO1xudmFyIE1BUktFUl9MQVlFUiA9IFwibWFya2VyTGF5ZXJcIjtcbnZhciBPVkVSTEFZX0xBWUVSID0gXCJvdmVybGF5TGF5ZXJcIjtcbnZhciBPVkVSTEFZX01PVVNFX1RBUkdFVCA9IFwib3ZlcmxheU1vdXNlVGFyZ2V0XCI7XG5mdW5jdGlvbiBPdmVybGF5Vmlld0Z1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgYm91bmRzID0gX2EuYm91bmRzLCBtYXBQYW5lTmFtZSA9IF9hLm1hcFBhbmVOYW1lLCB6SW5kZXggPSBfYS56SW5kZXgsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50LCBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0ID0gX2EuZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgbWFwID0gcmVhY3QudXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgY29udGFpbmVyID0gcmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LCBbXSk7XG4gICAgdmFyIG92ZXJsYXkgPSByZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU92ZXJsYXkoY29udGFpbmVyLCBtYXBQYW5lTmFtZSwgcG9zaXRpb24sIGJvdW5kcywgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCk7XG4gICAgfSwgW2NvbnRhaW5lciwgbWFwUGFuZU5hbWUsIHBvc2l0aW9uLCBib3VuZHNdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWQgPT09IG51bGwgfHwgb25Mb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkxvYWQob3ZlcmxheSk7XG4gICAgICAgIG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5zZXRNYXAobWFwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uVW5tb3VudCA9PT0gbnVsbCB8fCBvblVubW91bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVW5tb3VudChvdmVybGF5KTtcbiAgICAgICAgICAgIG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW21hcCwgb3ZlcmxheV0pO1xuICAgIC8vIHRvIG1vdmUgdGhlIGNvbnRhaW5lciB0byB0aGUgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZFxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSBcIlwiLmNvbmNhdCh6SW5kZXgpO1xuICAgIH0sIFt6SW5kZXgsIGNvbnRhaW5lcl0pO1xuICAgIHJldHVybiBSZWFjdERPTV9fbmFtZXNwYWNlLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKTtcbn1cbnZhciBPdmVybGF5Vmlld0YgPSByZWFjdC5tZW1vKE92ZXJsYXlWaWV3RnVuY3Rpb25hbCk7XG52YXIgT3ZlcmxheVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE92ZXJsYXlWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlWaWV3KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHBhbmVFbDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnVwZGF0ZVBhbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFwUGFuZU5hbWUgPSBfdGhpcy5wcm9wcy5tYXBQYW5lTmFtZTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0LzMuZXhwL3JlZmVyZW5jZSNNYXBQYW5lc1xuICAgICAgICAgICAgdmFyIG1hcFBhbmVzID0gX3RoaXMub3ZlcmxheVZpZXcuZ2V0UGFuZXMoKTtcbiAgICAgICAgICAgIGludmFyaWFudCQxKCEhbWFwUGFuZU5hbWUsIFwiT3ZlcmxheVZpZXcgcmVxdWlyZXMgcHJvcHMubWFwUGFuZU5hbWUgYnV0IGdvdCAlc1wiLCBtYXBQYW5lTmFtZSk7XG4gICAgICAgICAgICBpZiAobWFwUGFuZXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVFbDogbWFwUGFuZXNbbWFwUGFuZU5hbWVdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwYW5lRWw6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVBhbmUoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkxvYWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBfdGhpcy5vdmVybGF5Vmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUG9zaXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIG1hcENhbnZhc1Byb2plY3Rpb24gPSBfdGhpcy5vdmVybGF5Vmlldy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX19hc3NpZ24oeyB4OiAwLCB5OiAwIH0sIChfdGhpcy5jb250YWluZXJSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgID8gZ2V0T2Zmc2V0T3ZlcnJpZGUoX3RoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQsIF90aGlzLnByb3BzLmdldFBpeGVsUG9zaXRpb25PZmZzZXQpXG4gICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgdmFyIGxheW91dFN0eWxlcyA9IGdldExheW91dFN0eWxlcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIF90aGlzLnByb3BzLmJvdW5kcywgX3RoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSAoX2EgPSBfdGhpcy5zdGF0ZS5jb250YWluZXJTdHlsZSwgX2EubGVmdCksIHRvcCA9IF9hLnRvcCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFhcmVQb3NpdGlvbnNFcXVhbChsYXlvdXRTdHlsZXMsIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGxheW91dFN0eWxlcy50b3AgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxheW91dFN0eWxlcy5sZWZ0IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbGF5b3V0U3R5bGVzLndpZHRoIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxheW91dFN0eWxlcy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub25Qb3NpdGlvbkVsZW1lbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBwYW5lRWw6IG51bGwsXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25Vbm1vdW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgX3RoaXMub3ZlcmxheVZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jb250YWluZXJSZWYgPSByZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgLy8gWW91IG11c3QgaW1wbGVtZW50IHRocmVlIG1ldGhvZHM6IG9uQWRkKCksIGRyYXcoKSwgYW5kIG9uUmVtb3ZlKCkuXG4gICAgICAgIHZhciBvdmVybGF5VmlldyA9IG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldygpO1xuICAgICAgICBvdmVybGF5Vmlldy5vbkFkZCA9IF90aGlzLm9uQWRkO1xuICAgICAgICBvdmVybGF5Vmlldy5kcmF3ID0gX3RoaXMuZHJhdztcbiAgICAgICAgb3ZlcmxheVZpZXcub25SZW1vdmUgPSBfdGhpcy5vblJlbW92ZTtcbiAgICAgICAgX3RoaXMub3ZlcmxheVZpZXcgPSBvdmVybGF5VmlldztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXcuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgcHJldlBvc2l0aW9uU3RyaW5nID0gY29udmVydFRvTGF0TG5nU3RyaW5nKHByZXZQcm9wcy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBwb3NpdGlvblN0cmluZyA9IGNvbnZlcnRUb0xhdExuZ1N0cmluZyh0aGlzLnByb3BzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHByZXZCb3VuZHNTdHJpbmcgPSBjb252ZXJ0VG9MYXRMbmdCb3VuZHNTdHJpbmcocHJldlByb3BzLmJvdW5kcyk7XG4gICAgICAgIHZhciBib3VuZHNTdHJpbmcgPSBjb252ZXJ0VG9MYXRMbmdCb3VuZHNTdHJpbmcodGhpcy5wcm9wcy5ib3VuZHMpO1xuICAgICAgICBpZiAocHJldlBvc2l0aW9uU3RyaW5nICE9PSBwb3NpdGlvblN0cmluZyB8fFxuICAgICAgICAgICAgcHJldkJvdW5kc1N0cmluZyAhPT0gYm91bmRzU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLm1hcFBhbmVOYW1lICE9PSB0aGlzLnByb3BzLm1hcFBhbmVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnNldE1hcChudWxsKTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYW5lRWwgPSB0aGlzLnN0YXRlLnBhbmVFbDtcbiAgICAgICAgaWYgKHBhbmVFbCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0RE9NX19uYW1lc3BhY2UuY3JlYXRlUG9ydGFsKGpzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNvbnRhaW5lclJlZiwgc3R5bGU6IHRoaXMuc3RhdGUuY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiByZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pIH0pLCBwYW5lRWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LkZMT0FUX1BBTkUgPSBcImZsb2F0UGFuZVwiO1xuICAgIE92ZXJsYXlWaWV3Lk1BUF9QQU5FID0gXCJtYXBQYW5lXCI7XG4gICAgT3ZlcmxheVZpZXcuTUFSS0VSX0xBWUVSID0gXCJtYXJrZXJMYXllclwiO1xuICAgIE92ZXJsYXlWaWV3Lk9WRVJMQVlfTEFZRVIgPSBcIm92ZXJsYXlMYXllclwiO1xuICAgIE92ZXJsYXlWaWV3Lk9WRVJMQVlfTU9VU0VfVEFSR0VUID0gXCJvdmVybGF5TW91c2VUYXJnZXRcIjtcbiAgICBPdmVybGF5Vmlldy5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIE92ZXJsYXlWaWV3O1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IHJldHVybjsgfVxuXG52YXIgZXZlbnRNYXAkNSA9IHtcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uQ2xpY2s6ICdjbGljaycsXG59O1xudmFyIHVwZGF0ZXJNYXAkNSA9IHtcbiAgICBvcGFjaXR5OiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wYWNpdHkpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIEdyb3VuZE92ZXJsYXlGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIHVybCA9IF9hLnVybCwgYm91bmRzID0gX2EuYm91bmRzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgdmlzaWJsZSA9IF9hLnZpc2libGU7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIGltYWdlQm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyhuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5zb3V0aCwgYm91bmRzLndlc3QpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5ub3J0aCwgYm91bmRzLmVhc3QpKTtcbiAgICB2YXIgZ3JvdW5kT3ZlcmxheSA9IHJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3ZlcmxheSA9IG5ldyBnb29nbGUubWFwcy5Hcm91bmRPdmVybGF5KHVybCwgaW1hZ2VCb3VuZHMsIF9fYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBvdmVybGF5O1xuICAgIH0sIFtdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheS5zZXQoXCJ1cmxcIiwgdXJsKTtcbiAgICAgICAgICAgIGdyb3VuZE92ZXJsYXkuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbZ3JvdW5kT3ZlcmxheSwgdXJsXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBncm91bmRPdmVybGF5LnNldE9wYWNpdHkodmlzaWJsZSA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgIH0sIFtncm91bmRPdmVybGF5LCB2aXNpYmxlXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0JvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuc291dGgsIGJvdW5kcy53ZXN0KSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMubm9ydGgsIGJvdW5kcy5lYXN0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgYm91bmRzICE9PSAndW5kZWZpbmVkJyAmJiBncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBncm91bmRPdmVybGF5LnNldChcImJvdW5kc1wiLCBuZXdCb3VuZHMpO1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFtncm91bmRPdmVybGF5LCBib3VuZHNdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBHcm91bmRPdmVybGF5RiA9IHJlYWN0Lm1lbW8oR3JvdW5kT3ZlcmxheUZ1bmN0aW9uYWwpO1xudmFyIEdyb3VuZE92ZXJsYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VuZE92ZXJsYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdW5kT3ZlcmxheSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBncm91bmRPdmVybGF5OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRHcm91bmRPdmVybGF5Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR3JvdW5kT3ZlcmxheS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhdGhpcy5wcm9wcy51cmwgfHwgISF0aGlzLnByb3BzLmJvdW5kcywgXCJGb3IgR3JvdW5kT3ZlcmxheSwgdXJsIGFuZCBib3VuZHMgYXJlIHBhc3NlZCBpbiB0byBjb25zdHJ1Y3RvciBhbmQgYXJlIGltbXV0YWJsZSBhZnRlciBpbnN0YW50aWF0ZWQuIFRoaXMgaXMgdGhlIGJlaGF2aW9yIG9mIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHYzICggU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNHcm91bmRPdmVybGF5KSBIZW5jZSwgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHR3byBwcm9wcyBwcm92aWRlZCBieSBgcmVhY3QtZ29vZ2xlLW1hcHMtYXBpYCwgdXJsIGFuZCBib3VuZHMuIEluIHNvbWUgY2FzZXMsIHlvdSdsbCBuZWVkIHRoZSBHcm91bmRPdmVybGF5IGNvbXBvbmVudCB0byByZWZsZWN0IHRoZSBjaGFuZ2VzIG9mIHVybCBhbmQgYm91bmRzLiBZb3UgY2FuIGxldmVyYWdlIHRoZSBSZWFjdCdzIGtleSBwcm9wZXJ0eSB0byByZW1vdW50IHRoZSBjb21wb25lbnQuIFR5cGljYWxseSwganVzdCBga2V5PXt1cmx9YCB3b3VsZCBzZXJ2ZSB5b3VyIG5lZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdG9tY2hlbnR3L3JlYWN0LWdvb2dsZS1tYXBzL2lzc3Vlcy82NTVcIik7XG4gICAgICAgIHZhciBncm91bmRPdmVybGF5ID0gbmV3IGdvb2dsZS5tYXBzLkdyb3VuZE92ZXJsYXkodGhpcy5wcm9wcy51cmwsIHRoaXMucHJvcHMuYm91bmRzLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5vcHRpb25zKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ1LFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDUsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGdyb3VuZE92ZXJsYXksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldEdyb3VuZE92ZXJsYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VuZE92ZXJsYXk6IGdyb3VuZE92ZXJsYXksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldEdyb3VuZE92ZXJsYXlDYWxsYmFjayk7XG4gICAgfTtcbiAgICBHcm91bmRPdmVybGF5LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91bmRPdmVybGF5LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb3VuZE92ZXJsYXkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBHcm91bmRPdmVybGF5LmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgb25Mb2FkOiBub29wLFxuICAgIH07XG4gICAgR3JvdW5kT3ZlcmxheS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEdyb3VuZE92ZXJsYXk7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJDQgPSB7fTtcbnZhciB1cGRhdGVyTWFwJDQgPSB7XG4gICAgZGF0YTogZnVuY3Rpb24gKGluc3RhbmNlLCBkYXRhKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERhdGEoZGF0YSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBIZWF0bWFwTGF5ZXJGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudCwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgdmFyIG1hcCA9IHJlYWN0LnVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gcmVhY3QudXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFnb29nbGUubWFwcy52aXN1YWxpemF0aW9uKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSghIWdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24sICdEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1tcInZpc3VhbGl6YXRpb25cIl19IGluIHVzZUpzQXBpU2NyaXB0PyAlcycsIGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhZGF0YSwgJ2RhdGEgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gSGVhdG1hcExheWVyICVzJywgZGF0YSk7XG4gICAgfSwgW2RhdGFdKTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVhdG1hcExheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uSGVhdG1hcExheWVyKF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCB7fSkpLCB7IGRhdGE6IGRhdGEsIG1hcDogbWFwIH0pKTtcbiAgICAgICAgc2V0SW5zdGFuY2UoaGVhdG1hcExheWVyKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKGhlYXRtYXBMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBIZWF0bWFwTGF5ZXJGID0gcmVhY3QubWVtbyhIZWF0bWFwTGF5ZXJGdW5jdGlvbmFsKTtcbnZhciBIZWF0bWFwTGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYXRtYXBMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWF0bWFwTGF5ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaGVhdG1hcExheWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRIZWF0bWFwTGF5ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmhlYXRtYXBMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSGVhdG1hcExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50JDEoISFnb29nbGUubWFwcy52aXN1YWxpemF0aW9uLCAnRGlkIHlvdSBpbmNsdWRlIHByb3AgbGlicmFyaWVzPXtbXCJ2aXN1YWxpemF0aW9uXCJdfSB0byA8TG9hZFNjcmlwdCAvPj8gJXMnLCBnb29nbGUubWFwcy52aXN1YWxpemF0aW9uKTtcbiAgICAgICAgaW52YXJpYW50JDEoISF0aGlzLnByb3BzLmRhdGEsICdkYXRhIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIEhlYXRtYXBMYXllciAlcycsIHRoaXMucHJvcHMuZGF0YSk7XG4gICAgICAgIHZhciBoZWF0bWFwTGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMudmlzdWFsaXphdGlvbi5IZWF0bWFwTGF5ZXIoX19hc3NpZ24oX19hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBkYXRhOiB0aGlzLnByb3BzLmRhdGEsIG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDQsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogaGVhdG1hcExheWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRIZWF0bWFwTGF5ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhlYXRtYXBMYXllcjogaGVhdG1hcExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRIZWF0bWFwTGF5ZXJDYWxsYmFjayk7XG4gICAgfTtcbiAgICBIZWF0bWFwTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNCxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ0LFxuICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVhdG1hcExheWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGVhdG1hcExheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLmhlYXRtYXBMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhlYXRtYXBMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhlYXRtYXBMYXllci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEhlYXRtYXBMYXllci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEhlYXRtYXBMYXllcjtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkMyA9IHtcbiAgICBvbkNsb3NlQ2xpY2s6ICdjbG9zZWNsaWNrJyxcbiAgICBvblBhbm9DaGFuZ2VkOiAncGFub19jaGFuZ2VkJyxcbiAgICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICAgIG9uUG92Q2hhbmdlZDogJ3Bvdl9jaGFuZ2VkJyxcbiAgICBvblJlc2l6ZTogJ3Jlc2l6ZScsXG4gICAgb25TdGF0dXNDaGFuZ2VkOiAnc3RhdHVzX2NoYW5nZWQnLFxuICAgIG9uVmlzaWJsZUNoYW5nZWQ6ICd2aXNpYmxlX2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJDMgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJQYW5vUHJvdmlkZXIocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgbGlua3M6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbGlua3MpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TGlua3MobGlua3MpO1xuICAgIH0sXG4gICAgbW90aW9uVHJhY2tpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbW90aW9uVHJhY2tpbmcpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TW90aW9uVHJhY2tpbmcobW90aW9uVHJhY2tpbmcpO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYW5vOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhbm8pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGFubyhwYW5vKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHBvdjogZnVuY3Rpb24gKGluc3RhbmNlLCBwb3YpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UG92KHBvdik7XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uIChpbnN0YW5jZSwgem9vbSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRab29tKHpvb20pO1xuICAgIH0sXG59O1xudmFyIFN0cmVldFZpZXdQYW5vcmFtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWV0Vmlld1Bhbm9yYW1hLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmVldFZpZXdQYW5vcmFtYSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdHJlZXRWaWV3UGFub3JhbWE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFN0cmVldFZpZXdQYW5vcmFtYUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdHJlZXRWaWV3UGFub3JhbWEucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgc3RyZWV0Vmlld1Bhbm9yYW1hID0gKF9iID0gKF9hID0gdGhpcy5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RyZWV0VmlldygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMyxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQzLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBzdHJlZXRWaWV3UGFub3JhbWEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RyZWV0Vmlld1Bhbm9yYW1hOiBzdHJlZXRWaWV3UGFub3JhbWEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFN0cmVldFZpZXdQYW5vcmFtYUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFN0cmVldFZpZXdQYW5vcmFtYS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVldFZpZXdQYW5vcmFtYS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVldFZpZXdQYW5vcmFtYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0cmVldFZpZXdQYW5vcmFtYS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIFN0cmVldFZpZXdQYW5vcmFtYTtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgU3RyZWV0Vmlld1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVldFZpZXdTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmVldFZpZXdTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdHJlZXRWaWV3U2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0U3RyZWV0Vmlld1NlcnZpY2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuc3RyZWV0Vmlld1NlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0cmVldFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmVldFZpZXdTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLlN0cmVldFZpZXdTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0U3RyZWV0Vmlld1NlcnZpY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmVldFZpZXdTZXJ2aWNlOiBzdHJlZXRWaWV3U2VydmljZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0U3RyZWV0Vmlld1NlcnZpY2VDYWxsYmFjayk7XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3U2VydmljZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWV0Vmlld1NlcnZpY2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3U2VydmljZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIFN0cmVldFZpZXdTZXJ2aWNlO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBEaXJlY3Rpb25zU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlyZWN0aW9uc1NlcnZpY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uc1NlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbnNTZXJ2aWNlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXREaXJlY3Rpb25zU2VydmljZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmRpcmVjdGlvbnNTZXJ2aWNlICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGlyZWN0aW9uc1NlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQkMSghIXRoaXMucHJvcHMub3B0aW9ucywgJ0RpcmVjdGlvbnNTZXJ2aWNlIGV4cGVjdGVkIG9wdGlvbnMgb2JqZWN0IGFzIHBhcmFtZXRlciwgYnV0IGdvdCAlcycsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25zU2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERpcmVjdGlvbnNTZXJ2aWNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zU2VydmljZTogZGlyZWN0aW9uc1NlcnZpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldERpcmVjdGlvbnNTZXJ2aWNlQ2FsbGJhY2spO1xuICAgIH07XG4gICAgRGlyZWN0aW9uc1NlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2Uucm91dGUodGhpcy5wcm9wcy5vcHRpb25zLCB0aGlzLnByb3BzLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlyZWN0aW9uc1NlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGlvbnNTZXJ2aWNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGlvbnNTZXJ2aWNlO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQyID0ge1xuICAgIG9uRGlyZWN0aW9uc0NoYW5nZWQ6ICdkaXJlY3Rpb25zX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJDIgPSB7XG4gICAgZGlyZWN0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBkaXJlY3Rpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERpcmVjdGlvbnMoZGlyZWN0aW9ucyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYW5lbDogZnVuY3Rpb24gKGluc3RhbmNlLCBwYW5lbCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQYW5lbChwYW5lbCk7XG4gICAgfSxcbiAgICByb3V0ZUluZGV4OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHJvdXRlSW5kZXgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Um91dGVJbmRleChyb3V0ZUluZGV4KTtcbiAgICB9LFxufTtcbnZhciBEaXJlY3Rpb25zUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpcmVjdGlvbnNSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXJlY3Rpb25zUmVuZGVyZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXREaXJlY3Rpb25zUmVuZGVyZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIuc2V0TWFwKF90aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpcmVjdGlvbnNSZW5kZXJlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb25zUmVuZGVyZXIgPSBuZXcgZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1JlbmRlcmVyKHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQyLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDIsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGRpcmVjdGlvbnNSZW5kZXJlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RGlyZWN0aW9uc1JlbmRlcmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zUmVuZGVyZXI6IGRpcmVjdGlvbnNSZW5kZXJlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0RGlyZWN0aW9uc1JlbmRlcmVyQ2FsbGJhY2spO1xuICAgIH07XG4gICAgRGlyZWN0aW9uc1JlbmRlcmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQyLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQyLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlyZWN0aW9uc1JlbmRlcmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlci5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGlvbnNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ganN4UnVudGltZS5qc3goanN4UnVudGltZS5GcmFnbWVudCwge30pO1xuICAgIH07XG4gICAgRGlyZWN0aW9uc1JlbmRlcmVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gRGlyZWN0aW9uc1JlbmRlcmVyO1xufShyZWFjdC5QdXJlQ29tcG9uZW50KSk7XG5cbnZhciBEaXN0YW5jZU1hdHJpeFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RhbmNlTWF0cml4U2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0YW5jZU1hdHJpeFNlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0RGlzdGFuY2VNYXRyaXhTZXJ2aWNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpc3RhbmNlTWF0cml4U2VydmljZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhdGhpcy5wcm9wcy5vcHRpb25zLCAnRGlzdGFuY2VNYXRyaXhTZXJ2aWNlIGV4cGVjdGVkIG9wdGlvbnMgb2JqZWN0IGFzIHBhcmFtZXRlciwgYnV0IGdvICVzJywgdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0cml4U2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXN0YW5jZU1hdHJpeFNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXREaXN0YW5jZU1hdHJpeFNlcnZpY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZTogZGlzdGFuY2VNYXRyaXhTZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREaXN0YW5jZU1hdHJpeFNlcnZpY2VDYWxsYmFjayk7XG4gICAgfTtcbiAgICBEaXN0YW5jZU1hdHJpeFNlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpc3RhbmNlTWF0cml4U2VydmljZS5nZXREaXN0YW5jZU1hdHJpeCh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXN0YW5jZU1hdHJpeFNlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzdGFuY2VNYXRyaXhTZXJ2aWNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RhbmNlTWF0cml4U2VydmljZTtcbn0ocmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkMSA9IHtcbiAgICBvblBsYWNlc0NoYW5nZWQ6ICdwbGFjZXNfY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAkMSA9IHtcbiAgICBib3VuZHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgYm91bmRzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH0sXG59O1xudmFyIFN0YW5kYWxvbmVTZWFyY2hCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YW5kYWxvbmVTZWFyY2hCb3gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhbmRhbG9uZVNlYXJjaEJveCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyRWxlbWVudCA9IHJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlYXJjaEJveDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0U2VhcmNoQm94Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5zZWFyY2hCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQkMSghIWdvb2dsZS5tYXBzLnBsYWNlcywgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgbGlicmFyaWVzPXtbXCJwbGFjZXNcIl19IHByb3AgdG8gPExvYWRTY3JpcHQgLz4gY29tcG9uZW50ICVzJywgZ29vZ2xlLm1hcHMucGxhY2VzKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyRWxlbWVudCAhPT0gbnVsbCAmJiB0aGlzLmNvbnRhaW5lckVsZW1lbnQuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hCb3hfMSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuU2VhcmNoQm94KGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQxLFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWFyY2hCb3hfMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFNlYXJjaEJveCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEJveDogc2VhcmNoQm94XzEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRTZWFyY2hCb3hDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDEsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnNlYXJjaEJveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGFuZGFsb25lU2VhcmNoQm94LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnNlYXJjaEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWUuanN4KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmNvbnRhaW5lckVsZW1lbnQsIGNoaWxkcmVuOiByZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pIH0pO1xuICAgIH07XG4gICAgU3RhbmRhbG9uZVNlYXJjaEJveC5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIFN0YW5kYWxvbmVTZWFyY2hCb3g7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwID0ge1xuICAgIG9uUGxhY2VDaGFuZ2VkOiAncGxhY2VfY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAgPSB7XG4gICAgYm91bmRzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICB9LFxuICAgIHJlc3RyaWN0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCByZXN0cmljdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29tcG9uZW50UmVzdHJpY3Rpb25zKHJlc3RyaWN0aW9ucyk7XG4gICAgfSxcbiAgICBmaWVsZHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZmllbGRzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICB0eXBlczogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRUeXBlcyh0eXBlcyk7XG4gICAgfSxcbn07XG52YXIgQXV0b2NvbXBsZXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdXRvY29tcGxldGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXV0b2NvbXBsZXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5jb250YWluZXJFbGVtZW50ID0gcmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRBdXRvY29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hdXRvY29tcGxldGUgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmF1dG9jb21wbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpbnZhcmlhbnQkMSghIWdvb2dsZS5tYXBzLnBsYWNlcywgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgbGlicmFyaWVzPXtbXCJwbGFjZXNcIl19IHByb3AgdG8gPExvYWRTY3JpcHQgLz4gY29tcG9uZW50ICVzJywgZ29vZ2xlLm1hcHMucGxhY2VzKTtcbiAgICAgICAgLy8gVE9ETzogd2h5IGN1cnJlbnQgY291bGQgYmUgZXF1YWwgbnVsbD9cbiAgICAgICAgdmFyIGlucHV0ID0gKF9hID0gdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBhdXRvY29tcGxldGVfMSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGF1dG9jb21wbGV0ZV8xLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IGF1dG9jb21wbGV0ZV8xLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzLnNldEF1dG9jb21wbGV0ZUNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwLFxuICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5hdXRvY29tcGxldGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ganN4UnVudGltZS5qc3goXCJkaXZcIiwgeyByZWY6IHRoaXMuY29udGFpbmVyRWxlbWVudCwgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSwgY2hpbGRyZW46IHJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgfSk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6ICcnXG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBBdXRvY29tcGxldGU7XG59KHJlYWN0LlB1cmVDb21wb25lbnQpKTtcblxuZXhwb3J0cy5BdXRvY29tcGxldGUgPSBBdXRvY29tcGxldGU7XG5leHBvcnRzLkJpY3ljbGluZ0xheWVyID0gQmljeWNsaW5nTGF5ZXI7XG5leHBvcnRzLkJpY3ljbGluZ0xheWVyRiA9IEJpY3ljbGluZ0xheWVyRjtcbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuZXhwb3J0cy5DaXJjbGVGID0gQ2lyY2xlRjtcbmV4cG9ydHMuRGF0YSA9IERhdGE7XG5leHBvcnRzLkRhdGFGID0gRGF0YUY7XG5leHBvcnRzLkRpcmVjdGlvbnNSZW5kZXJlciA9IERpcmVjdGlvbnNSZW5kZXJlcjtcbmV4cG9ydHMuRGlyZWN0aW9uc1NlcnZpY2UgPSBEaXJlY3Rpb25zU2VydmljZTtcbmV4cG9ydHMuRGlzdGFuY2VNYXRyaXhTZXJ2aWNlID0gRGlzdGFuY2VNYXRyaXhTZXJ2aWNlO1xuZXhwb3J0cy5EcmF3aW5nTWFuYWdlciA9IERyYXdpbmdNYW5hZ2VyO1xuZXhwb3J0cy5EcmF3aW5nTWFuYWdlckYgPSBEcmF3aW5nTWFuYWdlckY7XG5leHBvcnRzLkZMT0FUX1BBTkUgPSBGTE9BVF9QQU5FO1xuZXhwb3J0cy5Hb29nbGVNYXAgPSBHb29nbGVNYXA7XG5leHBvcnRzLkdvb2dsZU1hcHNNYXJrZXJDbHVzdGVyZXIgPSBpbmRleF9lc207XG5leHBvcnRzLkdvb2dsZU1hcmtlckNsdXN0ZXJlciA9IEdvb2dsZU1hcmtlckNsdXN0ZXJlciQxO1xuZXhwb3J0cy5Hcm91bmRPdmVybGF5ID0gR3JvdW5kT3ZlcmxheTtcbmV4cG9ydHMuR3JvdW5kT3ZlcmxheUYgPSBHcm91bmRPdmVybGF5RjtcbmV4cG9ydHMuSGVhdG1hcExheWVyID0gSGVhdG1hcExheWVyO1xuZXhwb3J0cy5IZWF0bWFwTGF5ZXJGID0gSGVhdG1hcExheWVyRjtcbmV4cG9ydHMuSW5mb0JveCA9IEluZm9Cb3hDb21wb25lbnQ7XG5leHBvcnRzLkluZm9Cb3hGID0gSW5mb0JveEY7XG5leHBvcnRzLkluZm9XaW5kb3cgPSBJbmZvV2luZG93O1xuZXhwb3J0cy5JbmZvV2luZG93RiA9IEluZm9XaW5kb3dGO1xuZXhwb3J0cy5LbWxMYXllciA9IEttbExheWVyO1xuZXhwb3J0cy5Mb2FkU2NyaXB0ID0gTG9hZFNjcmlwdDtcbmV4cG9ydHMuTG9hZFNjcmlwdE5leHQgPSBMb2FkU2NyaXB0TmV4dCQxO1xuZXhwb3J0cy5NQVBfUEFORSA9IE1BUF9QQU5FO1xuZXhwb3J0cy5NQVJLRVJfTEFZRVIgPSBNQVJLRVJfTEFZRVI7XG5leHBvcnRzLk1hcENvbnRleHQgPSBNYXBDb250ZXh0O1xuZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG5leHBvcnRzLk1hcmtlckNsdXN0ZXJlciA9IENsdXN0ZXJlckNvbXBvbmVudDtcbmV4cG9ydHMuTWFya2VyQ2x1c3RlcmVyRiA9IE1hcmtlckNsdXN0ZXJlckY7XG5leHBvcnRzLk1hcmtlckYgPSBNYXJrZXJGO1xuZXhwb3J0cy5PVkVSTEFZX0xBWUVSID0gT1ZFUkxBWV9MQVlFUjtcbmV4cG9ydHMuT1ZFUkxBWV9NT1VTRV9UQVJHRVQgPSBPVkVSTEFZX01PVVNFX1RBUkdFVDtcbmV4cG9ydHMuT3ZlcmxheVZpZXcgPSBPdmVybGF5VmlldztcbmV4cG9ydHMuT3ZlcmxheVZpZXdGID0gT3ZlcmxheVZpZXdGO1xuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcbmV4cG9ydHMuUG9seWdvbkYgPSBQb2x5Z29uRjtcbmV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcbmV4cG9ydHMuUG9seWxpbmVGID0gUG9seWxpbmVGO1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5leHBvcnRzLlJlY3RhbmdsZUYgPSBSZWN0YW5nbGVGO1xuZXhwb3J0cy5TdGFuZGFsb25lU2VhcmNoQm94ID0gU3RhbmRhbG9uZVNlYXJjaEJveDtcbmV4cG9ydHMuU3RyZWV0Vmlld1Bhbm9yYW1hID0gU3RyZWV0Vmlld1Bhbm9yYW1hO1xuZXhwb3J0cy5TdHJlZXRWaWV3U2VydmljZSA9IFN0cmVldFZpZXdTZXJ2aWNlO1xuZXhwb3J0cy5UcmFmZmljTGF5ZXIgPSBUcmFmZmljTGF5ZXI7XG5leHBvcnRzLlRyYWZmaWNMYXllckYgPSBUcmFmZmljTGF5ZXJGO1xuZXhwb3J0cy5UcmFuc2l0TGF5ZXIgPSBUcmFuc2l0TGF5ZXI7XG5leHBvcnRzLlRyYW5zaXRMYXllckYgPSBUcmFuc2l0TGF5ZXJGO1xuZXhwb3J0cy51c2VHb29nbGVNYXAgPSB1c2VHb29nbGVNYXA7XG5leHBvcnRzLnVzZUpzQXBpTG9hZGVyID0gdXNlSnNBcGlMb2FkZXI7XG5leHBvcnRzLnVzZUxvYWRTY3JpcHQgPSB1c2VMb2FkU2NyaXB0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-google-maps/api/dist/cjs.js\n");

/***/ })

};
;